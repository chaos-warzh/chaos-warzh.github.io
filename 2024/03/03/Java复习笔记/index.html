<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java复习笔记 | chaos-warzh's blog</title><meta name="author" content="Zhaohui Wang"><meta name="copyright" content="Zhaohui Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java复习笔记 Java-Lesson 0 (Resources)  Java 8 官方文档: https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F; Google Java Style Guide: https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;javaguide.html  Java-Lesson 1 (Basic Grammar)">
<meta property="og:type" content="article">
<meta property="og:title" content="Java复习笔记">
<meta property="og:url" content="https://chaos-warzh.github.io/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="chaos-warzh&#39;s blog">
<meta property="og:description" content="Java复习笔记 Java-Lesson 0 (Resources)  Java 8 官方文档: https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F; Google Java Style Guide: https:&#x2F;&#x2F;google.github.io&#x2F;styleguide&#x2F;javaguide.html  Java-Lesson 1 (Basic Grammar)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaos-warzh.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-03-03T03:04:49.000Z">
<meta property="article:modified_time" content="2025-02-25T09:10:02.784Z">
<meta property="article:author" content="Zhaohui Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaos-warzh.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java复习笔记",
  "url": "https://chaos-warzh.github.io/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://chaos-warzh.github.io/img/butterfly-icon.png",
  "datePublished": "2024-03-03T03:04:49.000Z",
  "dateModified": "2025-02-25T09:10:02.784Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zhaohui Wang",
      "url": "https://chaos-warzh.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaos-warzh.github.io/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java复习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.1.1"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">chaos-warzh's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java复习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java复习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-03T03:04:49.000Z" title="发表于 2024-03-03 11:04:49">2024-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-25T09:10:02.784Z" title="更新于 2025-02-25 17:10:02">2025-02-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Java复习笔记</h1>
<h2 id="Java-Lesson-0-Resources">Java-Lesson 0 (Resources)</h2>
<ol>
<li>Java 8 官方文档: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></li>
<li>Google Java Style Guide: <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/javaguide.html">https://google.github.io/styleguide/javaguide.html</a></li>
</ol>
<h2 id="Java-Lesson-1-Basic-Grammar">Java-Lesson 1 (Basic Grammar)</h2>
<ol>
<li>
<p>标识符: 标识类/ 变量/ 常量和方法的名字, 由字母 (A-Z, a-z) / 特殊符号(<strong>$</strong>, _) 和数字 (0-9) 构成, 区分大小写, 名字的第一个字符不能为数字, 标识符不可为Java关键字.</p>
</li>
<li>
<p>Java数据类型可分为<strong>基本数据类型 ( Primitive type )<strong>和</strong>引用数据类型 ( Reference type )</strong>, 数组和对象都是引用数据类型.</p>
</li>
<li>
<p>Java基本数据类型有<code>byte</code>: -128~127 (1 byte) 的整数, <code>boolean</code>: 布尔型 (实际占1 byte), <code>char</code>: 占2 byte, (16-bit unicode)</p>
</li>
<li>
<p>Java大数: 对于高精度计算的需求, Java Math库提供了BigInteger 和 BigDecimal 以满足任意长度的整数运算和任意精度的浮点数运算, 有一些常量, 如 <code>BigInteger.ZERO</code>  <code>BigInteger.TEN</code>, 但是由于Java不像C++那样支持运算符重载, 所以其运算不是使用 + * , 而是add() multiply() 等.</p>
</li>
<li>
<p>Java也支持下划线分隔整数或浮点数, 以及科学记数法 (E或e).  <code>long hex = 0x7f_e9_b7_aa; float expf = 1.39E-43f;</code></p>
</li>
<li>
<p>final关键字, 修饰常量. 常量命名常常全部大写 (<strong><code>final</code></strong>: 最后的, 没有后继者(不被修改/改写, 不能被继承…) )</p>
</li>
<li>
<p>Java允许int类型溢出, 这一点与C十分相似.</p>
</li>
<li>
<p>java中的最大整数常量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型转换: 自动类型转换 – 类型提升 强制类型转换 <code>(&lt;type&gt;)vari</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">doubleNum</span> <span class="operator">=</span> <span class="number">9.9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intNum</span> <span class="operator">=</span> (<span class="type">int</span>)doubleNum; <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>main() 方法要给外部JVM程序调用, 所以必须为public, 在对象没产生前, main()方法就已被JVM调用, 所以必须为static (类方法/ 静态方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="comment">// 访问修饰符 关键字 返回类型 方法名(参数)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-2-Control-Flow-Container">Java-Lesson 2 (Control Flow, Container)</h2>
<ol>
<li>
<p>switch语句中default的使用细节:</p>
<ol>
<li>default可以随意与case语句更换位置, 不论其在哪, 都是最后被执行</li>
<li>default语句如果在所有case后面使用, 则可以不用break语句</li>
<li>default语句如果在部分case之前, 或在所有case之前, 则建议在其语句中加入break语句. 否则, 执行完default语句后, 会从上往下顺序执行case语句, 直到遇到break语句, 如果一直不遇到break语句, 则<strong>执行完default下方所有的</strong>case语句.</li>
</ol>
</li>
<li>
<p><code>switch</code>的新特性: <strong>switch 表达式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DaysInMonth</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">today</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> today.get(Calendar.MONTH);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> today.get(Calendar.YEAR);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">            <span class="keyword">case</span> Calendar.JANUARY,</span><br><span class="line">                 Calendar.MARCH,</span><br><span class="line">                 Calendar.MAY,</span><br><span class="line">                 Calendar.JULY,</span><br><span class="line">                 Calendar.AUGUST,</span><br><span class="line">                 Calendar.OCTOBER,</span><br><span class="line">                 Calendar.DECEMBER -&gt; <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> Calendar.APRIL,</span><br><span class="line">                 Calendar.JUNE,</span><br><span class="line">                 Calendar.SEPTEMBER,</span><br><span class="line">                 Calendar.NOVEMBER -&gt; <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> Calendar.FEBRUARY -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; !(year % <span class="number">100</span> == <span class="number">0</span>))</span><br><span class="line">                        || (year % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">yield</span> <span class="number">29</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">yield</span> <span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Calendar in JDK does not work&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;There are &quot;</span> + daysInMonth + <span class="string">&quot; days in this month.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意, 与C的区别, 分支的控制变量也可以是<strong>字符串</strong>.</p>
<p>变化1, switch 代码块出现在了赋值运算符的右侧. 这也就意味着, 这个 switch 代码块表示的是一个<strong>数值</strong>, 或者是一个变量. 换句话说, 这个 switch 代码块是一个表达式.</p>
<p>变化2, 是多情景的合并. 也就是说, 一个 case 语句, 可以处理多个情景. 这些情景, 使用逗号分隔开来, 共享一个代码块.</p>
<p>变化3, 无break.</p>
<p>变化4, <code>-&gt;</code>, 箭头标识符, 这个符号使用在 case 语句里, “case L -&gt;”. L就是要匹配的一个或者多个情景. 替代的是传统冒号标识符<code>:</code> , 但我们依然可以在 switch 表达式里使用冒号标识符, 使用冒号标识符的一个 case 语句只能匹配<strong>一个</strong>情景 (但是极不推荐你用这种形式).</p>
<p>变化5, 是箭头标识符的右侧, 可以是表达式/ 代码块或者异常抛出语句, 而不能是其他的形式. 如果只需要一个语句, 这个语句也要以代码块的形式呈现出来. (<strong>即必须括上大括号</strong>, 否则报错)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Calendar.JANUARY,</span><br><span class="line">     <span class="comment">// snipped</span></span><br><span class="line">     Calendar.DECEMBER -&gt; &#123;  <span class="comment">// CORRECT, enclosed with braces.</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>foreach语法 <code>for (char c : array1) &#123; System.out.println(c); &#125;</code></p>
</li>
<li>
<p>break标签 (, continue标签) : 可以打破任意层循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Loop1: </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Loop2: </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> Loop1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>int[][] a = new int[3][4]; //矩阵 </code></p>
<p><code>int[][] a = new int[3][]; //不规则</code></p>
<p><code>a[0] = new int[3] &#123;1, 1, 4&#125;</code></p>
</li>
<li>
<p><code>ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; food = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">food.add(<span class="string">&quot;pizza&quot;</span>); <span class="comment">// 增</span></span><br><span class="line">food.set(<span class="number">0</span>, <span class="string">&quot;pasta&quot;</span>); <span class="comment">// 改</span></span><br><span class="line">System.out.println(food.get(<span class="number">0</span>)); <span class="comment">// 查</span></span><br><span class="line">food.remove(<span class="number">0</span>); <span class="comment">// 删</span></span><br><span class="line">food.size();</span><br><span class="line">food.clear;</span><br></pre></td></tr></table></figure>
<p><strong>排序</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line">Collections.sort(food, Comparator.reverseOrder()); <span class="comment">// 列表排序, 而数组排序用Arrays.</span></span><br></pre></td></tr></table></figure>
<p><code>arraylist.sort(Comparator c)</code>  <code>list.sort(Comparator.reverseOrder()); // 从大到小排序</code></p>
<p><code>addAll(int index, Collection c)</code> 将c中所有元素插入到ArrayList中index的位置. (index缺省时为尾插)</p>
<p><code>removeIf(Predicate&lt;E&gt; filter)</code>  如 <code>list.removeIf(e -&gt; e.contains(&quot;Tao&quot;))</code></p>
<p><code>clone()</code> 复制一份 <code>contains</code>  <code>indexOf()</code>返回元素的索引</p>
<p><code>subList()</code> <code>toArray()</code> <code>toString()</code></p>
</li>
<li>
<p>注意, List只能装对象, <strong>不能装原始类型(int/ char/ float)</strong>! 所以常常要类型转换为<code>Integer</code>等类.</p>
</li>
<li>
<p>列表<code>ArrayList</code> 用作动态数组:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 为什么不用List来new一个对象, 因为Java中List是接口, 而ArrayList可以看作是一个实现. List里面的方法, ArrayList都有</span></span><br><span class="line">L.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; L1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">L1.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(L1);  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ArrayList</code>初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>));</span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ArrayList</code> <strong>二维</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;String&gt;&gt; groceryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">groceryList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>().add(<span class="string">&quot;soda&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝数组: (比for循环拷贝更快)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, <span class="number">2</span>, dst, <span class="number">0</span>, <span class="number">7</span>); <span class="comment">// src, 偏移量, dst, 偏移量, 复制元素的个数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Arrays类中常用函数</p>
<ul>
<li><code>Arrays.sort(array)</code> – 将<strong>数组</strong>排序 (升序)</li>
<li><code>Arrays.toString()</code> – 将数组变为已读的字符串</li>
<li><code>Arrays.asList()</code> – 将数组<strong>转换成列表</strong> <code>Arrays.asList()</code>方法返回由指定数组支持的固定大小的列表. 由于无法对数组进行结构修改, 因此无法向列表中添加元素或从中删除元素. 该列表将抛出一个<code>UnsupportedOperationException</code> 如果对其执行任何调整大小操作.</li>
</ul>
</li>
<li>
<p>List与数组之间相互转换</p>
<ul>
<li>数组 -&gt; List</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="comment">// int[] -&gt; Integer[]</span></span><br><span class="line">Integer[] boxB = Arrays.stream(b).boxed().toArray(Integer[]::<span class="keyword">new</span>); </span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(boxB));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">25</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, a); <span class="comment">// 利用集合工具类</span></span><br></pre></td></tr></table></figure>
<ul>
<li>List -&gt; 数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List转Object[]</span></span><br><span class="line">Object[] objs = list.toArray();</span><br><span class="line"><span class="comment">// Object[] 转Integer[]</span></span><br><span class="line">Integer[] nums = Arrays.stream(objs).toArray(Integer::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// Integer[] 转int[]</span></span><br><span class="line"><span class="type">int</span>[] arr = Arrays.stream(nums).mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = list.stream().mapToInt(Integer::intValue).toArray;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="type">int</span>[] arr = list.stream().mapToInt(Integer::valueOf).toArray;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java HashMap, 类似Python的字典.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;           </span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;BMW&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;BMW&quot;</span>)); <span class="comment">// 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	Map&lt;String, String&gt; L = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 这是一种泛型的写法 </span></span><br><span class="line"> 	L.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;woof&quot;</span>);</span><br><span class="line"> 	L.put(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;meow&quot;</span>);</span><br><span class="line"> 	<span class="type">String</span> <span class="variable">sound</span> <span class="operator">=</span> L.get(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-3-File-Exception">Java-Lesson 3 (File, Exception)</h2>
<ol>
<li>
<p>File类 (java.io.File)</p>
</li>
<li>
<p>创建文件, 可以使用 <code>createNewFile()</code> 方法, 此方法会返回一个布尔值: true 代表此文件成功创建; false 代表此文件已存在. 要注意此方法要放入 try … catch 中, 防止 IOException 异常的出现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileHandler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newFile.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newFile.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>File类的内置方法: <code>getName()</code> <code>getAbsolutePath()</code>  <code>canWrite()</code>  <code>canRead()</code> <code>length()</code></p>
</li>
<li>
<p>删除 (空) 文件夹: <code>.delete()</code></p>
</li>
<li>
<p>Java函数 (方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	System.out.println(Fact(<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n = <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * Fact(n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>异常 (Exception)</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0</span> / <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> []array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    System.out.println(array[<span class="number">3</span>]);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;continue...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关键字 <code>throws</code> <code>throw</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            badCode(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">badCode</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException, IndexOutOfBoundsException &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(array[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throws关键字要写在会出现异常的方法后面 (称为&quot;异常说明&quot;), 并定义好会出现的异常类型, 如有多个异常, 则用逗号隔开. 这样我们就可以将处理异常这种麻烦事交给上层处理. (虽然异常说明跟在出异常的方法声明的后面, 但是它并不是方法签名或方法类型的一部分. )</p>
<p>我们可以使用throw关键字来抛出一个异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        checkAge(<span class="number">17</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Access denied: You must be at least 18 years old.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Access granted: You are old enough!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以抛出多个异常, 相应的, 也要处理多个异常.</p>
</li>
<li>
<p>检查型异常 (checked exception) : 在编译时被检查并强制实施的异常. 非检查型异常 (unchecked exception) : RuntimeException, 运行时异常.</p>
</li>
<li>
<p>子类重写父类方法要抛出与父类一致的异常, 或者不抛出异常 (在继承和重写中, 异常说明只缩不扩); 子类重写父类方法所抛出的异常不能超过父类本身的范畴. (如果子类多一个Runtime Exception, 那么编译器也不会报错. 因为运行时异常与编译无关, 如<code>NullPointerException</code> )</p>
<p>但是构造方法是个例外, 子类的构造器可以无视基类构造器随便抛出任何异常. 但是, 如果子类的构造器调用了基类的构造器或者被编译器自动加入了一个无参的基类构造器, 那么子类构造器必须抛出所有基类构造器抛出的异常. 而子类构造器不能捕获基类构造器所抛出的异常.</p>
</li>
<li>
<p>如果我们要创建一个自定义的异常, 只要继承<code>Exception</code>基类即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    MyException();</span><br><span class="line">    MyException(String msg) &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对知道怎么解决的异常, 要捕获; 对于自己不知道怎么解决的异常, 要抛出. 例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;divided by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Calculator</span>().div(Integer.parseInt(args[<span class="number">0</span>]), </span><br><span class="line">                                                    Integer.parseInt(args[<span class="number">1</span>])));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结合日志使用异常.</p>
</li>
<li>
<p>异常链: 重新抛出异常时, 希望保留原始异常的信息.</p>
<p>所有的<code>Throwable</code>子类都可以选择在构造器中接受一个cause对象, 作为原始的异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable(String message, Throwable cause)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>针对文件等资源的IO异常问题 (需要嵌套捕获, 不方便), Java 7引入了自动关闭资源 (回收), 在相关资源类 (如<code>FileInputStream</code>) 中实现了<code>AutoCloseable</code>接口, 里面具有<code>close</code>方法, <strong>会自动关闭打开的资源</strong>, 这样一定程度上避免了使用资源的IO时嵌套的复杂的异常捕获代码.  (注意以下代码中<strong>圆括号</strong>的使用) (圆括号里面的内容叫<strong>资源说明头</strong>, 事实上, 资源说明头可以包含多个定义语句)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryWithResources</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不是直接 &#123;&#125; 而是在 &#123;&#125; 之前用 () 包裹一个准备资源的语句 -- ()里的语句也可能发生异常, 但是这个异常是自动被处理的 (自动关闭), 这样在进入实际的 try 的内部即&#123;&#125;内, 那么这个资源被保证一定正常打开了, 如果()内部异常了, 打开的资源会被自动关上. </span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.java&quot;</span>)); <span class="comment">// 此处(位于圆括号包围内容的结尾)的分号是可选的</span></span><br><span class="line">            <span class="comment">// FileInputStream类实现了java.lang.AutoCloseable接口</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">contents</span> <span class="operator">=</span> in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// handle the error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于一段代码可能产生多个异常, 一种做法是逐个捕获, 即<code>try &#123;&#125; catch (Exception1) &#123;&#125; catch (Exception2) &#123;&#125; ...</code> 如果多个异常之间有继承关系, 那么子类捕获在前. ( 按从小到大顺序捕获异常, 先子类后父类. )</p>
<p>这样的做法可能不够灵活, 可以使用<strong>组合捕获</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception1 | Exception2 | Exception3 e) &#123;</span><br><span class="line">    process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是, 由于一次异常只可能是具体的一种, 所以在若干个catch块之中至多只会执行一个.</p>
</li>
<li>
<p>如果程序规模足够大, 那么使用检查型异常可能不是一个好主意 (详见 <em>On Java 基础卷</em> 第15章) , 有两种补偿的方法 – 1. 利用链式异常将检查型异常包在<code>RuntimeException</code>中 2. 创建自己的 <code>RuntimeException</code> 的子类.</p>
</li>
</ol>
<h2 id="Java-Lesson-4-String">Java-Lesson 4 (String)</h2>
<ol>
<li>
<p>String类: final的不可被继承, 本质是final的char数组</p>
</li>
<li>
<p>String中的内置函数</p>
<ul>
<li>length – 长度</li>
<li>toUpperCase – 转换为大写</li>
<li>indexOf(substr) – 找到特定字符<strong>串</strong>的位置</li>
</ul>
</li>
<li>
<p>**String类中的方法 **</p>
<p>==<strong>(注意, 由于String是不可变类, 以下方法均不能修改字符串本身, 而是返回一个改后的String类对象)</strong>==</p>
<p><code>.equals()</code> - 判断字符串==是否相等 (<strong>所以常用equals()方法</strong>)==, 而 <code>==</code> 是判断是否==<strong>同一</strong>==  (这是一个很坑的点, 应该说, 在Java判断相等的时候, 你==<em><strong>只应该想到equals这一种做法!!!</strong></em>==)</p>
<p><strong><code>trim()</code></strong> - 移出前导或尾随的空白符</p>
<p><code>toCharArray()</code> - <em><strong>转换成字符数组</strong></em></p>
<p><code>substring(start, stop)</code>  [起始下标, 终止下标) <em><strong>终止下标可省</strong></em>, 表示到末尾 (<em><strong>前闭后开</strong></em>)</p>
<p><code>charAt(index)</code> 字符串里面下标为index的字符</p>
<p><code>replace(s1, s2)</code> 把字符串中的s1变为s2</p>
<p><code>.split()</code> 返回一个<strong>String[]</strong> 类型, 为分割出的子串的数组.</p>
<p><code>.length()</code> 返回长度</p>
</li>
<li>
<p>String类对象有个特殊的创建方式, <code>String x = &quot;abc&quot;</code> x是&quot;abc&quot;对象的地址, 也叫作&quot;abc&quot;对象的引用.</p>
</li>
<li>
<p>String对象可以通过 “+” 串联, 也可通过 concat() 来串联. 但是字符串连接符 <code>+</code> 可以把数字 (int/double) 或 字符(char) 和字符串加在一起, 而<code>concat()</code>方法只能连接字符串.</p>
</li>
<li>
<p>也可以先转换成<code>StringBuilder</code>, 通过<code>append</code>来增加 (StringBuilder还自带了reverse方法), 然后通过<code>.toString()</code>方法回来.</p>
</li>
<li>
<p>从字节数组创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> System.in,read(buffer);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java常考题 – 以下代码输出什么:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2); </span><br><span class="line"><span class="comment">// true, 因为这里&quot;abc&quot;存在常量池中, 在代码区, 指向同一块内存</span></span><br><span class="line"><span class="comment">// 这是java的一个特性 (feature) 而判断相等(非同一)最好还是用.equals()方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// false, 因为此时&quot;abc&quot;在堆区, 他们已是不同的对象</span></span><br><span class="line"><span class="comment">// PS: str1, str2这样的局部变量在栈区</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-5-OOP">Java-Lesson 5 (OOP)</h2>
<ol>
<li>
<p>类声明</p>
<p>[modifiers] class <em>ClassName</em> [<strong>extends</strong> <em>SuperClassName</em>] [<strong>implements</strong> <em>InterfaceNames</em>] {…}</p>
</li>
<li>
<p>modifier (修饰符)</p>
<p><code>final</code>: 不可有任何子类</p>
<p><code>public</code>: 可被包外的类访问</p>
<p>缺省: 是一个缺省类 (the default 又叫包私有 package-private) 只可被当前包里的类访问.</p>
<p><code>abstract</code>: 虚类 (抽象类) 只可被继承, 不可被实例化对象</p>
</li>
<li>
<p>包 (package) 的概念</p>
<p>如果我想写一个类叫Student, 但是另一个人也要写一个Student类, 这就会产生名字冲突, 为了解决这个问题, 我们需要 package.</p>
<p>Java定义了一种命名空间, 叫做包 (package). 一个类总是归属于某一个包, 所以一个类的完整名字便是 package_name.class_name.</p>
<p>JDK中的 Arrays 类存放在 java.util 包中, 那么完整类名就是 java.util.Arrays.</p>
</li>
<li>
<p>位于同一个包的类, 可以访问包作用域的属性和方法. 如果我们想要在其他的包中调用方法, 我们需要使用import关键字.</p>
</li>
<li>
<p>创建包的时候, 需要为这个包取一个合适的名字. 之后, 如果其他的一个源文件包含了这个包提供的类/ 接口/ 枚举或者注释类型的时候, 都必须将这个包的声明放在这个源文件的开头.</p>
<p>包声明应该在源文件的<strong>第一行</strong>, 每个源文件只能有<strong>一个包声明</strong>, 这个文件中的每个类型都应用于它. (package pkg1.pkg2…)</p>
<p>如果一个源文件中没有使用包声明, 那么其中的类/ 函数/ 枚举/ 注释等将被放在一个无名的默认包 (unnamed package) 中.</p>
</li>
<li>
<p>Maven: 用于调用包</p>
</li>
<li>
<p>Python目录里必须包含一个<code>__init__.py</code>文件以便被Python视为包. (这个 <code>__init__.py</code> 使得Python有类似Java的包结构, 可以为空, 也可以包含一些初始化代码 (被首先执行) )</p>
</li>
<li>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>常用类</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang</td>
<td>语⾔包 (默认引⼊)</td>
<td>Object、String、Math、System、Exception、Class、Thread、Throwale</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://java.io">java.io</a></td>
<td>输⼊输出流的⽂件包</td>
<td>OutputStream、InputStream、PrintWriter、File、FileInputStream、FileOutputStream、BufferedReader、BufferedWriter</td>
</tr>
<tr>
<td>java.util</td>
<td>实⽤⼯具包</td>
<td>Date、Calendar、List、Map、Set、Stack、Random、Currency、Locale</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://java.net">java.net</a></td>
<td>⽹络包</td>
<td>URL、Socket、ServerSocket、HttpCookie</td>
</tr>
<tr>
<td>java.sql</td>
<td>数据库处理包</td>
<td>Connection、Statement、PreparedStatement、ResultSet</td>
</tr>
<tr>
<td>java.text</td>
<td>⽂本处理包</td>
<td>Format、DateFormat、NumberFormat</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>第三方java库: Junit(用于测试), Weka(机器学习), Hadoop(分布式)</p>
</li>
<li>
<p>成员变量</p>
</li>
</ol>
<p>[accessSpecifier] [final] type varaibleName [=initial_value];</p>
<p><strong>访问控制</strong></p>
<p>public–所有都能访问  (<strong>可修饰类 (仅有public和default可以修饰类)</strong>)</p>
<p>protected–当前类/当前类所在包/当前类的子类能访问, 其他不可</p>
<p>default (缺省)–当前类/当前类所在包能访问, (不在同一个包的) 子类不可</p>
<p>private–只有<strong>当前类</strong>能访问 (所以可以设定get和set方法来进行访问和修改).</p>
<p>​	(protected – 包可达性 + 子类可达; default – 包可达性)</p>
<ol start="11">
<li>
<p>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处变量i仅能被y包下的类访问.</span></span><br><span class="line"><span class="comment">// 因为虽然A是public, 但是i是default, 所以A的子类不能存取i</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一般来说, 对于&quot;敏感&quot;的数据应该设为私有变量, 从而对外界进行隔离. 通过公共方法 (get和set) 来进行访问和修改这些变量. (Java的封装性)</p>
</li>
<li>
<p>get… 方法 -&gt; 访问子/ 观察子; set… 变异子</p>
</li>
<li>
<p>方法一旦被final修饰, 则不可被重写 (覆盖).</p>
</li>
<li>
<p>javadoc: 文档, 提供了类或者方法的一些说明, 如参数/ 返回值, 这是java注释的⼀种. /** … */</p>
</li>
<li>
<p>java方法的参数如果是Primitive type, 则传递过来的必须是单一值, 称Pass by value;  如果是Reference type, 则传递过来的必须是内存地址, 称Pass by reference.</p>
</li>
<li>
<p>值传递 (Pass by value) 在java中, 方法的实参是通过值传递的, 当方法调用时, 实参的值的<strong>拷贝</strong>会赋给方法中的参数变量. 方法中本意读该拷贝值做改变, 但不会影响到原来的变量. (方法外和内严格分开, 且无指针, 所以Java写不出swap(a, b)函数.)</p>
</li>
<li>
<p>Java函数参数传递<strong>某个对象的引用</strong>, 如果这时函数<strong>通过该引用改变了这个对象</strong>, 那么<em><strong>外部的索引指向的对象==也被改动了==</strong></em>. (类似C的指针, 不是pure function, 不安全, 所以不推荐).</p>
</li>
<li>
<p><strong>Integer类型的整数对象, 因为是不可变类 (类属性不会被修改), 所以不会被函数传参后通过对形参的操作改变变量名指向的东西. String类也是不可变类, 所以==函数内部改动无法影响到外部的引用名所指对象==.</strong> 所谓的函数内部的改动只是把这个引用的副本指向了另外的东西, 而不是把引用的副本指向的东西修改了! (所以在外部, 那个引用该指向啥还指向啥)</p>
</li>
<li>
<p>Python中的方法中参数是什么传递? -&gt; 赋值传递, 与Java本质一样, 只是Python没有原始类型. (所以说Java的变量名也更像标签, 用Python理解Java, 这两种语言在 pass by assignment上J几乎一致)</p>
</li>
<li>
<p>对象数组: 先定义一个存放对象的数组, 再建立每个对象的存储空间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book[] books = <span class="keyword">new</span> <span class="title class_">Book</span>[<span class="number">2</span>]; <span class="comment">// 定义一个存放Book对象的数组</span></span><br><span class="line"><span class="comment">/* 建立每个对象的存储空间 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; books.length; i++)</span><br><span class="line">    books[i] = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>构造方法 (同名, ==无返回值==)</strong>: 对象的实例化通过构造方法来实现, new语句时自动调用, 而不能显式地调用.</p>
<p>(1) 构造方法名字必须与类名相同.</p>
<p>(2) 构造方法无返回值 (不是返回void型, 不能加void修饰, <strong>加了返回值修饰的就成了一般方法==不是构造方法==</strong>).</p>
<p>(3) 构造方法可以有多个, 构造方法可以==<strong>重载</strong>== (运行时会根据参数形式来具体选择构造方法).</p>
<p>(4) 当没有声明构造函数时, 默认含有一个无参数的构造函数, 当显式声明构造函数后, 默认的构造函数就不存在.</p>
</li>
<li>
<p>继承:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 由于super就是父类名, 而父类构造方法和类同名, 所以此处子类的构造方法中用super调用了父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WangWang..., I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>==<strong>静态类型和实际类型</strong>==:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(); <span class="comment">// Base: 静态类型, Child: 实际类型</span></span><br></pre></td></tr></table></figure>
<p>一个变量都有两个类型.</p>
<p><strong>静态类型: 引用变量的类型, 在编译期确定, 无法改变</strong></p>
<p><strong>实际类型: 实例对象的类型, 在编译期无法确定, 需在运行期确定, 可以改变</strong></p>
</li>
<li>
<p><strong>static</strong>关键字: 是Java中用来表达隶属于&quot;类&quot;本身, 而不隶属于类的对象的一个关键字. (可修饰变量(静态变量), 方法(静态方法), <strong>语句块(初始化类变量)</strong>)</p>
</li>
<li>
<p>类变量 (Class Variable) / 静态变量: 表示类的属性, 为所有该类的对象所共有, 为了与实例变量有所区别, 前面加<strong>static</strong>. 用来表达所有对象的共有属性, 在java类1加载之后就得到了相应的内存, 其只有一份, 不会随着对象的创建增多.</p>
<p><strong>在创建实例之前就已经有了</strong>, <strong>即在初始化类时就已有了</strong>. 存在Metaspace里 (Metaspace存储元信息) (占用内存的时间最久, 最不能有效利用内存空间)</p>
</li>
<li>
<p>类方法/ 静态方法: 一个静态方法隶属于类, <strong>专门用于处理类变量的计算</strong>, 通过类名称来调用, 而无需实例化一个对象来调用, 必须加上一个<strong>static</strong>修饰词.</p>
<p>静态方法可以访问更改静态变量, 但不能直接访问非静态的成员(变量和方法).</p>
<p>在静态方法中,<strong>this</strong>(表示当前对象的引用) ( 当需要明确指出当前对象的引用时, 才使用this关键字, 如果是在同一个类中, 那么会自动加, <strong>不要滥用this, 为了代码可读性! 原则上, 只有当类中变量和成员变量重名时才使用this指针</strong> ) 和<strong>super</strong>(表示当前对象的相应父类对象引用) <em><strong>无法使用</strong></em>. (因为this/ super所代表的对象还没产生, 既然没有对象, 就不会有实例变量.)</p>
<p>(变量引用) 类名或对象名与变量名之间为<code>.</code>  (方法引用) 类名或对象名与方法名之间为<code>::</code> (这个语法来自C++)</p>
</li>
<li>
<p>这里的 this 可以认为就是类名(即构造方法名), <a target="_blank" rel="noopener" href="http://xn--this-ue6fn7n8o2f.xxx">会看到this.xxx</a> 或 this() 调用构造方法等等, 其实this 替换类名 (类的构造方法名) 类似于<em>字面</em>上替换. (super同理)</p>
</li>
<li>
<p><strong>静态语句块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">static</span> &#123; <span class="comment">// 静态语句块</span></span><br><span class="line">		a = <span class="number">1</span>;</span><br><span class="line">		b = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A1</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态语句块用来初始化静态变量</li>
<li>静态语句块<strong>不能访问非静态成员</strong></li>
<li>静态语句块在main方法之前被调用</li>
</ul>
</li>
<li>
<p>静态语句块用于初始化静态变量, 那么什么语句块用于初始化成员变量? – 非静态语句块 (实例语句块), 会在执行某一个构造方法之前就执行, 是与静态块类似的语法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	&#123; <span class="comment">// 语句块</span></span><br><span class="line">		a = <span class="number">1</span>;</span><br><span class="line">		b = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">A2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一语法是<strong>匿名内部类</strong>初始化所必需的.</p>
</li>
<li>
<p>record类 (本条参考 - Java 17 updates) :</p>
<p>我们常常会写这样的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> length, <span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.length; &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">width</span><span class="params">()</span>  &#123; <span class="keyword">return</span> <span class="built_in">this</span>.width; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementation of equals() and hashCode(), which specify</span></span><br><span class="line">    <span class="comment">// that two record objects are equal if they</span></span><br><span class="line">    <span class="comment">// are of the same type and contain equal field values.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> equals...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> hashCode...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An implementation of toString() that returns a string</span></span><br><span class="line">    <span class="comment">// representation of all the record class&#x27;s fields,</span></span><br><span class="line">    <span class="comment">// including their names.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了record关键字，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就这一行代码</span></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Rectangle</span><span class="params">(<span class="type">double</span> length, <span class="type">double</span> width)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>record对于创建小型<strong>不可变</strong>对象很有帮助.</p>
<p>record classes 提供了 1. private final修饰的成员变量和相应的公共访问方法 (*get()*方法) 2. 全参的构造方法 3. equals/ hashCode/ toString方法.</p>
<p>record类是final的, 即不可被继承.</p>
</li>
<li>
<p>record类可以用作简单的 (不可变的) 数据容器. (serve as a simple “data carrier”)</p>
</li>
<li>
<p>我们知道class类可以在文件中声明，也可以在类中声明/ 方法中声明。那么record类也一样，它有这几种方式：</p>
<p>直接在文件中声明的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">range</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DidispaceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">range</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DidispaceTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">range</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可变参数 – 语法糖, 类型后加 <code>...</code> 来表示.  必须放在参数列表最后, 实际会被编译器当成数组. 不同的是, 类似<code>String... trailing</code> 的参数声明可以接受空参数, 这带来了一定的灵活性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Integer... args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : args) &#123; <span class="comment">// Java 11 支持 for (var i : args) &#123;&#125; 的写法. </span></span><br><span class="line">        System.out.println(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    f();</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用方法重载 (特设多态), 那么你应当在至多一个重载方法上使用可变参数列表.</p>
</li>
</ol>
<h2 id="Java-Lesson-5-1-inheritance">Java-Lesson 5.1 (inheritance)</h2>
<ol>
<li>
<p>继承</p>
<p>Java通过关键字extends来表达继承关系.</p>
<p><code>class SubClass extends SuperClassName &#123;&#125;</code></p>
<p>Java只支持单继承, 只有一个&quot;直接&quot;父类. 父类的父类也是该子类的父类, 但不是直接父类, Java中所有类都是java.lang.Object 的子类.</p>
</li>
<li>
<p>实际编写代码中, 继承最好不要超过3层.</p>
</li>
<li>
<p>重新定义父类中的变量, 父类中相应的变量被隐藏 (hidden). 可以通过super关键词来访问这些隐藏的变量, 当然static的变量可以通过类名来访问. (隐藏和覆盖, 意思都是是其虽然被改写了, 但是依然可以通过super来调出来, 其区别在于运行前确不确定)</p>
</li>
<li>
<p>无论是什么类型的<em><strong>变量</strong></em>被重新定义都叫隐藏, <em><strong>静态方法</strong></em>被重新定义也叫隐藏. (隐藏在编译时就分开了)</p>
</li>
<li>
<p>重新定义签名相同的<em>成员方法</em> (<em><strong>前提是这些方法可达</strong></em>), 就是方法重写 (Overriding).  (重写在编译时是分不开的)</p>
</li>
<li>
<p>定义一个与private的方法同名的方法也不叫隐藏 (因为本来就不可达) , 也不叫覆盖. 但是两者依然是分开的, 可以认为是天然的隐藏起来了.</p>
</li>
<li>
<p>只有既没有static也没有private修饰的成员方法被重新定义才是覆盖/ 重写 (Overriding)</p>
</li>
<li>
<p><strong>隐藏和重写的区别</strong></p>
<p>重写对应==<em><strong>运行时</strong></em>==, Java会在运行时判断哪个方法会被调用</p>
<p>(It is for non-static methods.)</p>
<p>隐藏对应编译时, Java在编译阶段就已经确定好了调用的对象 (即静态和实例变量/静态方法)</p>
</li>
<li>
<p>early binding/ late binding 早绑定 (编译时) / 迟绑定 (运行时)</p>
</li>
<li>
<p>在Java中, 任何类的构造方法, <strong>第一行语句必须是调用父类的构造方法</strong>.</p>
<p>如果没有明确地调用父类的构造方法, 编译器会帮我们自动加一句super();</p>
<p>// 如果有参数, 那么只能自己写super(3);</p>
</li>
<li>
<p><strong>构造方法无法继承, 它隶属于特定的类.</strong> 因此, 如果即使类没有写构造方法, 那么其也会有一个默认的构造方法, 而不是继承于父类的构造方法.</p>
</li>
<li>
<p>什么样的类成员会被子类继承?</p>
<ol>
<li>私有的 (private) 类成员不能被子类继承</li>
<li>构造方法不能被继承</li>
<li>公共的 (public) 和保护性的 (protected) 类成员能被子类继承, 且子类和父类可以属于不同的包</li>
<li>无修饰的父类成员, 仅在同一个包中才能被子类继承</li>
</ol>
</li>
<li>
<p><strong>重写</strong>可继承的函数时, 其<strong>访问权限不能</strong>比父类中被重写方法的访问权限<strong>更低</strong>, 父类protected, 子类可为public.</p>
</li>
<li>
<p><strong>重写</strong>可继承的函数时, 返回值如果是原始类型, 必须与原函数一致,如果是对象类型, 必须是原函数返回值或是其<strong>子类</strong></p>
</li>
<li>
<p>以上2条只是对重写, 若是隐藏则无以上限制.</p>
</li>
<li>
<p>函数重载即特设多态 (Ad hoc polymorphism), 重载是不同的函数,因为虽然函数名相同但是参数不同.</p>
</li>
<li>
<p>⽽重写(也叫覆盖)是重新定义⽗类中签名相同的函数. 重载是特设多态, 重写是⼦类型多态. 重载在函数调⽤时所调⽤的具体函数 (函数绑定) 在编译时确定(early binding), 重写的函数绑定在运⾏时(late binding).</p>
</li>
<li>
<p>重载是重复利用名称, 而重写是重复利用方法的架构.</p>
</li>
<li>
<p>子类每个对象也是父类的对象 (is-a), 可以直接用子类对象赋给一个父类常量. 这种转化叫作: 向上转型 (upcasting)</p>
</li>
<li>
<p>父类的对象不能直接赋给子类. 但是可以强制转换 ( downcasting ). 想要安全的进行向下转型  ( 避免<strong>运行时</strong>产生异常 “ClassCastException” )  时, 一般需要用运算符instanceof (判断实例是不是一个类/ 接口的子类) 来进行判断.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog)</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-6-Generics">Java-Lesson 6 (Generics)</h2>
<ol>
<li>
<p>作为一种静态类型语言, Java对参数需要固定类型, 虽然增加了安全性, 但却失去了灵活性. 通过引入“泛型” (generics) 的概念, Java可以将类型也作为一种参数, 从而实现参数多态 (参数不同, 逻辑一致).</p>
</li>
<li>
<p>泛型的语法:</p>
<p>泛型类: <code>[modifiers] class className &lt;T, E, ...&gt; &#123;...&#125;</code></p>
<p>泛型接口: <code>[modifiers] interface interfaceName &lt;T, E, ...&gt; &#123;&#125;</code></p>
<p><strong>泛型方法</strong>: <code>[modifiers] &lt;T, E, ... &gt; returnType *functionName* ( parameterList ) &#123;...&#125;</code></p>
</li>
<li>
<p>形式类型参数: 在定义类/ 接口或方法时使用的类型参数. 可以用任意字母来表示, 如T, E, K, V等, 常用T, 需要加尖括号. (这对尖括号&lt;&gt;叫菱形运算符 / 钻石运算符)</p>
</li>
<li>
<p>泛型类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;A&gt; &#123; <span class="comment">// 形式类型参数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(A a)</span> &#123;...&#125;</span><br><span class="line">    A <span class="title function_">pop</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 使用时需要加上实际的数据类型</span></span><br><span class="line">        <span class="comment">// 你也可以使用 class Stack&lt;T, E, F&gt; &#123;&#125; 以支持有3种变量类型元素的栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>泛型接口: 与泛型类类似.</p>
</li>
<li>
<p><code>public class Computer&lt;T extends Disk&gt; &#123;...&#125;</code> T是Disk的一个子类, 通过这样的方式对类型作限制. 此处的 Disk 被称为该形式类型的限定类型 (bounding type)</p>
</li>
<li>
<p>泛型方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(T x)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E, V&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(E[] list1, V[] list2)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (E e : list1) </span><br><span class="line">        <span class="keyword">for</span> (V v : list2) &#123;</span><br><span class="line">	        System.out.println(e);</span><br><span class="line">	        System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在返回类型之前加一个<code>&lt;E, V&gt;</code> (<strong>形式类型参数表</strong>, 后续可以使用于参数/ 函数体)</p>
</li>
<li>
<p>形式类型参数和普通类型用法一样.</p>
</li>
<li>
<p>实际类型参数, 必须为对象类型. 在构造对象类型时, 可显示声明, 也可缺省.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericsSample&lt;Integer, Long, List&gt; t2 = <span class="keyword">new</span> <span class="title class_">GenericsSample</span>&lt;Integer, Long, List&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericsSample&lt;Integer, Long, List&gt; t2 = <span class="keyword">new</span> <span class="title class_">GenericsSample</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这件事情 (泛型机制使得获取一个泛型返回类型时不用再人为向下转型) 听起来很完美, 但是事实上这只是因为编译器帮你做了转型, 是编译时刻的语法糖, 真正在运行时类型信息被擦掉了. 证据: 观察字节码可知, 泛型的实际类型根本就没有在字节码中出现, 而是以java.lang.Object (或是一个父类) 代替了.</p>
</li>
<li>
<p>泛型背后的机制: 其实Java的泛型都是伪泛型, 其为了能够后向兼容Java旧时代 (Java 4.0及以前, 当时还没有泛型) 代码, 并不是运行时进行泛型的支持, 而是通过编译器在编译阶段对类型进行擦除. (都被擦除成Object)  如果类型是受限的, 则会替换为其限定类型.</p>
</li>
<li>
<p>如果是这样的泛型, 观察字节码则会看到, 类型参数被擦除到了边界类型 (父类Disk). 事实上, Java泛型的实现方式即是<strong>边界类型替换</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Disk</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所以, 如果泛型的类型不匹配, 如<code>Holder&lt;Integer&gt; holder = new Holder&lt;&gt;(); holder.set(&quot;string&quot;); </code>, 在编译期就会fail, 无法通过编译.</p>
</li>
<li>
<p>通过泛型背后机制 (伪泛型) 理解问题:</p>
<ul>
<li>
<p>为什么泛型的实际参数类型不能是原始类型 (因为都会被擦除为Object或其限定类) 所以<code>List&lt;Integer&gt;</code> 是可以的而不能是int.</p>
</li>
<li>
<p>为什么 instanceof 判断不了泛型, 比如: <code>arg instanceof T</code> 或 <code>T&lt;String&gt; a = …; a instanceof T&lt;Integer&gt;;</code>   //  Error</p>
</li>
<li>
<p>为什么不能用泛型创建对象, 即 T a = new T(); (因为本质上就是new Object()) // Error</p>
</li>
<li>
<p>为什么不能用泛型创建数组对象, 即 T[] a = new T[size]；// Error</p>
</li>
<li>
<p>为什么不能声明静态的泛类型的变量，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T singleInstance; <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>擦除后就是Object类型. 导致用 <code>Singleton&lt;Integer&gt;</code> 和 <code>Singleton&lt;String&gt;</code> 所生成的静态变量都是Object类型, 都是存在相同的data space里面的Object, 从而没有意义 (产生了冲突) !</p>
<p>而声明泛型的非静态的成员变量显然是可以的.</p>
</li>
</ul>
</li>
<li>
<p>既然这些行为都不能做, 那么泛型到底还有啥用?</p>
<p>泛型的语法会让编译器帮我们做各种检查: 编译器会做<strong>类型检查</strong>, 防止实参与要求的泛型实际类型不匹配. (注意, 由于<strong>自动包装机制</strong>, int类型会被自动转换为Integer).</p>
<p>编译器还会做其他事情: 将所有的T都<strong>替换成边界类型</strong> (常为Object); 涉及泛型作为返回值, 编译器会<strong>自动插入一个向下转型</strong>的操作.</p>
</li>
<li>
<p>字节码层面是看不见&quot;泛型&quot;的 (没有&quot;泛型&quot;的概念) , 泛型只是编译器层面提供的一套语法功能, 所以使用了泛型的代码完全可以在旧版本JVM上跑.</p>
</li>
<li>
<p>如果真的想生成泛型对象, 怎么办?</p>
<ul>
<li>使用工厂创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(IFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = factory.create(); <span class="comment">// 实现新建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">newTwithFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Holder&lt;Integer&gt; holder = <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;&gt;();</span><br><span class="line">        holder.init(<span class="keyword">new</span> <span class="title class_">Integerfactory</span>()); <span class="comment">// 给holder一个具体的工厂</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用RTTI (运行时类型识别)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Class&lt;T&gt; kind)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.t = kind.newInstance(); <span class="comment">// 这样的生成实例的写法要求kind必须有一个无参构造器 </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Holder&lt;Integer&gt; holder = <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;&gt;(Integer.class);</span><br><span class="line">        holder.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>**<em>多个边界</em> (Bounds) – 这里传递出的信息是, 在表示边界时的 <em>extends</em> 关键字与表示类继承时的含义不一样, 表达边界时允许使用 <code>&amp;</code> 来表达还实现了若干个接口. **</p>
<p>Java只允许继承一个父类, 但是可以实现多个接口, 这使得泛型语法可以有多个边界.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HasColor</span> &#123; java.awt.Color <span class="title function_">getColor</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dimension</span> &#123; <span class="keyword">public</span> <span class="type">int</span> x, y, z; &#125;</span><br><span class="line"><span class="comment">// ColoredDimension 里面的泛型类型T既继承了Dimension又实现了HasColor接口. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColoredDimension</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Dimension</span> &amp; HasColor&gt; &#123;...&#125; <span class="comment">//  &amp; 用来分隔多个边界.</span></span><br></pre></td></tr></table></figure>
<p>注意: 如果既有父类又有父接口, 那么仅有的那一个父类一定放在多个边界的第一个, 后面跟着的是若干个父接口. (为什么? 因为父类很特殊, 至多有一个, 其放在最前面对编译检查是有利的. )</p>
</li>
<li>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> T item;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Plate</span><span class="params">(T t)</span> &#123;item = t;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;item = t;&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试创建一个装苹果的盘子</span></span><br><span class="line">Plate&lt;Fruit&gt; p = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Apple</span>()); <span class="comment">// Compile Error! </span></span><br></pre></td></tr></table></figure>
<p>装苹果的盘子无法转换成装水果的盘子 (不是父类子类关系!) , 即使苹果是一种水果.</p>
<p>回到父类和子类的最初的定义: 子类是	父类的特例, 父类具有的特性子类必须都要有.</p>
<p>所以, 装苹果的盘子不是装水果的盘子的子类, 它不具备装水果的盘子的性质 – 可以装任何水果 (香蕉, 蛇果, 车厘子, …) , 他们没有一个是另一个的特殊化的关系.</p>
</li>
<li>
<p>协变 (构造的复杂类型后保持原来的父子关系), 逆变 (仍然有父子关系, 但是与原来相反) , 不变 (没有父子关系) . (根据上一条所述, <em>水果 -&gt; 装水果的盘子</em> 是一种<strong>不变</strong>构造)</p>
</li>
<li>
<p>如何解决以上例子中的问题?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的是一个能放任意**一种**水果以及任意**一种**水果派生类的盘子</span></span><br><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; flist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>泛型通配符 <strong><code>?</code></strong> 到底表达什么意思?</p>
<p>答: 表示一定是<strong>一个</strong>确定的具体的类型, 但是具体这个类型是什么, 不确定.</p>
<p>比如一个装苹果的盘子, 是装一种确定的水果的盘子的子类, 所以上一条中的写法是可通过编译的.</p>
<p>通配符带来的意思是a plate will hold “some specific (特定的) type of fruit which is not specify (不确定)”.</p>
</li>
<li>
<p>所以, 一个装任意一种特定类型水果的盘子不能再被存入任何元素, 无论是new Fruit() 还是 new Apple(), 因为编译器的能力无法确定这个 <strong><code>?</code></strong> 表示的确切类型是哪一种, 为了安全性, 编译器不会再允许放入任何元素.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line"><span class="comment">// 不能再存入任何元素</span></span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Fruit</span>()); <span class="comment">// Error!</span></span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Apple</span>()); <span class="comment">// Error!</span></span><br><span class="line"><span class="comment">// 读取出来的东西只能放在Fruit或它的基类里</span></span><br><span class="line"><span class="type">Fruit</span> <span class="variable">newFruit1</span> <span class="operator">=</span> p.get();</span><br><span class="line"><span class="type">Object</span> <span class="variable">newFruit1</span> <span class="operator">=</span> p.get();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>超类通配符 (supertype wildcard)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="built_in">super</span> Fruit&gt; p = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Fruit</span>()); <span class="comment">// 只能初始化为Fruit及其超类</span></span><br><span class="line"><span class="comment">// 可以存入任何Fruit类及其子类</span></span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Fruit</span>());</span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line"><span class="comment">// 读取出来的东西只能放在Object类里 (编译器不知道你这个超类有多超, 只能保守估计)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">newFruit1</span> <span class="operator">=</span> p.get();</span><br><span class="line"><span class="type">Fruit</span> <span class="variable">newFruit1</span> <span class="operator">=</span> p.get(); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>泛型的类型通配符 (Wildcard)</strong></p>
<ul>
<li>
<p>之前一个泛型对象名只能引用同一种泛型对象, 如GeneralType&lt;String&gt; a 只能指向GeneralType&lt;String&gt;的对象 (有时候不希望list&lt;A&gt;和list&lt;B&gt;无任何关系)</p>
</li>
<li>
<p>如果要使用同一个泛型对象名去引用不同的泛型对象, 就需要使用通配符 “?” 创建泛型类对象</p>
</li>
<li>
<p>但要求不同泛型对象的类型实参<strong>必须是某个类或者其子类, 或实现某个接口泛型类名</strong> &lt;? extends T&gt; 0 = null;</p>
</li>
<li>
<p>除了可以利用extends限定实际类型参数是某个类型的子类外 (设置上限), 还可以用super 限定其是某个类的父类 (设置下限)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛型类型 &lt;? <span class="built_in">super</span> anyclass&gt; x = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>例子: (extends 和 super 刚好是相反的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralType</span> &lt;T&gt; &#123;</span><br><span class="line">  T obj;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span> <span class="params">(T obj)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GeneralType &lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; x = <span class="literal">null</span>; <span class="comment">// 类型通配符创建类, 并实例化为x</span></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">GeneralType</span> &lt;Long&gt; ();</span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">GeneralType</span> &lt;Integer&gt; ();</span><br><span class="line"><span class="type">Number</span> <span class="variable">a</span> <span class="operator">=</span> x.getObj(); <span class="comment">// Correct</span></span><br><span class="line">x.setObj(Integer.valueOf(<span class="number">1</span>)); <span class="comment">// Error, 因为x类型并不可判定(编译器为了Safe而不让x写入)</span></span><br><span class="line"></span><br><span class="line">GeneralType &lt;? <span class="built_in">super</span> Integer&gt; x = <span class="literal">null</span>;</span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">GeneralType</span> &lt;Object&gt; ();</span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">GeneralType</span> &lt;Number&gt; ();</span><br><span class="line"><span class="type">Number</span> <span class="variable">a</span> <span class="operator">=</span> x.getObj(); <span class="comment">// Error, x到底是什么类编译器不可判定, 为了safe-不能把超类赋值给子类</span></span><br><span class="line">x.setObj(Integer.valueOf(<span class="number">1</span>)); <span class="comment">// Correct</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java==<strong>泛型</strong>==举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; age = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Number&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( List&lt;?&gt; data )</span> &#123; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;data.length(); i++) &#123; </span><br><span class="line">    System.out.println(data.get(i)); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArray(name)</span><br><span class="line">printArray(age)</span><br><span class="line">printArray(number)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Self-bounded types 自限定类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfBounded</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SelfBounded</span>&lt;T&gt;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>目的是实现协变或者逆变 (参数协变(重载或者自限定), 返回值协变(Java 5自动支持) ), 非常漂亮的设计.</p>
<p>自限定的限制只服务于强制继承关系, 表示该类使用的类型参数和使用该参数的类是同一种基类.</p>
<p>也可以将自限定用于泛型方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">SelfBounded</span>&lt;T&gt;&gt; T <span class="title function_">f</span><span class="params">(T arg)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>自限定类型</strong>自然地支持<strong>参数协变类型 (covariant argument type)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SelfBoundSetter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SelfBoundSetter</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T arg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的set方法接收确切类型参数Setter</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Setter</span> <span class="keyword">extends</span> <span class="title class_">SelfBoundSetter</span>&lt;Setter&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfBoundingAndCovariantArguments</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Setter s1, Setter s2)</span> &#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java Optional 类, 更优雅处理null.</p>
<p><strong>创建 Optional 对象</strong></p>
<p>1）可以使用静态方法 <code>empty()</code> 创建一个空的 Optional 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty); <span class="comment">// 输出：Optional.empty</span></span><br></pre></td></tr></table></figure>
<p>2）可以使用静态方法 <code>of()</code> 创建一个非空的 Optional 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(opt); <span class="comment">// 输出：Optional[name]</span></span><br></pre></td></tr></table></figure>
<p>当然了，传递给 <code>of()</code> 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; optnull = Optional.of(name);</span><br></pre></td></tr></table></figure>
<p>3）可以使用静态方法 <code>ofNullable()</code> 创建一个即可空又可非空的 Optional 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">System.out.println(optOrNull); <span class="comment">// 输出：Optional.empty</span></span><br></pre></td></tr></table></figure>
<p><code>ofNullable()</code> 方法内部有一个三元表达式，如果为参数为 null，则返回私有常量 EMPTY；否则使用 new 关键字创建了一个新的 Optional 对象——不会再抛出 <code>NPE</code> 异常了。</p>
<p><strong>判断值是否存在</strong></p>
<p>可以通过方法 <code>isPresent()</code> 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 <code>obj != null</code> 的判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(opt.isPresent()); <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">System.out.println(opt.isPresent()); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>
<p>Java 11 后还可以通过方法 <code>isEmpty()</code> 判断与 <code>isPresent()</code> 相反的结果。</p>
<p><strong>非空表达式</strong></p>
<p>Optional 类有一个非常现代化的方法——<code>ifPresent()</code>，允许我们使用函数式编程的方式执行一些代码，因此，我把它称为非空表达式。如果没有该方法的话，我们通常需要先通过 <code>isPresent()</code> 方法对 Optional 对象进行判空后再执行相应的代码：</p>
<p>有了 <code>ifPresent()</code> 之后，可以直接将 Lambda 表达式传递给该方法，代码更加简洁，更加直观。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">opt.ifPresent(str -&gt; System.out.println(str.length()));</span><br></pre></td></tr></table></figure>
<p>Java 9 后还可以通过方法 <code>ifPresentOrElse(action, emptyAction)</code> 执行两种结果，非空时执行 action，空时执行 emptyAction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">opt.ifPresentOrElse(str -&gt; System.out.println(str.length()), () -&gt; System.out.println(<span class="string">&quot;为空&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>设置（获取）默认值</strong></p>
<p>有时候，我们在创建（获取） Optional 对象的时候，需要一个默认值，<code>orElse()</code> 和 <code>orElseGet()</code> 方法就派上用场了。</p>
<p><code>orElse()</code> 方法用于返回包裹在 Optional 对象中的值，如果该值不为 null，则返回；否则返回默认值。该方法的参数类型和值得类型一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nullName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Optional.ofNullable(nullName).orElse(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name); <span class="comment">// 输出：name</span></span><br></pre></td></tr></table></figure>
<p><code>orElseGet()</code> 方法与 <code>orElse()</code> 方法类似，但参数类型不同。如果 Optional 对象中的值为 null，则执行参数中的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nullName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Optional.ofNullable(nullName).orElseGet(()-&gt;<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name); <span class="comment">// 输出：name</span></span><br></pre></td></tr></table></figure>
<p><strong>获取值</strong></p>
<p>直观从语义上来看，<code>get()</code> 方法才是最正宗的获取 Optional 对象值的方法，但很遗憾，该方法是有缺陷的，因为假如 Optional 对象的值为 null，该方法会抛出 NoSuchElementException 异常。这完全与我们使用 Optional 类的初衷相悖。</p>
<p>建议 <code>orElseGet()</code> 方法获取 Optional 对象的值。</p>
<p><strong>过滤值</strong></p>
<p>新的任务：用户注册时对密码的长度进行检查。</p>
<p>Optional 类的 <code>filter()</code> 方法，就派上了用场。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterOptionalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(password);</span><br><span class="line">        System.out.println(opt.filter(pwd -&gt; pwd.length() &gt; <span class="number">6</span>).isPresent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>filter()</code> 方法的参数类型为 Predicate（Java 8 新增的一个函数式接口），也就是说可以将一个 Lambda 表达式传递给该方法作为条件，如果表达式的结果为 false，则返回一个 EMPTY 的 Optional 对象，否则返回过滤后的 Optional 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 过滤长度6~10的密码 */</span></span><br><span class="line">Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; <span class="number">6</span>;</span><br><span class="line">Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line">opt = Optional.ofNullable(password);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> opt.filter(len6.and(len10)).isPresent();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p><strong>转换值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        Optional&lt;String&gt; nameOptional = Optional.of(name);</span><br><span class="line">        Optional&lt;Integer&gt; intOpt = nameOptional</span><br><span class="line">                .map(String::length);</span><br><span class="line"></span><br><span class="line">        System.out.println( intOpt.orElse(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>map()</code> 方法的参数 <code>String::length</code>，意味着要 将原有的字符串类型的 Optional 按照字符串长度重新生成一个新的 Optional 对象，类型为 Integer。</p>
<p>把 <code>map()</code> 方法与 <code>filter()</code> 方法结合起来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; <span class="number">6</span>;</span><br><span class="line">Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; <span class="number">10</span>;</span><br><span class="line">Predicate&lt;String&gt; eq = pwd -&gt; pwd.equals(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> opt.map(String::toLowerCase).filter(len6.and(len10).and(eq)).isPresent();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-7-FP-Interface">Java-Lesson 7 (FP &amp; Interface)</h2>
<ol>
<li>
<p>为什么要函数式编程? 因为如果没有函数式, 单纯面向对象, 一切都是名词, 基于名词去做某件事常常是不必要的, 这就导致Java代码中出现很多的不必要的繁杂繁冗. (函数式编程是一种声明式的编程风格, 函数是没有副作用的, 外部的状态不因函数的执行而改变, 这带来的好处就是使得并发度尽可能的高).</p>
</li>
<li>
<p>lambda表达式也是语法糖, 在JVM上, 一切都是类和对象.</p>
</li>
<li>
<p>Java Lambda表达式和使用函数作为参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] calculate(BiFunction&lt;<span class="type">int</span>[][], <span class="type">int</span>[][], <span class="type">int</span>[][]&gt; func) &#123;</span><br><span class="line">    func.apply(A, B); <span class="comment">// 这里BiFunction为一个双参数的函数(单参数去掉Bi), 它被作为参数传入, 以待调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] plusFromConsole() &#123;</span><br><span class="line">	<span class="keyword">return</span> calculate(<span class="built_in">this</span>::plus); <span class="comment">// 所在类里面的一个方法plus, 作为参数传入</span></span><br><span class="line"><span class="comment">//  return calculate((a, b)-&gt;plus(a, b)); // lambda写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>lambda表达式:</p>
<p><code>(para1, para2, ...) -&gt; &#123; code block &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    System out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>语法糖:</p>
<p>参数类型可以明确声明, 也可省略, 编译器根据上下文推断.</p>
<p>只有一个参数时, 圆括号可省略;</p>
<p>只有一条语句, {}可省略. 如:  <code>a -&gt; a + 1</code></p>
</li>
<li>
<p><strong>函数式接口</strong></p>
<ul>
<li>函数式接口是只包含一个抽象方法声明的接口</li>
<li>每个<strong>lambda表达式 (或一个形如<code>A::foo</code> &amp; <code>a::foo</code> 的方法引用, 本质上方法引用也是lambda表达式的简化) 都能隐式地赋给函数式接口</strong>.</li>
</ul>
<p><code>java.lang.Runnable</code>就是一种函数式接口, 在Runnable接口中只声明一个抽象方法<code>void run()</code></p>
</li>
<li>
<p><strong>其他常见的函数式接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer&lt;E&gt; 函数式接口, 消耗一个E类型, 返回void.</span></span><br><span class="line">Consumer&lt;Integer&gt; c = (<span class="type">int</span> x) -&gt; &#123;System.out.println(x) &#125;;</span><br><span class="line"><span class="comment">// BiConsumer&lt;K, V&gt; 和Consumer类似</span></span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">&quot; : &quot;</span> + y);</span><br><span class="line"><span class="comment">// Predicate&lt;E&gt; 预测. 参数是E, 返回布尔值</span></span><br><span class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="literal">null</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义自己的函数式接口 <code>@FunctionalInterface</code> 是Java 8新加入的一种接口, 用于指明该接口类型声明是根据Java语言规范定义的函数式接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WorkerInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeWork</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>java.util.function包里的函数式接口:</p>
<p><code>Interface Function&lt;T, R&gt;</code></p>
</li>
<li>
<p>实际使用举例:</p>
<p>使用现成的函数式接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; myFunc = a -&gt; a + <span class="number">1</span>;</span><br><span class="line">myFunc.apply(<span class="number">1</span>);</span><br><span class="line">System.out.println(myFunc.apply(<span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>自己定义需要的函数式接口并使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">boolean</span> bl)</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	<span class="type">Func</span> <span class="variable">fc</span> <span class="operator">=</span> (a, b, c, bl) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (bl) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b * c + <span class="number">114514</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;;</span><br><span class="line">    System.out.println( fc.apply(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>) );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果要用函数式编程的方式实现递归, 则为了避免使用未初始化变量, 需要运用<strong>字段</strong>来作为递归的函数式接口的声明. (对于纯函数的支持在这一点上不如Python, 然而Python的函数式也不够纯 (&gt;_&lt;) )</p>
</li>
<li>
<p>构造方法 (new) 的方法引用, 例如 <code>MakeNoArgs mna = Dog::new; </code> 然后就可以通过<code>mna,apply()</code>创建新<code>Dog</code>对象.</p>
</li>
<li>
<p>Java 8提供了有限但是还算可以的闭包支持, 也就是实际上lambda表达式也可以改变一些可达的变量. 到底哪些是可改变的? 1. 外围类的字段. 2. final的局部变量或者是实际上final的局部变量 (如<code>List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); l.add(5); </code> , l这个局部变量的指向实际上没有变, 尽管指向的对象自己发生了一些改变.)</p>
</li>
<li>
<p><strong>方法重载 Method Overloading</strong>:</p>
<p>方法重载可以让我们使用相同的方法名, 来处理不同的参数, 比如下面这些方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> num1, <span class="type">float</span> num2)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>每个类中可以有一个特殊的构建函数, 它用于初始化实例. 构建函数是一个实例被创建时最先被调用的函数, 每次创建实例的时候, 它的构建函数都会被调用.</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Samuel&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(student.name); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中, Student就是构建函数, 构建函数不能有返回值, 而且函数名必须和类名一致.</p>
<ol start="11">
<li>
<p>可以在类中创建了两个同名函数, 但是两者参数不同, 这就是重载 (Overload).</p>
</li>
<li>
<p>修饰访问权限的关键词是 public/ private/ protected. 被定义为public的class, attributes, method可以被任何类访问, 如果是private那么就无法被其他类访问, protected适用于继承关系间的类, 被定义为protected的属性和方法可以被子类访问.</p>
</li>
<li>
<p>Java继承 子类名 <code>extends</code> 父类名</p>
</li>
<li>
<p>数据抽象可以通过 abstract class 或 interface (接口) 实现. abstract 关键字是一个用于类和方法的修饰符, 我们无法创建 abstract class 类型的实例 ( 不能用new运算符 ), 这种抽象类<strong>只能被继承</strong>. 而 abstract method 只能定义在 abstract class 中, 这种方法没有具体执行内容. 一个抽象类既可以有抽象方法也可以有正常的方法:</p>
</li>
<li>
<p>如果一个类中没有包含足够的信息来描绘一个具体的对象 (方法没实现), 这样的类就是抽象类. 在抽象类⾥, 不定义⽅法体, 只需声明不实现的方法 – 抽象方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 抽象类只能被继承 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zzz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teenager</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am a teenager.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抽象类的子类可以是抽象类, 如果子类不是抽象类, 那么其必须实现父类中的所有抽象方法.</p>
</li>
<li>
<p>抽象类不能用final修饰. (抽象类就是为了继承, 而final不允许继承)</p>
</li>
<li>
<p>抽象类中不一定包含抽象方法, 但包含抽象方法的类一定为抽象类.</p>
</li>
<li>
<p><em><strong>接口 Interface</strong></em></p>
<p>另一个实现数据抽象的方式就是使用接口 (interface). 一个接口就是<em>完全的抽象类</em>, 其中<s>只</s>含有抽象方法 (不含一般的方法) , 这些方法中是没有任何逻辑代码的. 类的主要作用便是定义一些特定的方法, 具体逻辑让正常的类实现.</p>
<p>可以认为, 接口就是一个<em>抽象程度很高的基类</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口没有构造方法.</p>
</li>
<li>
<p><strong>接口的变量都是 static final 修饰的</strong>, 缺省的也是静态常量, 所以<strong>必须赋初始值</strong>. (静态常量就是只有一份, 常量是没有一个实例就有一份, 一般常量一份就够了, 所以常常用static final)</p>
</li>
<li>
<p>接口的成员<strong>可访问性都是==public (所以子类相应的成员必须也是public)==</strong> (缺省也是public)</p>
</li>
<li>
<p>接口中除了抽象方法之外, 还可以含有<strong>静态方法</strong>和<strong>default</strong> (默认方法) . default方法中的实现会被所有implement了该接口的子类所具有.</p>
</li>
<li>
<p>如果要使用接口的方法, 那么具体的类必须实现 ( <strong>implements</strong> ) 其接口. 只要被实现, 具体的类必须将接口方法的具体逻辑全部实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToSchool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m going to school.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeExam</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m taking an exam.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意, 在接口中, 缺省的成员方法也是public, 但是在实现中, 每个方法的<strong>public</strong>修饰不能省, 否则会编译失败.</p>
</li>
<li>
<p>一个类可以实现 (implement) 多个接口 (interface) , 如: <code>public class Person implements Student, Employee &#123;...&#125;</code></p>
</li>
<li>
<p>==接口可以作为一种<em><strong>引用类型</strong></em> (静态类型) 使用==, (<strong>但是万万不可作为实际类型</strong>) 可以声明接口类型的变量或数组, 并用它来访问实现该接口的类的对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showPI</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(PI);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是⼀个图形&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CireCleForI</span> <span class="keyword">implements</span> <span class="title class_">IShape</span>&#123;</span><br><span class="line">  <span class="type">double</span> radius;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CireCleForI</span><span class="params">(<span class="type">double</span> r)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.radius = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PI*radius*radius;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*PI*radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIShape</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IShape</span> <span class="variable">cir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CireCleForI</span>(<span class="number">2.2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;⾯积 ： &quot;</span>+ cir.getArea());</span><br><span class="line">    System.out.println(<span class="string">&quot;周⻓ ： &quot;</span>+ cir.getLength());</span><br><span class="line">    cir.getInfo();</span><br><span class="line">    IShape.showPI();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口继承:</p>
<ul>
<li>接口可通过extends关键字声明该新接口是某个已存在的父接口的子接口, 它将继承父接口的所有变量与方法 (静态方法除外, 静态方法只能通过接口名来访问)</li>
<li>接口支持多继承 (一个接口可以继承多个接口, <strong>接口不可以继承类</strong>, 多个父接口用逗号隔开)</li>
<li>如果接口中定义了与父接口同名的常量或相同的方法, 则<em><strong>父接口中的常量和静态方法被隐藏, 默认方法和抽象方法被重写</strong></em>.</li>
</ul>
</li>
<li>
<p>可以利用接口继承轻松地为接口创建一个别名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">G</span> <span class="keyword">extends</span> <span class="title class_">F</span> &#123;&#125; <span class="comment">// 接口G是接口F的别名. </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用default方法实现混入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">// 如果不用default的话则不能给出内部实现</span></span><br><span class="line">    System.out.println(<span class="string">&quot;I can fly!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I can swim!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimmable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 接口里面所有方法默认是public访问修饰的, 这里default关键字不是访问修饰符, 而是default关键字.</p>
</li>
<li>
<p>接口多继承中的名字冲突问题</p>
<ul>
<li>接口的多重继承中可能存在常量名或方法名重复的问题, 即名字冲突问题</li>
<li>对于常量, 若名称不冲突, 子接口可以继承多个父接口中的常量, 但如果多个父接口中有同名的常量, 则必须通过 <em>接口名.常量名</em> 区分.</li>
<li>对于多个父接口中存在同名的方法包含默认方法 (default) 时, 也会发生命名冲突, 这时不能通过 <em>接口名.默认方法名</em> 来解决. (显然是不能的, 因为default是实例方法, 都没有实例, 哪里有这个方法呢?) 必须要在当前类中自己新定义一个同名的方法来覆盖才行.</li>
<li>而此时如果想要调用被覆盖的方法, 要用<em>父接口名.super.方法名</em> (一般是super.方法名, 这里加一个父接口名是为说清楚到底是哪个父接口)</li>
</ul>
</li>
<li>
<p>如果发生了继承类和实现接口的命名冲突, 那么“类”优先, 继承的父方法中的同名方法. (先认为子类的方法是所继承的父类的方法)</p>
</li>
<li>
<p>继承代表的类之间的关系是 <code>is-a</code> 关系, 而接口的类之间关系则是<code>has-a</code> 关系 (组合)</p>
</li>
</ol>
<h2 id="Java-Lesson-8-Stream">Java-Lesson 8 (Stream)</h2>
<ol>
<li>
<p>查看变量所在类和类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a.getClass());</span><br><span class="line">System.out.println(a.getClass().getSimpleName());</span><br><span class="line">System.out.println(a.getClass().getTypeName());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; i_ci = cities.iterator(); </span><br><span class="line"><span class="keyword">while</span>( i_ci.hasNext() ) &#123;</span><br><span class="line">	System.out.println(i_ci.next());</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Integer&gt; i_nu = numbers.iterator(); </span><br><span class="line"><span class="keyword">while</span>( i_nu.hasNext() ) &#123;</span><br><span class="line">	System.out.println(i_nu.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器的坑: 不要在列表迭代中对原来的迭代器作改变 (删除).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>));</span><br><span class="line"><span class="keyword">for</span> (Integer num : numbers) &#123;</span><br><span class="line"> numbers.remove(num); <span class="comment">// dangerous!!! mutates the list we&#x27;re iterating over</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(numbers); <span class="comment">/* list empty here? */</span></span><br></pre></td></tr></table></figure>
<p>正确的做法是, 新建一个数组, 过滤掉原来的. (本质是新建而不是删除)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (Integer num : numbers) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="number">100</span>)</span><br><span class="line">    newList.add(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个正确但是<strong>不推荐</strong>的做法: (利用迭代器) (不推荐是因为 – 多个迭代器指向同一个对象时出问题; 多线程会出问题)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>));</span><br><span class="line">Iterator&lt;Integer&gt; iter = numbers.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">num</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">100</span>) </span><br><span class="line">        iter.remove(); <span class="comment">// 此处迭代器会无误地指向删除元素的下一个, 从而正确完成过滤的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数组合 <code>andThen</code> <code>compose</code> <code>and</code> <code>or</code> <code>negate</code></p>
</li>
<li>
<p>流的常用操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* map */</span> </span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i * i).collect(Collectors.toList());</span><br><span class="line">squaresList = numbers.stream().map( i -&gt; i * i).distinct().collect(Collectors.toList()); <span class="comment">// distinct去重复值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* filter */</span></span><br><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>); </span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sorted */</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line">List&lt;Integer&gt; sortedList = numbers.stream().sorted().collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; sortedList = numbers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line">numbers.stream().sorted((a, b) -&gt; &#123;<span class="keyword">return</span> a.compareTo(b);&#125;).forEach( n -&gt; System.out.println(n) );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reduce */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">reduced</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">4</span>).reduce((a, b) -&gt; a + b).getAsInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Iterate */</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Match */</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> list.stream().allMatch(e -&gt; e &gt; <span class="number">3</span>); <span class="comment">//false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(e -&gt; e &gt; <span class="number">3</span>); <span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> list.stream().noneMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Min, Max */</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> list.stream().max((a, b) -&gt; a.compareTo(b)).get(); <span class="comment">// 5</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> list.stream().min(Integer::compareTo).get(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建一个String对象的&quot;流&quot;, 将其中每一个对象交给filter过滤, 最后forEach()会对每个保留下来的对象应用println方法引用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;foobar&quot;</span>, <span class="string">&quot;foobaz&quot;</span>, <span class="string">&quot;fongopuckey&quot;</span>)</span><br><span class="line">    .filter(s -&gt; s.length() &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>流是一个与任何特定存储机制都没有关系的元素序列, 事实上, 我们说流&quot;没有存储&quot;.</p>
</li>
<li>
<p>借助流显示随机的5-20之间的整数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream/Randoms.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Randoms</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>)</span><br><span class="line">		.ints(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">		.distinct()</span><br><span class="line">		.limit(<span class="number">7</span>)</span><br><span class="line">		.sorted()</span><br><span class="line">		.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先为Random对象设置一个种子(这样程序每次运行都会得到相同的结果). ints() 方法会生成一个流, 两个参数可以设置所生成值的上下界. 这里生成了一个由随机的int组成的流, 我们使用中间流操作**distinct()<strong>去掉重复的值, 再使用</strong>limit()**选择前7个值. 然后我们告诉它, 希望元素是有序的(sorted()). 最后, 我们使用了 ForEach(), 它会根据我们传递的函数, 在每个流对象上执行一个操作. 这里我们传递了一个方法引用<code>System.out::println</code>, 用于将每个条目显示在控制台上.</p>
</li>
<li>
<p>collect会将将流 (惰性) 收集起来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Use&gt; predicate1 = user -&gt; user.getAge() &lt; <span class="number">21</span>;</span><br><span class="line">List&lt;User&gt; collect = list.stream().filter(predicate1).filter(user -&gt; user.getSalary() &gt; <span class="number">2000</span>).collect(Collections.toList()).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 构建流, 过滤, 收集器收集, 逐个打印</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>foreach是对列表操作, map / reduce则是对流操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** map */</span></span><br><span class="line">list.stream().map(num-&gt;num + <span class="number">10</span>);</span><br><span class="line"><span class="comment">/** reduce */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b).get()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>流还有 <code>distinct()</code>操作, 把相同的元素变为一个. 还有<code>sorted(Comparator.reserveOrder())</code></p>
</li>
<li>
<p>Iterate 迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>); <span class="comment">// 前项推后项, 从0开始</span></span><br><span class="line">stream.forEach(System.out::print);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Output: 0246810</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-9-Reflection">Java-Lesson 9 (Reflection)</h2>
<ol>
<li>
<p>Introspection 自省: 运行时观察到类型信息</p>
</li>
<li>
<p>Reflection 反射: 不仅是检查当前对象的类型, 还可以修改对象的一些性质 (控制改变).</p>
</li>
<li>
<p>反射的核心是JVM在运行时动态加载类或调用/访问属性, 它不需要事先 (静态编译器) 知道运行对象是谁.</p>
</li>
<li>
<p><em><strong>反射 (Reflection)</strong></em>  反射是一种在运行时可以检视自身程序和操纵程序内部属性的一种语言特性 (不是java独有的). 比如对于Java而言, 反射可以使其运行时动态的加载类并获取类的详细信息, 从而可以操作类和对象的属性和方法.</p>
</li>
<li>
<p>反射给静态语言Java带来了动态性. 反射机制允许程序在执行期借助反射API获得任何类的内部信息, 并能直接操作任意对象的内部属性和方法. (通过对象得到类的属性/ 方法/ 构造器…)</p>
</li>
<li>
<p>反射的坏处,  比正向直接执行相应的操作慢多了. (几十倍 - 上百倍) 关闭语言访问检查可以一定程度上快一些.</p>
</li>
<li>
<p>在加载完类后, 在堆内存区就产生了一个Class 类型的对象, 包含了完整的类的结构信息.</p>
</li>
<li>
<p>实体类 entity, 也称pojo (简单Java对象)</p>
</li>
<li>
<p><code>Class c = Class.forName(&quot;java.util.Stack&quot;);</code> 这里是大写Class, 是反射语法, Stack (栈) 这个类就被加载到 c 这个变量里面去了. 然后通过这个c 可以得到Stack的方法和变量. ( <code>c.getDeclaredMethods()</code> )</p>
</li>
<li>
<p>反射举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DumpMethods</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.Stack&quot;</span>);</span><br><span class="line">		Method m[] = c.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m.length; i++)</span><br><span class="line">			System.out.println(m[i].toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		System.err.println(e);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Class类的创建方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.reflection.Student&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Student.class;</span><br><span class="line"><span class="comment">// 仅对内置类型的包装类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Integer.TYPE;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​		还可以用对象的 <code>.getSuperClass()</code> 方法.</p>
<ol start="12">
<li>
<p>很多类型都有Class对象: 各种类, 接口, 数组, 枚举, 注解, 基本数据类型 (包装类), void.  数组只要是同样类型同维度都是同一个Class.</p>
</li>
<li>
<p>通过反射调用 (而不是正向调用)</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;TestInvoke&quot;</span>);</span><br><span class="line">			Class partypes[] = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">2</span>];</span><br><span class="line">			partypes[<span class="number">0</span>] = Integer.TYPE;</span><br><span class="line">			partypes[<span class="number">1</span>] = Integer.TYPE;</span><br><span class="line">			<span class="type">Method</span> <span class="variable">meth</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;add&quot;</span>, partypes);</span><br><span class="line">			<span class="type">TestInvoke</span> <span class="variable">methobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestInvoke</span>();</span><br><span class="line">			Object arglist[] = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">2</span>];</span><br><span class="line">			arglist[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">37</span>);</span><br><span class="line">            arglist[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">47</span>);</span><br><span class="line">			<span class="type">Object</span> <span class="variable">retobj</span> <span class="operator">=</span> meth.invoke(methobj, arglist); <span class="comment">// 通过反射api调用方法</span></span><br><span class="line">			<span class="type">Integer</span> <span class="variable">retval</span> <span class="operator">=</span> (Integer)retobj;</span><br><span class="line">			System.out.println(retval.intValue());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>
<p>通过反射可以获取很多类的信息.</p>
<p>c是Class类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> A.getClass();</span><br><span class="line">c.getName(); <span class="comment">// 包名 + 类名</span></span><br><span class="line">c.getSimpleName(); <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">c.getFields(); <span class="comment">// public的属性</span></span><br><span class="line">c.getDeclaredFileds(); <span class="comment">// 所有属性</span></span><br><span class="line">c.getDeclaredFiled(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获得name属性</span></span><br><span class="line"></span><br><span class="line">c.getMethods(); </span><br><span class="line">c.getDeclaredMethods(); </span><br><span class="line">c.getMethod(<span class="string">&quot;get&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">c.getMethod(<span class="string">&quot;set&quot;</span>, String.class); </span><br><span class="line"></span><br><span class="line">c.getDeclaredConstructors(); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反射获取类内的方法, 使用 <em>方法名.invoke(…)</em> 的方式, 以统一的方式调用类内函数.</p>
</li>
<li>
<p>反射可以用来创建类的实例对象. 可以对用反射创建的对象做很多事情.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.User&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)c1.newInstance(); <span class="comment">// 相当于调用一个无参的构造方法</span></span><br><span class="line"><span class="comment">// 调用有参的构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c1.getDeclaredConstructor(String.class, <span class="type">int</span>,class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)constructor.newInstance(<span class="string">&quot;chaos&quot;</span>, <span class="number">1</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 调用方法(通过invoke)</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">setName.invoke(user2, <span class="string">&quot;kid&quot;</span>); <span class="comment">// 第一个参数是隶属的对象, 第二个是所invoke方法的参数列表</span></span><br><span class="line"><span class="comment">// 操作属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 不能对private属性直接修改, 但是可以加上下面这条语句以关闭Java的语言访问检查</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">name.set(user2, <span class="string">&quot;Guy&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过反射获取泛型.</p>
<p>关于Java泛型，很多人都有一个误解，认为Java代码在编译时会擦除泛型的类型，从而在运行时导致没法访问其类型，这其实并不完全正确，因为有一部分泛型信息是可以在运行时动态获取的，这部分信息基本能够满足我们日常开发中的大多数场景，本节我们就来了解相关的知识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">getMethodReturnType</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">  <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> MyClass.class.getMethod(<span class="string">&quot;getStringList&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">  System.out.println(method.getReturnType());</span><br><span class="line">  <span class="type">Type</span> <span class="variable">retrunType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">  System.out.println(retrunType);</span><br><span class="line">  <span class="keyword">if</span>(retrunType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">type</span> <span class="operator">=</span> (ParameterizedType)retrunType;</span><br><span class="line">    Type[] typeArguments = type.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span>(Type typeArgument : typeArguments) &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">typeArgClass</span> <span class="operator">=</span> (Class)typeArgument;</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot;泛型类型：&quot;</span> + typeArgClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的关键在于 <code>ParameterizedType</code> 表示一种参数化类型. Java引入了包括<code>ParameterizedType</code> 的几种类型来支持反射操作泛型. 还有 <code>GenericArrayType</code> <code>TypeVariable</code> <code>WildcardType</code>.</p>
</li>
<li>
<p>反射操作注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建2个注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Interface</span> TableTest &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Interface</span> FieldTest &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableTest(&quot;database_student&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student1</span> &#123;</span><br><span class="line">    <span class="meta">@FieldTest(columnName = &quot;database_id&quot;, type = itn, length = 10)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@FieldTest(columnName = &quot;database_age&quot;, type = itn, length = 10)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span>() &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.Student1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用反射获取注解信息</span></span><br><span class="line">    Annotation[] ann = c1.getAnnotations();</span><br><span class="line">    System.out.println(ann);</span><br><span class="line">    </span><br><span class="line">    <span class="type">TableTest</span> <span class="variable">tabletest</span> <span class="operator">=</span> (TableTest)c1.getAnnotation(TableTest.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> tabletest.value();</span><br><span class="line">    System.out.println(val);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">// 获取字段</span></span><br><span class="line">    <span class="type">FieldTest</span> <span class="variable">annotation</span> <span class="operator">=</span> name.getAnnotation(FieldTest.class); <span class="comment">//获取注解</span></span><br><span class="line">    System.out.println(annotation.columnName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反射有什么用?</p>
<ul>
<li>Rapid Application Development (RAD)</li>
<li>Visual approach to GUI development</li>
<li>Requires information about component at run-time</li>
<li>Remote Method Invocation (RMI)</li>
<li>Distributed objects</li>
</ul>
<p>重要用途是各种通用框架的开发; 编写分布式代码; …</p>
</li>
</ol>
<h2 id="Java-Lesson-10-Annotation">Java-Lesson 10 (Annotation)</h2>
<ol>
<li>
<p>注解 Annotation – 可以被其他程序 (编译器) 识别 ; 注释 comment</p>
</li>
<li>
<p>内置注解</p>
<p><code>@Override</code> 重写(覆盖)</p>
<p><code>@Deprecated</code> 弃用</p>
<p><code>@SuppressWarnings()</code> 抑制警告 <strong>必须要有参数</strong> <code>(&quot;all&quot;)</code> , <code>(&quot;unchecked&quot;)</code>, <code>(value = &#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</code> 等</p>
<p>参数可以有哪些呢? deprecation - 使用了过时的类或方法 ; fallthrough - switch块缺少了break ; finally - 任何finally字句不能正常完成 ; … ; all - 所有情况</p>
</li>
<li>
<p>元注解 meta-annotation 注解的注解.</p>
<p><s>只有4个</s>, 有6个, Java 8 新增了 <code>@Repeatable</code> (用于定义可重复注解) 和 <code>@Native</code> (表示变量可被本地代码引用)</p>
<p><code>@Target</code> 用于描述注解的适用范围 有TYPE, FIELD, METHOD, PARAMETER, …</p>
<p><code>@Retention</code> 表示在什么级别上保存该注释信息, 用于描述注解的生命周期. 有SOURCE (源码), CLASS (字节码), RUNTIME. 一般是 RUNTIME</p>
<p><code>@Documented</code> 该注解包含在javadoc中 – 在javadoc生成api文档时, 被这个注解标记的元素在文档上也会出现该注解.</p>
<p><code>@Inherited</code> 子类可以继承父类的注解, 只对目标为类/ 接口/ 枚举有效.</p>
</li>
<li>
<p>自定义一个注解: (元注解派上用场)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target 元注解说明了注解适用范围是什么</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> MyAnnotation &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Target和Retention一般是必须的.</p>
</li>
<li>
<p>使用<code>@Interface</code>就定义了一个注解类型 (或称为<strong>元数据 meta-data</strong>) , 自动继承了<code>java.lang.annotation.Annotation</code>接口</p>
</li>
<li>
<p>如果在类内声明一个注解 不用加 public</p>
</li>
<li>
<p>定义自己的注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;Element,TYPE, Element.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 以下的无参方法并不真的是方法, 而是注解的属性, default xxx;是该属性的默认值. </span></span><br><span class="line">    <span class="comment">// 定义注解的属性 必须有(), 这里的()不是方法的那个括号</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>; <span class="comment">// 没有默认值必须在使用时加参数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>; <span class="comment">// 如果有默认值, 可以不传入</span></span><br><span class="line">    String[] schools();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果参数只有一个, 建议使用value命名, 此时可以省略 “value =”, 但是如果用其它的名字就不能省略.</p>
</li>
</ol>
<h2 id="Java-Lesson-11-Testing">Java-Lesson 11 (Testing)</h2>
<ol>
<li>
<p>为什么叫单元测试? – 这里的&quot;单元&quot;可以理解为Java中某个类的某个方法.</p>
</li>
<li>
<p>JUnit – 测试代码放在同一个包的不同目录 (/tests) 下</p>
</li>
<li>
<p>不同的方法注解 <code>@Test</code> <code>@BeforeAll</code> <code>@BeforeEach</code> <code>@AfterAll</code> <code>@AfterEach</code> <code>@Ignore</code>(暂不执行该测试方法)</p>
</li>
<li>
<p><code>@Test</code> 注解其实是有属性的 (可以加参数)</p>
<ul>
<li><code>expected</code> 期望异常</li>
<li><code>timeout</code> 性能测试</li>
</ul>
<p>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = Exception.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Math</span>().factorial(-<span class="number">1</span>);</span><br><span class="line">    fail(<span class="string">&quot;未抛出factorial参数负数异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test(timeout = 2000)</span></span><br><span class="line">quickSort() &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java assert – 不会执行, 除非加 <code>-ea</code> 选项.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="literal">false</span>: </span><br><span class="line">  <span class="string">&quot;Message saying what happened here&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Guava库中的测试方法 – <code>vertify(true);</code> <code>checkNotNull(s);</code></p>
</li>
<li>
<p>契约式编程 (DbC) : 客户调用某特定public方法时, 期望产生某些特定的行为</p>
<ol>
<li>可以明确规定这种行为, 就好像合同一样</li>
<li>可以通过某些运行时检查来保证这种行为, 也就是<strong>前置条件</strong>, <strong>后置条件</strong>和**不变项 (方法开头的, 方法末尾的) **.</li>
</ol>
</li>
<li>
<p>JUnit5 提供多种动态生成测试的方法, 如<code>DynamicTest.stream()</code></p>
</li>
<li>
<p>java <em><strong>日志</strong></em> – SLF4J / Log4j /…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.trace(<span class="string">&quot;&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;&quot;</span>);</span><br><span class="line">log.warn(<span class="string">&quot;&quot;</span>);</span><br><span class="line">log.error(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为什么使用日志? – 可以很容易地取消某个级别以下或全部日志, 且容易重新打开和禁止. 可以被定向到不同的处理器, 如控制台, 文件等. 过滤器可以按标准丢弃无用的记录项.</p>
</li>
<li>
<p>用getLogger创建自己的日志记录器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为静态字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.yourcompany.stack&quot;</span>);  <span class="comment">// 使用包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己创建处理器并且调整级别为FINE</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    logger.setLevel(Level.FINE); <span class="comment">// 若此处设置级别为OFF, 即关闭日志</span></span><br><span class="line">    logger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line">    handler.setLevel(Level.FINE);</span><br><span class="line">    logger.addHandler(handler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后, 在任何地方插入 <code>logger.fine()</code> 或其他的日志.</p>
</li>
<li>
<p>日志的常见用途是记录那些意料之外的异常, 以下两个方法通常使用:</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">throwing</span><span class="params">(String className, String methodName, Throwable t)</span> </span><br></pre></td></tr></table></figure>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level l, String message, Throwable t)</span></span><br></pre></td></tr></table></figure>
<p>例如:</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;...&quot;</span>) ;</span><br><span class="line">logger.throwing(<span class="string">&quot;com.mycompany.Reader&quot;</span>, <span class="string">&quot;read&quot;</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>
<p>日志执行的过程经过了 日志记录器 -&gt; 处理器, 还会有过滤器, 格式化器. 可以根据需要自己编写处理器和过滤器等.</p>
</li>
<li>
<p>由于所有级别为 INFO / WARNING / SEVERE 的消息都会显示到控制台上, 所以最好之将对用户有意义的消息设置为这几个级别, 而程序员想要的消息设置为FINE级别.</p>
</li>
<li>
<p>JMH基准测试工具.</p>
</li>
<li>
<p>JDK 默认附带 VisualVM 分析器. 静态分析器 - Findbugs (-&gt;Spotbugs)</p>
</li>
<li>
<p>要观察类的加载过程, 启动Java虚拟机时使用 -verbose 标志, 这样就可以看到类加载的信息, 有时候, 这对诊断类路径问题很有帮助.</p>
</li>
<li>
<p>- Xlint 选项告诉编译器找出常见的代码问题.</p>
</li>
<li>
<p>jconsole工具可以显示有关虚拟机的性能统计的结果, Java任务控制器 (Java Mission Control) 是一个专业级性能分析和诊断工具, 类似jconsole.</p>
</li>
</ol>
<h2 id="Java-Lesson-12-Collections">Java-Lesson 12 (Collections)</h2>
<ol>
<li>
<p>for-in 语法适用于数组和任何Collection对象.</p>
</li>
<li>
<p>任何自定义的类, 只要实现了<code>Iterable</code>接口, 都可以用for-in语法.</p>
</li>
<li>
<p>其原理是, Java 5 引入了一个叫<code>Iterable</code>的接口, 该接口包含一个可以生成 <code>Iteraor</code> 的方法 – iterator() 方法. 这个接口就可以用来遍历序列, 所以只要implement了Iterable接口, 就可以用for-in语法遍历了.</p>
</li>
<li>
<p>使用<strong>适配器方法 (Adapter Method) 惯用法</strong>, 为容器List增加一个能够返回逆序元素迭代器的方法作为适配器方法. 这样就可以实现逆序的 for-in 遍历.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReversibleList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterable</span>&lt;T&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;T&gt;() &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> size() - <span class="number">1</span>;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> get(current--);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ReversibleList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ReversibleList</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s : strings.reversed()) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>java.util.Collection</code> 和 <code>java.util.Collections</code> 的区别:</p>
<p><code>Collection&lt;E&gt;</code>是一个接口, 继承了 <code>Iterable&lt;E&gt;</code> , 是一个由单独元素组成的序列, 其子接口有<code>List&lt;E&gt;</code> <code>Set&lt;E&gt;</code> <code>Queue&lt;E&gt;</code>. (而存放一组键值对用接口 <code>Map&lt;K, V&gt;</code>) . 声明的方法有<code>size()</code> <code>add()</code> 等.</p>
<p><code>Collections</code> 是具体类, 提供了一系列操作或返回集合的静态方法.</p>
</li>
<li>
<p>在<code>java.util.Collections</code>类中定义了以下的<code>sort</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br></pre></td></tr></table></figure>
<p>该方法可以对列表进行排序, 但是要求列表中的所有元素必须实现 <code>Comparable</code> 接口 (中的<code>e1.compareTo(e2)</code>方法).</p>
</li>
<li>
<p>如果希望自己编写的类构成的列表可以排序, 需要在该类里实现一个<code>compareTo</code>方法. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getId().compareTo(o.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然而<code>sort</code>方法还有一个重载版本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>这里的参数多了一个比较器<code>Comparator&lt;T&gt;</code>, <code>Comparator&lt;T&gt;</code>接口是一个函数式接口, 它可以被赋值为lambda表达式或者是一个实现了该接口的对象.</p>
<p>这个接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以, 可以写出以下的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Employee&gt; compareById = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Employee&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Employee o1, Employee o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId().compareTo(o2.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用Lambda表达式, 可以写的更优雅些:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Employee&gt; compareById = (Employee o1, Employee o2) -&gt; </span><br><span class="line">    o1.getId().compareTo( o2.getId() );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-13-Inner-Class">Java-Lesson 13 (Inner Class)</h2>
<ol>
<li><code>jdk.internal.loader.ClassLoaders$AppClassLoader</code>  其中, <code>$</code>符号后面的类是<code>$</code>前面的类的内部类, 这是 <code>$</code> 的含义.</li>
</ol>
<h2 id="Java-Lesson-14-Concurrency">Java-Lesson 14 (Concurrency)</h2>
<ol>
<li>
<p>进程: <strong>操作系统</strong>进行资源分配和调度的一个独立单位, 也是一个具有独立功能的程序.</p>
<p>线程: 依托于进程而存在, 是CPU调度和分派的基本单位, 它是比进程<strong>更小的能独立运行的基本单位</strong>. 线程自己基本上不拥有资源, 但是它可与同属一个进程的其他线程共享进程所拥有的全部资源.</p>
<p>区别在于: 进程是资源分配的单位, 而线程是作业调度的单位; 进程拥有自己的地址空间, 而多个线程拥有自己的堆栈和局部变量, 并共享所依托于进程的资源.</p>
</li>
</ol>
<h2 id="Java-Lesson-14-1-Thread">Java-Lesson 14.1 (Thread)</h2>
<ol>
<li>
<p>Java关于线程编程的抽象:</p>
<ul>
<li>Thread对象像是运载火箭, Runnable / Callable的实现对象 (run方法) 像是一个荷载 (payload)</li>
<li>Runnable / Callable --&gt; 任务; Thread --&gt; 让任务启动.</li>
</ul>
</li>
<li>
<p><code>Runnable</code>接口 – 一个函数式接口, 里面只有一个<code>run</code>方法.</p>
<p>实现<code>Runnable</code>接口实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LiftOff</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">taskCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> taskCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiftOff</span><span class="params">(<span class="type">int</span> countDown)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">status</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;(&quot;</span> + (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">&quot;Liftoff!&quot;</span>) + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LiftOff</span> <span class="variable">launch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiftOff</span>(<span class="number">10</span>);</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Thread</code>类, 表示线程, 如果要创建一个新线程, 就要新创建一个<code>Thread</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicThreads</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 把任务装进线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LiffOff</span>(<span class="number">10</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// start 之后, 就会进入新线程的run()方法. </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for LiftOff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>除了通过实现<code>Runnable</code>接口来实现新的线程之外, 还可以直接继承<code>Thread</code>类, 直接重写<code>Thread</code>类下的<code>run</code>方法即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + getName() + <span class="string">&quot;(&quot;</span> + countDown + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (--countDown == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleThread</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这5个线程创建完之后, 线程运行的顺序不是你可以控制的, 多线程并发时, 执行的先后关系是不确定的, 这要交由操作系统的调度器决定.</p>
</li>
<li>
<p>创建线程并启动 (start) 后, 线程并不会立即执行, 而只是<strong>通知</strong>了JVM这个线程可以开始运行了. 然而调度过程不是由你控制的, 所以你不应该显式地调用<code>run</code>方法, 而是调用<code>start</code>方法. (run不是你能控制的)</p>
</li>
<li>
<p>尽管你知道你的机器是4核的, 并且写Java程序运行了4个线程, 但是这并不意味着就只有这4个线程, JVM底层还有线程, 所以, 一般我们不自己创建和销毁单个线程, 而是利用<code>ExecuteService</code>.</p>
</li>
<li>
<p>一般我们创建线程之后, 不会自己做启动这件事, 可以使用<code>ExecutorService</code>启动.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这条语句会创建一个带缓存的线程池</span></span><br><span class="line">    	<span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">// 新的带缓存的线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池, 不再接受新任务, 不是把虚拟机停掉, 只是不再给出任务</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>带缓存的线程池</em> – 根据需要创建新线程的线程池, 如果现有线程没有可用的, 则创建一个新线程并添加到池中, 如果有被使用完但是还没被销毁的线程, 就复用线程池.</p>
</li>
<li>
<p>每一个线程要能够执行, JVM会为之准备一堆的事情 (准备栈, PC, …), 严重地消耗时间和内存空间. 所以为了提高效率, 应该避免手动创建和销毁线程, 而是交给线程池管理.</p>
</li>
<li>
<p>还可以创建一个固定线程数的线程池 (FixedThreadPool), 在任何时候最多只有n个线程被创建, 若在所有的线程都处于活动状态时, 有其他任务提交, 他们将等待队列中直到线程可用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 最多只有5个线程被创建</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    exec.execute(<span class="keyword">new</span> <span class="title class_">LiftOff</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>线程池常见用法:</p>
<ol>
<li>
<p>调用 <code>Executor</code> 类的静态方法 新建带缓存的或者固定线程数的线程池.</p>
</li>
<li>
<p>调用 <code>submit</code> 提交 <code>Runnable</code> 或 <code>Callable</code> 对象.</p>
</li>
<li>
<p>保存好返回的 <code>Future</code> 对象, 以便得到结果或者取消任务.</p>
</li>
<li>
<p>当不想再提交任何任务时, 调用shutdown. (-&gt; 不是销毁掉, 而是进入不接受新任务的状态)</p>
</li>
</ol>
</li>
<li>
<p>如果需要获得一个返回值, 而不是像 run 方法一样返回void, 那么就使用 <code>Callable&lt;V&gt;</code> 对象, 而不是<code>Runnable&lt;V&gt;</code> 对象.</p>
</li>
<li>
<p>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;做一些耗时的任务...&quot;</span>);</span><br><span class="line">    	Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureSimpleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 这里使用的是submit, 而不是execute, 区别在于submit会返回一个Future类型的对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;得到异步任务返回结果: &quot;</span> + future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>什么是 <code>Future</code> 类型的对象?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p>Future代表了一个异步计算的结果. 这个结果只有等到计算过程结束后, 才能通过<code>get()</code>方法获得, 如果还没有结束, get方法的调用就会阻塞 (block) .</p>
</li>
<li>
<p><code>Thread.sleep(1000); </code> 线程停止1000ms, 为了避免歧义, 现在通常使用<code>TimeUnit.MILLISECONDS.sleep(100); </code> 实际上使CPU处于了不是满载, 但是是停止状态, CPU在空转 (而不是在进行任何操作) , 等待若干时钟周期, 然后进入下一条指令执行.</p>
</li>
<li>
<p><code>yield</code> 让位. 提醒调度器当前线程愿意让出它当前对于处理器的使用, 由调度器决定是否要将此线程让出.</p>
</li>
<li>
<p><code>yield</code>和<code>sleep</code>的主要区别:</p>
<p>sleep是暂停CPU的处理下一条指令.</p>
<ol>
<li>yield会临时暂停当前线程, 让同样优先级的正在等待的线程有机会执行</li>
<li>若没有正在等待的线程或者所有正在等待的线程的优先级都较低, 则继续运行</li>
<li>执行yield的线程何时继续运行由线程调度器来决定, 不同厂商可能有不同行为</li>
<li>yield方法不保证当前的线程会暂停或停止, 但是可以保证当前线程在调用yield方法时会放弃CPU (让调度器决策一下)</li>
</ol>
</li>
<li>
<p>优先级 (priority) : 可以使用 <code>setPriority()</code> 方法来改变线程的优先级 (<code>Thread.MAX_PRIORITY</code>) , 但是不应该自己改变优先级, 而应该让系统自己决定.</p>
</li>
<li>
<p>Daemon线程, demon线程是一种不会阻止JVM退出 (JVM的main方法运行结束了) 的线程. 即main thread执行完了且其它所有的非daemon threads都执行完了, JVM就会退出.</p>
</li>
</ol>
<h2 id="Java-Lesson-14-2-Synchronize">Java-Lesson 14.2 (Synchronize)</h2>
<ol>
<li>
<p>本节讲解线程之间的同步问题.</p>
</li>
<li>
<p><code>Thread</code> 类有一个 <code>join()</code> 方法, join方法直到run方法停止后才会执行, 若run方法运行被打断, 抛出异常.</p>
</li>
<li>
<p>利用 join() 可以保证一个线程在另一个线程之后执行. (实现<em><strong>线程同步</strong></em>)</p>
</li>
<li>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleeper</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sleeper</span><span class="params">(String name, <span class="type">int</span> sleepTime)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        duration = sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; was interrupted.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; has awakened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joiner</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Joiner</span><span class="params">(String name, Sleeper sleeper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.sleeper = sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleeper.join(); <span class="comment">// 必须sleeper线程运行完之后, join()方法才执行, joiner线程才能往下执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; join completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Thread</code>类里面还有一个 <code>interrupt()</code> 方法, 给当前线程发一个interrupt消息打断这个线程, 如果线程在sleep中收到了interrupt消息, 就会触发一个<code>InterruptedException</code>.</p>
</li>
<li>
<p>每个线程运行时都可能发生异常 (这种运行时异常编译时往往无法捕获), 而这些异常显然无法通过在main thread里面写 try catch来捕获, 而是应该使用<em>UncaughtExceptionHandler</em>, 即<strong>创建一个异常处理器</strong>, 实现 <code>Thread.UncaughtExceptionHandler</code>接口, 然后对 (希望创建的) 线程t调用方法 <code>t.setUncaughtExceptionHandler(new ...)</code> 来设置异常处理器 (表示如果线程t中出现异常, 希望被怎么处理), <strong>设置了Uncaught异常处理器后</strong>线程t中抛出的异常就会被异常处理器处理 (从而没有直接抛出来, 而是被handler解决).</p>
</li>
<li>
<p>更进一步地, 当我们使用很多线程时, 我们希望对于这些所有线程, 对于整个JVM设置一个default的 UncaughtExceptionHandler. 这样在整个JVM运行中, 只要出现了运行时异常, 就会被默认Handler处理, 这是一个简单的做法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SettingDefaultHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>());</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em><strong>资源共享问题</strong></em></p>
<p>在数据库领域, 这个问题就是数据一致性.</p>
<p>例如: 多个线程同时操作同一个数据 (如局部变量), 由于堆区的数据是共享的, 所以数据不一致.</p>
</li>
<li>
<p>race condition(竞争条件) 多个资源竞争不能被同时访问的资源</p>
</li>
<li>
<p>解决方案: 对资源加锁, 确保一个时刻只有一个任务在使用共享资源 (使其互斥)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title class_">IntGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentEvenValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 即创建一个锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			++currentEvenValue;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">			++currentEvenValue;</span><br><span class="line">       		<span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 即是return了, finally里面的语句还会执行</span></span><br><span class="line">            lock.unlock(); <span class="comment">// 一定要用try-catch的finally释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> <span class="title class_">MutexEvenGenerator</span>(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ReentrantLock</code> 类, 里面的方法<code>tryLock()</code> 尝试获取锁, 返回成功与否, 若有参数 <code>tryLock(timeout, TimeUnit.SECONDS)</code>, 则会等timeout个TimeUnit的时间, 若这段时间内获取锁成功也返回true.</p>
</li>
<li>
<p><code>Synchronized</code> 关键字 – 只允许一个线程进入这一方法, 这整个方法不允许被多个线程同时调用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>synchronized</code>标记了是一个 <strong>临界区 (critical sections)</strong> , 整个临界区一次只有一个线程可以进入.</p>
</li>
<li>
<p><code>synchronized</code>不仅可以用于修饰方法, 也可以修饰代码片段, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line"> 		<span class="type">int</span> field;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            p.incrementX();</span><br><span class="line">            p.incrementX();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要加 <code>this</code>? 这涉及了Java <code>synchronized</code> 的设计理念, <code>synchronized</code>实际上是对于对象加锁.</p>
<p>Java VM中为每一个对象都对应维护一个 <em><strong>monitor</strong></em> (管程) , 用于实现多个线程执行该对象上同步方法时JVM检查该对象的管程:</p>
<ul>
<li>如果该对象管程未被占有, 当前调用线程可获得所有权并被允许执行该方法;</li>
<li>如果一个管程被另一个线程所有, 则调用线程需要等待管程被释放.</li>
</ul>
<p>当一个方法完成同步方法调用时, 它释放管程所有权, 等待该管程的线程被允许执行同步方法.</p>
<p>而synchronized的实现就是通过控制<strong>管程</strong> <em>(monitor)</em> 的所有权做到的.</p>
</li>
<li>
<p>即, synchronized的方法的调用必须要获得该方法所在对象的管程所有权.</p>
</li>
<li>
<p><strong>生产者-消费者问题</strong>, 对于一个对象的<code>get</code>和<code>put</code>方法, 给二者加上<code>synchronized</code>修饰, 那么在执行put / get时, 方法所在对象的管程被占有, 保证另一个方法不会同时执行.</p>
</li>
<li>
<p>如果buffer满了, 那么等待直到消费者来get.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">Put</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == buffer.length) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; wait(); &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// producing...</span></span><br><span class="line">    notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wait</code> 和 <code>notify</code> 是什么?</p>
<p><code>wait</code> – 释放锁 (管程), 停下此线程 (suspend the calling thread), 等待 (希望别人拿走管程) (release the ownership of the monitor),</p>
<p><code>notify</code>– 如果一个线程执行了<code>wait()</code>方法而被挂起, 那么只有当另一个线程调用了<code>notify() / notifyAll()</code>睡着的线程才会醒来.</p>
<p>简单来说, <code>notify</code> 就是<strong>提醒睡着的线程醒来</strong> (通知所有正在等待获取monitor所有权的线程醒来).</p>
</li>
<li>
<p><code>wait</code> 的作用是: 如果拿到了锁, 但是检查条件后发现不满足使用条件(不应该做后续事情), 那么不要拿着锁不放, 否则就死锁了. 通过wait方法把锁让出来, 使得别的线程可以调用synchronized方法. (在拿到锁后不应该做事时不要拿着锁死等不放)</p>
</li>
<li>
<p><code>wait()</code>和<code>notify()</code>都是Object类下定义的方法, 因为管程是每一个对象所维护的, 而这两个方法用于释放和转移monitor的所有权, 所以这两个方法在Object下定义, 而不是在<code>Concurrency</code>包下定义.</p>
</li>
<li>
<p>举例: 生产者消费者 (<code>PC.java</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] buffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Buffer(<span class="type">int</span> size) &#123;</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="title class_">char</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">Put</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == buffer.length) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123; wait(); &#125;</span><br><span class="line">        	<span class="keyword">catch</span> (InterruptedException e) &#123; &#125; </span><br><span class="line">        	<span class="keyword">finally</span> &#123; &#125; </span><br><span class="line">    	&#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;Producing &quot;</span> + c + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">        buffer[in] = c;</span><br><span class="line">        in = (in + <span class="number">1</span>) % buffer.length;</span><br><span class="line">        count++;</span><br><span class="line">        notify(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">char</span> <span class="title function_">Get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123; wait(); &#125;</span><br><span class="line">        	<span class="keyword">catch</span> (InterruptedException e) &#123; &#125; </span><br><span class="line">        	<span class="keyword">finally</span> &#123; &#125; </span><br><span class="line">    	&#125; </span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> buffer[out];</span><br><span class="line">        out = (out + <span class="number">1</span>) % buffer.length;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consuming &quot;</span> + c + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">        notify(); </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    </span><br><span class="line">    Producer(Buffer b) &#123;</span><br><span class="line">        buffer = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.Put((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i % <span class="number">26</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Buffer buffer;</span><br><span class="line">    </span><br><span class="line">    Consumer(Buffer b) &#123;</span><br><span class="line">        buffer = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.Get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(b);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(b);</span><br><span class="line"></span><br><span class="line">        p.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>线程状态: Start ; Runnable (等待运行状态, 可以由Running状态yield退回) ; Running ; Blocked(由Running状态<code>sleep</code>/<code>suspend</code>/<code>wait</code>进入, <code>resume</code>/<code>notify</code>退出) ; Stop (线程执行停止)</p>
</li>
<li>
<p><strong><code>wait</code>和<code>sleep</code>的区别</strong>:</p>
<ul>
<li>调用wait方法时, 线程在等待时会释放掉它所获得的monitor, sleep则不会;</li>
<li>wait应该在同步代码块中调用, 而sleep可以在任何地方调用;</li>
<li><strong>Thread</strong>.sleep()是一个静态方法, 作用在当前线程上, 而wait是一个实例方法, 只能在其他线程调用本实例的<code>notify()</code>方法时被唤醒.</li>
</ul>
<p>只是要让线程停止一段时间 – sleep() ; 要实现线程之间通信 – wait()</p>
</li>
<li>
<p>线程本地存储 (Thread local Storage, TLS) : 变量的可见域为线程内. (在线程内全局可访问, 但是不能被其他线程访问到, 这样保证了数据的独立性, 从而避免了线程同步问题)</p>
</li>
<li>
<p>Java使用 <code>ThreadLocal</code> 对象实现线程本地存储:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Accessor</span><span class="params">(<span class="type">int</span> idn)</span> &#123;</span><br><span class="line">        id = idn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            ThreadLocalVariableHolder.increment(); <span class="comment">// 尽管是同一个静态字段, 但是由于引用者处于不同线程, 所以各自的线程拿到的和使用的数据是各自的</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>);</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;: &quot;</span> + ThreadLocalVariableHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalVariableHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123; <span class="comment">// 定义线程局部变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Accessor</span>(i));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);  <span class="comment">// Run for a while</span></span><br><span class="line">        exec.shutdownNow();         <span class="comment">// All Accessors will quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java-Lesson-14-3-concurrent包">Java-Lesson 14.3 (concurrent包)</h2>
<ol>
<li>
<p>Java中的 <code>java.util.concurrent</code>包下有很多有用的工具.</p>
</li>
<li>
<p><code>CountDownLatch</code> 允许一个或多个线程等待直到一系列操作在另外的线程中完成. (用于线程同步, 比<code>join</code>更灵活)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">startSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">doneSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(N);</span><br><span class="line">startSignal.countDown();      <span class="comment">// let all threads proceed //对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。</span></span><br><span class="line">doneSignal.await();           <span class="comment">// wait for all to finish //阻塞当前线程，将当前线程加入阻塞队列。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>CyclicBarrier</code> 循环栅栏 : 只有当所有的栅栏拦住的所有线程都准备好时, 栅栏才放开.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUM, <span class="keyword">new</span> <span class="title class_">AggregatorThread</span>()); <span class="comment">// 参数分别是 1:参与线程的个数 2: 线程到达屏障时, 优先执行的action</span></span><br><span class="line">cyclicBarrier.await(); <span class="comment">// 表示线程已经到达栅栏</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ScheduledThreadPoolExecutor</code> 一种特殊的<code>ThreadPoolExecutor</code>(线程池执行者) , 比起<code>Cached</code>和<code>Fixed</code>的Executor, <code>ScheduledThreadPoolExecutor</code>可以让任务等一段时间在运行, 也可以规定多个任务以一个固定的速率启动. (can additionally schedule commands to run after a given delay, or to execute periodically.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">scheduler</span> <span class="operator">=</span> (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(<span class="number">1</span>); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Semaphore</code> 信号量: 指定一个资源使用量的上限是多少. (若信号量为1, 即是互斥的资源)</p>
</li>
<li>
<p><code>CompletableFuture</code></p>
</li>
<li>
<p><code>Exchanger</code></p>
</li>
<li>
<p><code>DelayQueue</code> 放入数据设置delay时间, 只有过了指定的时间之后数据才能被取走. (用于服务器对于用户请求排队)</p>
</li>
</ol>
<h2 id="Java-Lesson-15-VM">Java-Lesson 15 (VM)</h2>
<p>必读: <a target="_blank" rel="noopener" href="https://blog.jamesdbloom.com/JVMInternals.html">https://blog.jamesdbloom.com/JVMInternals.html</a></p>
<p>参考: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/682004204">https://zhuanlan.zhihu.com/p/682004204</a></p>
<ol>
<li>
<p>Java虚拟机的内存包括以下5个区域 :</p>
<ul>
<li>
<p><strong>堆 (Heap)</strong> – new出来的对象, 可以被所有线程共享</p>
</li>
<li>
<p><strong>栈 (JVM Language Stacks)</strong> – 存放基本变量类型和引用类型</p>
</li>
<li>
<p><strong>方法区 (Method Area)</strong> – 包含了所有的class和static变量, 包含类的数据(静态变量, 静态方法, 常量池, 代码…), 被所有线程所共享 ( (HotSpot中) 方法区仅仅在逻辑上独立, 物理上包含在Java堆中 )</p>
</li>
<li>
<p><strong>PC Registers</strong></p>
</li>
<li>
<p><strong>Native Method Stacks</strong> (运行用C语言等编写的本地方法时使用)</p>
</li>
</ul>
</li>
<li>
<p>方法区中保存了每一个类的信息. 包括:</p>
<ul>
<li>Classloader Reference 由哪个类加载器加载的</li>
<li>Run Time Constant Pool 运行时常量池 (类似C/ C++的符号表)</li>
<li>Field data</li>
<li>Method data</li>
<li>Method code</li>
</ul>
</li>
<li>
<p>使用<code>javap</code>命令查看字节码信息. 敲入<code>javap -help</code>以获取帮助.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p -s -sysinfo -constants MyClass</span><br></pre></td></tr></table></figure>
<p>获取字节码相关信息.</p>
</li>
<li>
<p>所有的类都是在对其<strong>第一次使用</strong> (类缓存保证了只加载第一次) 时, 动态加载到JVM中去的.</p>
</li>
<li>
<p>一旦某个类的 <code>Class</code> 对象被载入内存, 它就被用来创建这个类的所有对象.</p>
</li>
<li>
<p>当程序创建第一个对类的静态成员的引用时 (包括使用new语句新建对象) , JVM会使用类加载器根据类名查找.class文件.</p>
</li>
<li>
<p>类的加载 (Load) -&gt; 类的链接 (Link) -&gt; 类的初始化 (Initialize)</p>
</li>
<li>
<p>加载: 将class文件<em><strong>字节码</strong></em>内容加载到内存中, 并将这些静态数据转换成方法区的运行时数据结构, 然后生成一个代表这个类的java.lang.Class对象 ( Class对象在堆区 ).</p>
<p>Java类由 <code>java.lang.ClassLoader</code> 加载, 那么ClassLoader类由谁加载? – <code>Bootstrap Class Loader</code> ( <code>/ˈbutˌstræp/</code>) , 特殊的Class Loader, 一般不用Java语言编写, 而是用C语言等本地代码写, 与具体的平台实现相关.</p>
<p>此外, 还有extension class loader (java 9以后叫platform class loader), 用于加载放在 <code>java.ext.dirs</code> 目录下的java扩展类型.</p>
<p>system class loader / application class loader, 加载你自己在java应用里面写的类型, 从命令行选项中的 <code>-classpath</code> 或 <code>-cp</code> 下寻找.</p>
</li>
<li>
<p>链接: 将Java类的二进制代码合并到JVM的运行状态之中的过程.</p>
<p>验证 – 验证加载的类信息没有安全方面的问题,</p>
<p>准备 – 在方法区为static变量分配内存并设置默认初始值,</p>
<p>解析-- 常量池内的符号引用(name) 被替换为 直接引用(地址).</p>
</li>
<li>
<p>初始化:</p>
</li>
</ol>
<p>执行类构造器中的&lt;clinit&gt;() 方法, 由所有static变量的赋值和静态代码块中的语句合并起来构成. (按源码的<strong>字面</strong>顺序执行静态语句)</p>
<p>若发现其父类没有初始化, 先触发其父类的初始化</p>
<p>保证一个类的&lt;clinit&gt;() 方法在多线程环境中被正确加锁和同步.</p>
<ol start="11">
<li>
<p>什么时候会发生类的初始化?</p>
<ul>
<li>
<p>类的主动引用 (一定发生类的初始化)</p>
<p>​	1. 虚拟机启动时, 先初始化main方法所在的类</p>
<p>​	2. new一个对象时</p>
<p>​	3. 调用类的静态成员 (除final常量) 和静态方法</p>
<p>​	4. 使用<code>java.lang.reflect</code>包的方法对类进行反射调用</p>
<p>​	5. 初始化一个类, 但是父类没有被初始化则会先初始化其父类</p>
</li>
<li>
<p>类的被动引用 (<strong>不会</strong>发生类的初始化)</p>
<ol>
<li>当访问一个静态域时, 只有真正声明这个域的类才会被初始化. 如: 当通过子类引用父类的静态变量, 不会导致子类初始化.</li>
<li>通过数组定义类引用, 不会触发此类的初始化. (数组只是给它定义一个名字) (<code>A[] arr = new A[5];</code>)</li>
<li>引用常量不会触发此类的初始化. (常量在链接时就被放入常量池了)</li>
</ol>
</li>
</ul>
</li>
<li>
<p>初始化的顺序: 静态字段和静态代码块初始化 -&gt; 成员变量和非静态代码块初始化 -&gt; 构造方法; 若有父类, 先初始化父类.</p>
</li>
<li>
<p><strong>类缓存</strong> – 标准的JavaSE类加载器可以按照要求查找类, 但一旦某个类被加载到类加载器中, 它将维持一段时间 (缓存), 不过JVM回收机制可以回收这些Class对象.</p>
</li>
<li>
<p>类加载器 – 用来把类 (class) 装载进内存. 有引导类加载器, 扩展类加载器, 系统类加载器 (AppClassLoader) (最常用, 用于加载用户自己写的类)</p>
</li>
<li>
<p>用户也可以自定义类加载器, 是Application Class Loader的子类. (重写类加载器类的<code>findClass(String name)</code> 方法即可实现自己的类加载器) 实现自己的类加载器是有用的, 例如浏览器使用独立的类加载器加载来自不同网页的小程序, 这样即使小程序重名也会被认为成是不同的部分.</p>
</li>
<li>
<p>双亲委派机制 – 类加载时, 类加载器会一直向父加载器 (parent class loader) 委派 (application class loader -&gt; platform class loader) , 直到根类加载器 (引导类加载器, bootstrap class loader), 如果父类加载器加载失败 (返回null) , 就依次交由下一级进行加载. (所以从库里找的顺序是从父到子.)</p>
</li>
<li>
<p>父类 (parent) 加载器并不是子类加载器的父类 (super class).</p>
</li>
<li>
<p>这一机制的核心思想在于, 当遇到一个加载请求时, <strong>先尝试的是向上委派, 而不是先尝试自己加载</strong>. <strong>下层加载的类型不能被上层看到</strong>.</p>
</li>
<li>
<p><strong>所以你不能写个恶意的String类型替换掉系统内部的String.</strong></p>
</li>
<li>
<p>类加载机制的高级应用: 对加载的字节码进行修改, 改变类的行为; 运行时动态创建类型 -&gt; 高级的Java应用技术.</p>
</li>
<li>
<p>Java类加载机制: 当触发类加载的时候，类加载器也不是直接加载这个类。首先交给 <code>AppClassLoader</code> ，它会查看自己有没有加载过这个类，如果有直接拿出来，无须再次加载，如果没有就将加载任务传递给 <code>ExtClassLoader</code> ，而 <code>ExtClassLoader</code> 也会先检查自己有没有加载过，没有又会将任务传递给 <code>BootstrapClassLoader</code> ，最后 <code>BootstrapClassLoader</code> 会检查自己有没有加载过这个类，如果没有就会去自己要寻找的区域去寻找这个类，如果找不到又将任务传递给 <code>ExtClassLoader</code> ，以此类推最后才是 <code>AppClassLoader</code> 加载我们的类。</p>
</li>
</ol>
<h2 id="Java-Regexes">Java Regexes</h2>
<ol>
<li>
<p>Java也有正则表达式, 常用于各种字符串处理.</p>
</li>
<li>
<p><code>.</code> 任意字符 (不能是换行)</p>
<p><code>*</code> 重复0次或更多次</p>
<p><code>+</code> 重复1次或更多次</p>
<p><code>?</code> <strong>重复0或1次</strong> (表示可选的)</p>
<p><code>&#123;m&#125;</code> 重复m次</p>
<p><code>&#123;m, n&#125;</code> 重复m ~ n次</p>
<p><code>^</code> 匹配字符串开头</p>
<p><code>$</code> 匹配字符串结尾</p>
<p><code>[]</code> 必须匹配括号里的内容</p>
<p><code>[^]</code> 必须匹配除了括号里以外的字符 (这里^的意思与之前)</p>
</li>
<li>
<p><code>\w</code>: [a-zA-Z0-9_] 即构成一个单词的所有可能组合, 字母数字下划线.</p>
<p><code>\d</code>: [0-9] digits</p>
<p><code>\D</code>: [^0-9] not a digit</p>
<p><code>\s</code>: 空白字符</p>
<p><code>\S</code>: 空白字符</p>
<p><code>\W</code>: [^a-zA-Z0-9_] 非单词字符以外所有字符</p>
</li>
</ol>
<h2 id="Jar包">Jar包</h2>
<ol>
<li>
<p>只要涉及到Java的项目, 就不可避免地接触到jar包. 而实际开发中，maven, gradle等项目管理工具为我们自动地管理jar包以及相关的依赖, 让jar包的调用看起来如黑盒一般&quot;密不透风&quot;. 本节让我们打开这个黑盒, 了解有关jar包的知识. (参考 - Java核心技术)</p>
</li>
<li>
<p>jar包就是 Java Archive File, 是Java的一种文档格式, 是一种与平台无关的文件格式, 可将多个文件合成一个文件. 与zip包很相似, 准确的说, jar和zip的唯一区别就是在jar文件的内容中, 包含了一个 <code>META-INF/MAINIFEST.MF</code> 文件, 作为jar里面的详情单.</p>
</li>
<li>
<p>jar包主要是对class文件进行打包, 这意味着jar包是跨平台的.</p>
</li>
<li>
<p>使用指令 <code>jar -tf xxx.jar</code> 查看jar里面的内容.</p>
</li>
<li>
<p>可以查看到jar包里面一般有 .MF .class 文件, 还有静态资源文件如 .html, .css 以及 .js等.</p>
</li>
<li>
<p>jar包用于发布, 方便将自己实现的功能提供给别人使用.</p>
</li>
<li>
<p>还有war包, war包是一个可以直接运行的web模块, 通常应用于web项目中, war包可以部署到Tomcat等容器中, war包能打包的内容jar包都可以打包.</p>
</li>
<li>
<p>如何打jar包? 首先将编写好的java项目用<code>javac</code>命令生成字节码文件, 然后在命令行中执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf xxx.jar com/src/A.class com/B.class</span><br></pre></td></tr></table></figure>
<p>c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名.</p>
</li>
<li>
<p>手动打jar包需要自己新建MANIFEST文件, 一般使用intellij idea打包, 步骤如下:</p>
<ol>
<li>找到FILE/ Project Structure</li>
<li>点击 Artifacts</li>
<li>点击绿色的 “+” 号, 选择JAR -&gt; Empty</li>
<li>然后按照提示设置jar包名, 目标路径, 需要打包的文件即可.</li>
<li>然后点击菜单中的Build, 选择Build Artifacts…, 然后双击弹窗中的Build即可. (END)</li>
</ol>
</li>
<li>
<p>如何执行一个jar包? 很简单, 一般只要执行指令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure>
<p>但是, 这样可能会出现不知道指定的main方法所在的问题, 可以通过一下指令动态指定:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp xxx.jar com.src.A</span><br></pre></td></tr></table></figure>
<p>即通过-cp指定main方法所在的类.</p>
</li>
<li>
<p>甚至用户可以通过双击JAR文件图标来启动应用程序.</p>
</li>
<li>
<p>读取jar包内的资源文件, 使用 <code>getResourceAsStream()</code> 这一api来实现.</p>
</li>
<li>
<p>如何使用IDEA导入第三方jar包: 使用IDEA打开项目, 找到FILE/ Project Structure , 然后选择 Modules -&gt; Dependencies -&gt; + -&gt; Jars or directories, 导入jar包所在的本地路径.</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaos-warzh.github.io">Zhaohui Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaos-warzh.github.io/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://chaos-warzh.github.io/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaos-warzh.github.io" target="_blank">chaos-warzh's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/03/02/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C语言复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言复习笔记</div></div><div class="info-2"><div class="info-item-1">C语言复习笔记 Lesson 1: 输入输出   program程序 Operations运算符 expressions表达式 statements语句   理解第一个程序hello.c的各个部分： 12345#include : preprocessor directive 预处理指令main: function 函数int main(): takes no arguments, return an integer 无参数, 返回整型main: .c contains one and only one main function 一个.c文件有且仅有一个main函数printf: print+f: format 格式化输出   %f或者%lf都表示匹配输出double类型的值；但是scanf输入只能使用%lf匹配   如果是输入输出的是long double类型, 对应的格式串是 %Lf.   const double PI;  定义常量, 常量要全大写命名。   % 和 f 中间可以有一些东西. 例如%10.2f这里的点不是小数点, 而是分隔的意思, 10表示字段的宽度为...</div></div></div></a><a class="pagination-related" href="/2024/03/04/Golang%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Golang复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang复习笔记</div></div><div class="info-2"><div class="info-item-1">Golang复习笔记 1: intro   Golang: 极简单的部署方式  可直接编译成机器码 不依赖其它库 直接运行可部署    Golang是一门静态类型语言 – 编译时可检查出隐藏的问题   语言层面的并发  天生支持并发 充分利用多核  123456789101112131415161718package mainimport (	&quot;fmt&quot;    &quot;time&quot;)func goFunc(i int) &#123;    fmt.Println(&quot;goroutine &quot;, i, &quot; ...&quot;)&#125; func main() &#123;    for i := 0; i &lt; 10000; i++ &#123;        go goFunc(i) // 开启一个并发协程    &#125;        time.Sleep(time.Second)&#125;   强大的标准库  runtime系统调度机制 高效的GC...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhaohui Wang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chaos-warzh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/chaos-warzh" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>(2024-03-02) <br> Thank you for visiting my website! <br> I am an undergraduate student with a passion for exploring languages, logic, and software craftsmanship. </p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java复习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-0-Resources"><span class="toc-number">1.1.</span> <span class="toc-text">Java-Lesson 0 (Resources)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-1-Basic-Grammar"><span class="toc-number">1.2.</span> <span class="toc-text">Java-Lesson 1 (Basic Grammar)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-2-Control-Flow-Container"><span class="toc-number">1.3.</span> <span class="toc-text">Java-Lesson 2 (Control Flow, Container)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-3-File-Exception"><span class="toc-number">1.4.</span> <span class="toc-text">Java-Lesson 3 (File, Exception)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-4-String"><span class="toc-number">1.5.</span> <span class="toc-text">Java-Lesson 4 (String)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-5-OOP"><span class="toc-number">1.6.</span> <span class="toc-text">Java-Lesson 5 (OOP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-5-1-inheritance"><span class="toc-number">1.7.</span> <span class="toc-text">Java-Lesson 5.1 (inheritance)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-6-Generics"><span class="toc-number">1.8.</span> <span class="toc-text">Java-Lesson 6 (Generics)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-7-FP-Interface"><span class="toc-number">1.9.</span> <span class="toc-text">Java-Lesson 7 (FP &amp; Interface)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-8-Stream"><span class="toc-number">1.10.</span> <span class="toc-text">Java-Lesson 8 (Stream)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-9-Reflection"><span class="toc-number">1.11.</span> <span class="toc-text">Java-Lesson 9 (Reflection)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-10-Annotation"><span class="toc-number">1.12.</span> <span class="toc-text">Java-Lesson 10 (Annotation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-11-Testing"><span class="toc-number">1.13.</span> <span class="toc-text">Java-Lesson 11 (Testing)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-12-Collections"><span class="toc-number">1.14.</span> <span class="toc-text">Java-Lesson 12 (Collections)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-13-Inner-Class"><span class="toc-number">1.15.</span> <span class="toc-text">Java-Lesson 13 (Inner Class)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-14-Concurrency"><span class="toc-number">1.16.</span> <span class="toc-text">Java-Lesson 14 (Concurrency)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-14-1-Thread"><span class="toc-number">1.17.</span> <span class="toc-text">Java-Lesson 14.1 (Thread)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-14-2-Synchronize"><span class="toc-number">1.18.</span> <span class="toc-text">Java-Lesson 14.2 (Synchronize)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-14-3-concurrent%E5%8C%85"><span class="toc-number">1.19.</span> <span class="toc-text">Java-Lesson 14.3 (concurrent包)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Lesson-15-VM"><span class="toc-number">1.20.</span> <span class="toc-text">Java-Lesson 15 (VM)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Regexes"><span class="toc-number">1.21.</span> <span class="toc-text">Java Regexes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jar%E5%8C%85"><span class="toc-number">1.22.</span> <span class="toc-text">Jar包</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="2024-NJUSE-编译原理">2024-NJUSE-编译原理</a><time datetime="2025-02-25T06:50:49.000Z" title="发表于 2025-02-25 14:50:49">2025-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/2024%E6%AF%95%E6%98%87%E6%9D%AF%E6%80%BB%E7%BB%93/" title="2024毕昇杯总结.md">2024毕昇杯总结.md</a><time datetime="2024-08-22T14:24:48.000Z" title="发表于 2024-08-22 22:24:48">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/18/RISC-V%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90%E8%B8%A9%E5%9D%91/" title="backend-bugs">backend-bugs</a><time datetime="2024-07-17T17:53:21.000Z" title="发表于 2024-07-18 01:53:21">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/Compilers%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/" title="Compilers 框架指南">Compilers 框架指南</a><time datetime="2024-05-30T10:01:30.000Z" title="发表于 2024-05-30 18:01:30">2024-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/04/Golang%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Golang复习笔记">Golang复习笔记</a><time datetime="2024-03-04T06:02:53.000Z" title="发表于 2024-03-04 14:02:53">2024-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zhaohui Wang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23ct3SpmblpGh2sl5A',
      clientSecret: '6a7a97e8ec634f5540e2964c1d00806f929aa6d7',
      repo: 'gitalk-comments',
      owner: 'chaos-warzh',
      admin: ['chaos-warzh'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e7092026d73bc00fb7dca3fd342fee43'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>