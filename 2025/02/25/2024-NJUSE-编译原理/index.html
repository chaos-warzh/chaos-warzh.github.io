<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2024-NJUSE-编译原理 | chaos-warzh's blog</title><meta name="author" content="Zhaohui Wang"><meta name="copyright" content="Zhaohui Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="课程内容参考 https:&#x2F;&#x2F;qingkaishi.github.io&#x2F;Compilers.html  intro   编译器的工作:   词法分析（Lexical Analysis） 语法分析（Syntax Analysis &#x2F; Parsing） 语义分析（Semantic Analysis） 翻译（Translating）产生IR 优化（Optimization） 代码生成（Code Gen">
<meta property="og:type" content="article">
<meta property="og:title" content="2024-NJUSE-编译原理">
<meta property="og:url" content="https://chaos-warzh.github.io/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="chaos-warzh&#39;s blog">
<meta property="og:description" content="课程内容参考 https:&#x2F;&#x2F;qingkaishi.github.io&#x2F;Compilers.html  intro   编译器的工作:   词法分析（Lexical Analysis） 语法分析（Syntax Analysis &#x2F; Parsing） 语义分析（Semantic Analysis） 翻译（Translating）产生IR 优化（Optimization） 代码生成（Code Gen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaos-warzh.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-02-25T06:50:49.000Z">
<meta property="article:modified_time" content="2025-03-04T02:09:49.935Z">
<meta property="article:author" content="Zhaohui Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaos-warzh.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2024-NJUSE-编译原理",
  "url": "https://chaos-warzh.github.io/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
  "image": "https://chaos-warzh.github.io/img/butterfly-icon.png",
  "datePublished": "2025-02-25T06:50:49.000Z",
  "dateModified": "2025-03-04T02:09:49.935Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zhaohui Wang",
      "url": "https://chaos-warzh.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaos-warzh.github.io/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2024-NJUSE-编译原理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script><script>MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  }
};</script><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">chaos-warzh's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">2024-NJUSE-编译原理</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">2024-NJUSE-编译原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-25T06:50:49.000Z" title="发表于 2025-02-25 14:50:49">2025-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-04T02:09:49.935Z" title="更新于 2025-03-04 10:09:49">2025-03-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>课程内容参考 <a target="_blank" rel="noopener" href="https://qingkaishi.github.io/Compilers.html">https://qingkaishi.github.io/Compilers.html</a></p>
</blockquote>
<h1>intro</h1>
<ol>
<li>
<p>编译器的工作:</p>
<p><img src="https://static-analysis.cuijiacai.com/assets/img/compiler.568f088c.jpg" alt="compiler"></p>
<ul>
<li><strong>词法分析（Lexical Analysis）</strong></li>
<li><strong>语法分析（Syntax Analysis / Parsing）</strong></li>
<li><strong>语义分析（Semantic Analysis）</strong></li>
<li><strong>翻译（Translating）产生IR</strong></li>
<li><strong>优化（Optimization）</strong></li>
<li><strong>代码生成（Code Generating）</strong></li>
</ul>
</li>
<li>
<p>中间表示, IR: Intermediate Representation</p>
<p>是编译器前端的输出, 即上图中<strong>Translator</strong>的输出.</p>
</li>
<li>
<p>为什么要有IR?</p>
<ol>
<li>统一编译成中间表示, 从而分离开前端和后端, 降低复杂度, 简化开发.</li>
<li>方便机器无关优化 (只要在IR上优化 / 分析即可)</li>
</ol>
</li>
<li>
<p>编译器的趟 (pass)</p>
<p>趟: 以文件输入输出单位的编译过程的个数, 每趟可以由一个或若干个步骤构成.</p>
</li>
<li>
<p><strong>字符串基本概念:</strong></p>
<ol>
<li>
<p>字母表, 一个有限的符号集合; 串–字母表中符号组成的一个有穷序列</p>
</li>
<li>
<p>语言, 给定字母表上一个任意可数的串的集合 例如: 语法正确的C语言</p>
</li>
<li>
<p>前缀 / 后缀 / 子串</p>
</li>
<li>
<p>真前缀 / 真后缀 / 真子串</p>
</li>
<li>
<p>串的运算:</p>
<ol>
<li>连接: 如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li>幂次: 如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mn>5</mn></msup><mo>=</mo><mi>s</mi><mi>s</mi><mi>s</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">s^5 = sssss</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span></li>
<li>闭包: 用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>符号</li>
</ol>
</li>
</ol>
</li>
<li>
<p>例子:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>Z</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>z</mi></mrow></mrow><annotation encoding="application/x-tex">L = {A, B, C, ..., Z, a, b, c, ..., z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></span> 表示字符集合</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">L^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> – 任意长度为4的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>中字符组成的串</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> – 任意长度的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>中字符组成的串</p>
</li>
<li>
<p>运算优先级 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> (闭包) &gt; 连接 &gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span></span></span></span> (或运算)</p>
</li>
</ol>
<h1>ANTLR 4</h1>
<ol>
<li>
<p>词法分析</p>
<p>输入  程序文本 / 字符串 s (CharStream)  + 词法单元 (token) 的规约</p>
<p>输出  词法单元流 (TokenStream)</p>
</li>
<li>
<p>词法分析器的3种设计方法:</p>
<ol>
<li>ANTLR等词法分析器生成工具</li>
<li>手写</li>
<li>自己实现词法分析生成器</li>
</ol>
</li>
<li>
<p>为什么手写?</p>
<p>性能 / 其他设计 / 相对简单 (语法分析器本课程不手写)</p>
</li>
<li>
<p>ANTLR</p>
<p>输入: 词法单元的规约 <code>.g4</code> (g 的意思是 Grammar; 4 的意思是 ANTLR4)</p>
<p>输出: 词法分析器 此处为一系列<code>.java</code>文件.</p>
</li>
<li>
<p>运行词法分析器, 输入为源程序, 得到输出即为词法单元(token)流.</p>
</li>
<li>
<p>学ANTLR, 推荐阅读官网, 而不是ANTLR4权威指南(较陈旧).</p>
</li>
<li>
<p>antlr 的<code>.g4</code>语言用于设计另一门语言, 因此<code>.g4</code>语言称为元语言</p>
</li>
<li>
<p><code>.g4</code>的一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">grammar SimpleExpr; // 必须和文件名同名</span><br><span class="line"></span><br><span class="line">prog : stat* EOF; // 一个program是由0到任意多个(*)语句(stat)构成的, EOF -- 表示文件结束</span><br><span class="line">stat : expr &#x27;;&#x27;  // 引号里面的;是正在设计的语言的一部分</span><br><span class="line">	 | ID &#x27;=&#x27; expr &#x27;;&#x27;  // 备选分支</span><br><span class="line">	 | &#x27;print&#x27; expr &#x27;;&#x27;</span><br><span class="line">	 ;</span><br><span class="line">// 加减乘除表达式, 这一行本身是一个大的规则, 其中的括号并列4种运算符叫子规则 </span><br><span class="line">expr : expr (&#x27;*&#x27; | &#x27;/&#x27;) expr // g4文件里, 写在前面的运算优先级高</span><br><span class="line">	 | expr (&#x27;+&#x27; | &#x27;-&#x27;) expr</span><br><span class="line">	 | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">	 | ID</span><br><span class="line">	 | INT</span><br><span class="line">	 ; // 如果没有特别配置, 那么g4文件就默认运算符左结合</span><br><span class="line"></span><br><span class="line">// 语法规则已写完, 以下是词法规则</span><br><span class="line">ID : (&#x27;_&#x27; | [a-zA-Z]) (&#x27;_&#x27; | [a-zA-Z0-9])* ; // 正则表达式, []表示字符集合</span><br><span class="line">INT : &#x27;0&#x27; | (&#x27;+&#x27; | &#x27;-&#x27;)? [1-9][0-9]*;</span><br><span class="line"></span><br><span class="line">SL_COMMENT: &#x27;//&#x27; .*? &#x27;\n&#x27; -&gt; skip ; // 这里如果不加?就是贪婪匹配, 加?就是非贪婪匹配(所有匹配的可能性中, 选择最短的那个匹配)</span><br><span class="line"></span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip; // 识别空白符, +表示一个或多个; -&gt; skip表示丢掉这一词法单元, 不进入语法分析</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>最前优先匹配</strong>原则, 当有多条规则可以匹配时, 选择最前面的优先匹配. (类似C语言的switch case)</p>
</li>
<li>
<p><strong><code>fragment</code>关键字</strong></p>
<p>不参与实际识别, 只是方便编写语法</p>
<p>例如: <code>fragment LETTER : [a-zA-Z]</code>, 这个 <code>LETTER</code> 并不会被识别成词法单元.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fragment LETTER : [a-zA-Z] ;</span><br><span class="line">fragment NUMBER : [0-9] ;</span><br><span class="line">fragment WORD : &#x27;_&#x27; | LETTER | NUMBER ; // 这是个常用做法</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>~</code> 表示<strong>除了…以外的字符</strong>:</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SL_COMMENT2 : &#x27;//&#x27; ~&#x27;\n&#x27;* &#x27;\n&#x27; -&gt; skip ;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法单元的规约要以<strong>小写字母</strong>开头, 词法单元以<strong>大写字母</strong>开头.</p>
</li>
<li>
<p><strong>最长优先匹配</strong>原则:</p>
<p><code>1.23</code> 为什么没有被匹配成 1和 .23呢?</p>
<p>因为匹配时尽可能地使得匹配程度最长. 即只要还能匹配就要继续匹配, 除非已经无法再匹配.</p>
</li>
<li>
<p>使用 <code>lexer grammar ...</code> 开头, 表示此文件是词法规则.</p>
</li>
<li></li>
</ol>
<h1>Lexer</h1>
<ol>
<li>
<p>正则表达式 regular expression (re) 是词法分析使用的工具.</p>
<p>但是只给出正则表达式, 计算机是怎么做到正则匹配的呢?</p>
<p>这就与<strong>自动机理论</strong>相关!</p>
</li>
<li>
<p>Automaton 自动机 (复数, Automata)</p>
<p>DFA, Deterministic Finite Automaton 确定性有穷状态自动机</p>
<p>NFA, Nondeterministic Finite Automaton 非确定性有穷状态自动机</p>
</li>
<li>
<p>一张重要的转换图</p>
<ul>
<li>
<p>DFA -&gt;DFA 的自环</p>
<ul>
<li>DFA最小化</li>
</ul>
</li>
<li>
<p>根据DFA, 可以得到RE (正则表达式)</p>
<ul>
<li>Kleene构造法</li>
</ul>
</li>
<li>
<p>RE -&gt; NFA</p>
<ul>
<li>Thompson构造法</li>
</ul>
</li>
</ul>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211282146730.png" alt=""></p>
</li>
<li>
<p>复习:</p>
<ol>
<li>
<p>(语言)</p>
<p>语言是给定字母表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 上一个<strong>任意的<em>可数</em>的串集合.</strong></p>
</li>
<li>
<p>(字母表)</p>
<p>字母表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 是一个有限的符号集合.</p>
</li>
<li>
<p>(串)</p>
<p>字母表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 上的串 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>) 是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 中<strong>符号构成的一个有穷序列</strong>. 空串: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ε</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">|ε| = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">ε</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
</li>
<li>
<p>连接运算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
</li>
<li>
<p>幂乘运算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">s^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ol>
</li>
<li>
<p>正则表达式的<strong>形式化定义</strong></p>
<p>给定字母表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 上的正则表达式由且仅由以下规则定义:</p>
<p>(1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">ϵ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> 是正则表达式;</p>
<p>(2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">∀a ∈ Σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正则表达式;</p>
<p>(3) 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 是正则表达式, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 是正则表达式;</p>
<p>(4) 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 是正则表达式, 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi mathvariant="normal">∣</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">r|s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">∣</span><span class="mord mathdefault">s</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">rs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mtext>∗</mtext></msup></mrow><annotation encoding="application/x-tex">r ^∗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 也是正则表达式.</p>
</li>
<li>
<p>运算优先级: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> (闭包) &gt; 连接 &gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span></span></span></span> (或运算)</p>
</li>
<li>
<p>每一个正则表达式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>都对应一个正则语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">L(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>.</p>
</li>
<li>
<p><strong>语言</strong>的运算 (注意区别于串的运算):</p>
<p>对于语言 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∪</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L \cup M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></p>
<ul>
<li>并运算</li>
</ul>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">LM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></p>
<ul>
<li>连接运算 (类比笛卡尔积)</li>
</ul>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的Kleen闭包 ; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的正闭包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">L^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>  闭包允许我们构造无穷集合.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>正则语言的运算规则:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">L(r|s) = L(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r)\cup L(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">L(rs) = L(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span></span></span></span>$r)L(s) $</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mtext>∗</mtext></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">L(r ^∗ ) = (L(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mopen">(</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mtext>∗</mtext></msup></mrow><annotation encoding="application/x-tex">r))^∗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>非确定性有穷自动机(Nondeterministic Finite Automaton) A 是一个五元组 A = (Σ, S, s~0~, δ, F):</p>
<p>(1) 字母表 Σ (ϵ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span></span></span> Σ)</p>
<p>(2) 有穷的状态集合 S</p>
<p>(3) 唯一的初始状态 s~0~ ∈ S</p>
<p>(4) 状态转移函数 δ  : S × (Σ ∪ {ϵ}) → 2 ^S^</p>
<p>(5) 接受状态集合 F ⊆ S (图中用双圈表示)</p>
</li>
<li>
<p>非确定性体现在: 1. 当前状态下, 在某一个字符的驱动下会跑到2个(或多个)不同状态 2. 允许使用ϵ的转移, 即没有任何字符驱动也允许转移到某一个指定状态.</p>
</li>
<li>
<p>若某一字符没有出边对应, 即指向空状态∅.</p>
</li>
<li>
<p>NP – 非确定性算法在多项式时间可解.</p>
</li>
<li>
<p>NF(有穷)A 是一类极其简单的计算装置, 它可以识别 (接受 / 拒绝) Σ上的字符串.</p>
</li>
<li>
<p><strong>接受 (Accept)</strong></p>
<p>(非确定性) 有穷自动机 A 接受字符串 x, 当且仅当存在一条从开始状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到某个<strong>接受状态</strong> f ∈ F、标号为 x 的路径.</p>
</li>
<li>
<p>进行转换时, 要注意自动机能接受的语言不能变化, 否则就不等价了.</p>
</li>
<li>
<p>确定性有穷自动机 A 是一个五元组 A = (Σ, S, s0, δ, F):</p>
<p>(1) 字母表 Σ (ϵ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span></span></span> Σ)</p>
<p>(2) 有穷的状态集合 S</p>
<p>(3) <strong>唯一</strong>的初始状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">s_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ∈ S</p>
<p>(4) 状态转移函数 δ : S × Σ → S</p>
<p>(5) 接受状态集合 F ⊆ S</p>
</li>
<li>
<p>一个字符只能转移到唯一确定的下一个状态; 不支持空串ϵ转移.</p>
</li>
<li>
<p>约定: 所有没有对应出边的字符默认指向一个&quot;死状态&quot;</p>
</li>
<li>
<p>对于DFA, 容易判断一个字符串是否被接受, 但是理解它所接受的语言的模式就比较困难.</p>
</li>
<li>
<p>NFA – 易于描述一个语言; DFA – 易于用来实现词法分析器</p>
</li>
<li>
<p>正则表达式转NFA (RE =&gt; NFA)</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">N(r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></p>
<p>要求: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">L(N(r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> =  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">L(r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>Thompson 构造法:</p>
<p>基本思想: 按结构归纳.</p>
<ul>
<li>ϵ 是正则表达式</li>
</ul>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291505728.png" alt=""></p>
<ul>
<li>a ∈ Σ 是正则表达式</li>
</ul>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291505372.png" alt=""></p>
<ul>
<li>如果 s, t 是正则表达式, 则 s|t 是正则表达式 (做法: 通过ϵ转移得到2分支) (如果初始状态不唯一, 就通过ϵ转移构造一个公共的出发点)</li>
</ul>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291507400.png" alt=""></p>
<ul>
<li>如果 s, t 是正则表达式, 则 st 是正则表达式 (把s的接受状态和t的初始状态叠起来)</li>
</ul>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291508066.png" alt=""></p>
<ul>
<li>如果 s 是正则表达式, 则 s ∗ 是正则表达式 (与以上类似)</li>
</ul>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291508063.png" alt=""></p>
</li>
<li>
<p>例子:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/202211291511497.png" alt=""></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">N(r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 的性质以及 Thompson 构造法复杂度分析</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">N(r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 的开始状态与接受状态均唯一</li>
<li>开始状态没有入边, 接受状态没有出边</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">N(r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 的状态数 |S| ≤ 2 × |r|  (|r| : r 中运算符与运算分量的总和)</li>
<li>每个状态最多有两个 ϵ-入边与两个 ϵ-出边</li>
<li>∀a ∈ Σ, 每个状态最多有一个 a-入边与一个 a-出边</li>
</ol>
</li>
<li>
<p><em><strong>期末必考 RE 转 NFA 画图</strong></em>.</p>
</li>
<li>
<p>NFA =&gt; DFA <strong>子集构造法</strong>(Subset / Powerset Construction) 思想: 用DFA模拟NFA</p>
</li>
<li>
<p>通过不断模拟走一步, 来合并所有等价的状态.</p>
</li>
<li>
<p>NFA -&gt; DFA</p>
<ol>
<li>寻找初始状态: start指向的状态 (n0) 以及经过 ϵ 转移能到达的状态. (0 1 2 4 7)</li>
<li>经过a转移之后能到达的状态集 ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>a</mtext></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{\text{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.934392em;vertical-align:-0.01100000000000001em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.923392em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">a</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000001em;"><span></span></span></span></span></span></span></span></span> 3 8 6 7 1 2 4)</li>
<li>按照状态集构造DFA 构造出来的DFA的每个状态是NFA所有状态的一个子集. (子集构造法)</li>
<li>哪里是接受状态? NFA的接受状态在DFA的哪个状态集中? =&gt; 所在的那些DFA状态集就是接受状态.</li>
</ol>
</li>
<li>
<p>ϵ-closure(s) ( ϵ-闭包 )  从状态s开始, 只通过 ϵ-转移 可达的状态集合.</p>
<p>若是从状态集合 T 开始, 只通过 ϵ-转移可达的状态集合 就是  ϵ-closure(T)</p>
<p>move(T, a) 从状态集合T开始, 通过a转移能够转移到的状态集合.</p>
</li>
<li>
<p>子集构造法 (N ⇒ D) 的原理: (<strong>形式化</strong>)</p>
<p>N : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">Σ</mi><mi>N</mi></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>N</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>N</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Σ_N , S_N , n_0, δ_N , F_N )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>D : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">Σ</mi><mi>D</mi></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>D</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>δ</mi><mi>D</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>D</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Σ_D, S_D, d_0, δ_D, F_D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mi>D</mi></msub><mo>=</mo><msub><mi mathvariant="normal">Σ</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">Σ_D = Σ_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>D</mi></msub><mo>⊆</mo><msup><mn>2</mn><msub><mi>S</mi><mi>N</mi></msub></msup><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><msub><mi>s</mi><mi>D</mi></msub><mo>∈</mo><msub><mi>S</mi><mi>D</mi></msub><mo>:</mo><msub><mi>s</mi><mi>D</mi></msub><mo>⊆</mo><msub><mi>S</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_D \subseteq 2 ^{S_N} (\forall s_D ∈ S_D : s_D \subseteq S_N )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">∀</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>初始状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>=</mo><mi>ϵ</mi><mrow><mo lspace="0em" rspace="0em">−</mo><mi mathvariant="normal">c</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">n</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_0 = ϵ\rm{-}closure(n_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϵ</span><span class="mord"><span class="mord"><span class="mord">−</span></span><span class="mord mathrm">c</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">u</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>转移函数 $\forall a ∈ Σ_D : δ_D(s_D, a) = ϵ-closure(move(s_D, a)) $</p>
<p>接受状态集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>D</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mi>D</mi></msub><mo>∈</mo><msub><mi>S</mi><mi>D</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∃</mi><mi>f</mi><mo>∈</mo><msub><mi>F</mi><mi>N</mi></msub><mi mathvariant="normal">.</mi><mi>f</mi><mo>∈</mo><msub><mi>s</mi><mi>D</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F_D = \{s_D \in S_D | \exists  f \in F_N . f \in s_D\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∃</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></p>
</li>
<li>
<p>子集构造法的复杂度分析:</p>
<p>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>N</mi></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">|S_N | = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>)</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>D</mi></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo><mo>∩</mo><mtext>Ω</mtext><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|S_D| = Θ(2^n ) = O(2^n ) ∩ Ω(2^n )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>子集构造法复杂度这么高? – 事实上, 对于任何算法, 最坏情况下, 复杂度也必须是Ω(2^n^ ).</p>
</li>
<li>
<p>闭包 (Closure): f-closure(T)</p>
<p>T =&gt; f(T) =&gt; f(f(T)) =&gt; …</p>
<p>直到找到x使得 f(x) = x (<strong>不动点</strong>)</p>
</li>
<li>
<p>DFA<strong>的最小化</strong>:</p>
<p><strong>核心思想: 等价的状态可以合并 (Hopcroft)</strong></p>
</li>
<li>
<p>等价定义</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∼</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s ∼ t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> ⇐⇒ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>s</mi><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>a</mi></mpadded></mover><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>t</mi><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>a</mi></mpadded></mover><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∼</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∀a ∈ Σ , ( (s  \xrightarrow{a} s&#x27; ) ∧ (t \xrightarrow{a} t&#x27; ) ) ⇒  (s&#x27; ∼ t&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.173392em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.923392em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.173392em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.923392em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≁</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s ≁ t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≁</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> ⇐⇒ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>s</mi><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>a</mi></mpadded></mover><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>t</mi><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>a</mi></mpadded></mover><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>≁</mo><msup><mi>t</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∃a ∈ Σ , (s \xrightarrow{a}s&#x27; ) ∧ (t \xrightarrow{a}t &#x27;) ∧ (s &#x27; ≁ t &#x27; )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∃</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.173392em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.923392em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.173392em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.923392em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≁</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p><strong>如果两个状态不等价, 那么一定有相同的输入使之转移到不同的状态!</strong></p>
</li>
<li>
<p>但是, 这是一个递归定义, 从哪里开始呢?</p>
</li>
<li>
<p>采用的思想就是: 划分, 而非合并!</p>
</li>
<li>
<p>接受状态与非接受状态必定不等价</p>
</li>
<li>
<p>DFA 最小化等价状态划分方法 Π = {F, S \ F} F为接受状态</p>
</li>
<li>
<p>直到再也无法划分为止 (不动点!) . 然后, 将同一等价类里的状态合并.</p>
</li>
<li>
<p>Hopcroft算法不适用于 NFA 最小化; NFA 最小化问题是 PSPACE-complete 的</p>
</li>
<li>
<p>Definition (可区分的 (Distinguishable); 等价的 (Equivalent)) 如果存在某个能区分状态 s 与 t 的字符串, 则称 s 与 t 是可区分的; 否则, 称 s 与 t 是等价的。</p>
</li>
<li>
<p>最前优先匹配, 最长优先匹配 -&gt; 匹配最长的先出现的</p>
</li>
<li>
<p>以上两个原则用于匹配由NFA产生的DFA的每个接受状态匹配的字符串格式 (正则表达式)</p>
</li>
<li>
<p>DFA不要模拟 (要消除) “死状态”, 否则会消耗输入流, 不是想要的情况. (严格定义的DFA是没有死状态的!)</p>
</li>
<li>
<p>利用DFA生成词法分析器, 接受输入, 若为接受状态则是识别成功, 否则回溯至最近的一次接受状态. 若没有经过任何接受状态, 报错. (不合法)</p>
</li>
<li>
<p>特定于词法分析器的DFA最小化方法: 初始划分就考虑不同的词法单元, 如果是匹配的不同的正则表达式, 那么他们应当先天地被分成不同的等价状态.</p>
</li>
<li>
<p>DFA (确定性有限自动机) =&gt; RE (正则表达式)</p>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>
<h1>Lexer Analysis</h1>
<ol>
<li>
<p>NFA(Nondeterministic Finite Automaton, 非确定性有限自动机) DFA(Deterministic Finite Automaton, 确定性有限自动机) 的区别和转换.</p>
</li>
<li>
<p>NFA的状态转换中可以有空串, NFA可以转换成DFA</p>
</li>
<li>
<p>DFA可以进行简化, 得到的就是最小DFA</p>
</li>
<li></li>
<li>
<p>语法分析: 符号流  -(语法分析)-&gt;  语法树</p>
</li>
<li>
<p>语法分析器的功能: 1. 验证输入源程序的合法性 2. 若发现了语法错误, 要能够报错, 进行错误恢复 (其实静态报错编译器报的差的话你很难定位到)</p>
</li>
<li>
<p>语法分析:</p>
<p>自顶向下: 通常处理<strong>LL</strong>文法 (从左到右扫描字符)</p>
<p>自底向上: 通常处理<strong>LR</strong>文法</p>
</li>
<li>
<p>代表性文法</p>
<p>元符号: <code>-&gt;</code>表示推出 , <code>|</code>表示或,</p>
<p>产生式 (产生式头) -&gt; (产生式体)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F -&gt; (E) | id // 这个产生式体的第一个符号是 ( , 而不是其他的. </span><br></pre></td></tr></table></figure>
<p><strong>左括号</strong>是一个东西! 不要忽略任何括号!</p>
</li>
<li>
<p>CFG (Context Free Grammar) 上下文无关文法</p>
</li>
<li>
<p>一个上下文无关文法 (CFG) 由以下几个部分组成:</p>
<ul>
<li>终结符号 (组成串的基本符号, 与 &quot;词法单元名字&quot;同义)</li>
<li>非终结符号 (语法变量, 表示特定串的集合; 给出了语言的层次结构, 这种层次结构是语法分析和翻译的关键)</li>
<li>一个开始符号 (某个特定的非终结符号, 其表示的串集合是这个文法生成的语言)</li>
<li>一组产生式 (描述将终结符号和非终结符号组合成串的方式)</li>
</ul>
</li>
<li>
<p>上下文: 前后已经推导出的部分 (前面做过的行为 – 上文; 后面做的行为 – 下文)</p>
</li>
<li>
<p>推导: =&gt;; 经过0+步推导, =^<em>^=&gt; ; 经过1+步推导, =^+^=&gt; ; 最左(右)推导 ( 总是选择句型最左(右)的非终结符号 )  =&gt; 上面是</em>, 下面是lm / rm</p>
</li>
<li>
<p>语法分析的任务是: 接受一个终结符号串作为输入, 找出从文法的开始符号推导出这个串的方式.</p>
</li>
<li>
<p>语言的二义性 : 需要严格规定语法</p>
</li>
<li>
<p>上下文产生式 用于定义语法. 语言是由文法开始符号出发, 能够推导得到的所有句子的集合.</p>
</li>
<li>
<p>上下文无关文法的表达能力 &gt; 正则表达式 (每一个正则语言 都是一个 上下文无关语言, 反之不成立)</p>
</li>
<li>
<p>上下文无关文法足够用来描述语法吗? 不! 例如: 标识符必须先声明后使用. (无法通过上下文<strong>无关</strong>文法描述)</p>
</li>
<li>
<p>文法的设计 – <strong>1. 消除二义性 2. 消除左递归 3. 提取左公因子</strong></p>
</li>
<li>
<p>左递归带来二义性, 务必要消除!</p>
</li>
<li>
<p>立即消除左递归的<em><strong>实例</strong></em> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; Aα | β </span><br><span class="line">转换成:</span><br><span class="line">A -&gt; βA&#x27;</span><br><span class="line">A&#x27; -&gt; αA&#x27; | ε</span><br></pre></td></tr></table></figure>
<p>一定要有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> !</p>
</li>
<li>
<p>消除立即左递归的方法不能消除因为2步或多步推导而产生的左递归.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; Aa | b, A -&gt; Ac | Sd | ε</span><br><span class="line">则: S =&gt; Aa =&gt; Sda</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>消除算法: 给非终结符排序, 若发现后面的符号推出了前面的, 则代入当前式, 若替换成直接左递归, 再消除.</p>
</li>
<li>
<p>注意, 此处不是推导, 而是<strong>文法代入</strong>, 你不应少代或代多次 (注意, 这在<strong>推导</strong>里是允许的, 可是我们是在<strong>代入</strong>!)</p>
</li>
<li>
<p>提取左公因子: 要提取最长前缀.</p>
</li>
<li>
<p><strong>自顶向下语法分析</strong>: 为输入串构造语法分析树. 也可以是看作一种寻找输入串的最左推导的过程.</p>
<p>(必考: 1.预测分析法  2. 优先级算法)</p>
</li>
<li>
<p>递归下降分析框架:</p>
<p>依次选择某一个产生式, 对于之, 每个非终结符处理一下, 终结符处理一下, 错误处理.</p>
</li>
<li>
<p>也有可能产生式匹配错了 (应该匹配另一个) -&gt; 回溯.</p>
</li>
<li>
<p>回溯 / 穷试 是一个笨办法.</p>
</li>
<li>
<p>预测分析法简介: 每一步都选择正确的产生式 (通常每一次向前看一个符号. )</p>
</li>
<li>
<p>FIRST和FOLLOW :</p>
<p>FIRST(α)  – 可以从α推导得到的串的<strong>首符号</strong>的集合. (FIRST(α) 就是 α 这个串的一部分)</p>
<p>FOLLOW(A) – 可能在某些句型中紧跟在A右边的<strong>终结符号</strong>的集合. ( FOLLOW(A) 不一定是当前串的一部分 )</p>
</li>
<li>
<p>FIRST函数的意义:</p>
<p>如果两个A产生式 A -&gt; α | β , 其中 FIRST(α) 和 FIRST(β) 是不相交的集合.</p>
<p>下一个输入符号是a, 若a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> FIRST(α) 则选择 A -&gt;α , 反之选择 另一个.</p>
</li>
<li>
<p>怎么计算First?</p>
<ul>
<li>
<p>如果X是终结符, 那么FIRST(X) = {X}</p>
</li>
<li>
<p>如果X是非终结符, 且有规则 X -&gt; a… 则 a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> FIRST(X) 如果 X -&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> FIRST(X)</p>
</li>
<li>
<p>对于规则 X -&gt; Y1 Y2 …</p>
<p>把 FIRST(Y1) 里的所有非<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> 符号添加进 FIRST(X), 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>在 FIRST(Y1) 中, 把 FIRST(Y2) 中的非<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> 符号添加进 FIRST(X) 中. … 以此类推,   一旦前面有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> , 就往后看, 直到无<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> 或者结尾 -&gt; 就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> .</p>
</li>
</ul>
</li>
<li>
<p>对于非终结符 A, FOLLOW(A) 定义为可能在某些句型中紧跟在A右边的终结符的集合. 例如: S =*=&gt; αAaβ, 终结符号a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> Follow(A)</p>
</li>
<li>
<p>若A是某些句型的最右符号, 那么 $ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> Follow(A). $是结束标记</p>
</li>
<li>
<p>FOLLOW的作用是帮助我们选择恰当的产生式</p>
</li>
<li>
<p>FOLLOW计算: 计算各个非终结符A的FOLLOW集合的方法就是 <strong>不断应用以下规则</strong>:</p>
<ul>
<li>将 $ 放入 FOLLOW(S), S 是开始符号, 而$是输入串的结束标记</li>
<li>如果存在产生式 A -&gt; αBβ, 那么First(β)中除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>之外的所有符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> FOLLOW(B)</li>
<li>如果存在一个产生式 A -&gt; αB, 或存在产生式 A -&gt; αBβ 且 <strong>First(β)包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></strong> ,那么 FOLLOW(A) 的所有符号都在 FOLLOW(B)  中.</li>
</ul>
</li>
<li>
<p>==<strong>考题1</strong>==: 对于给定的文法 –</p>
<ol>
<li>改造二义性 | 左递归 | 左公因子 (<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> 不能丢</strong> 各种需要epsilon的时候都不能丢)</li>
<li>得到一个新的文法, 计算它的First和Follow集</li>
</ol>
</li>
<li>
<p>这就得到了 <strong>LL(1) 文法</strong>. L – 从左往右扫描; L – 产生最左推导; k = 1表示往前看1个.</p>
</li>
<li>
<p><strong>LR(0)</strong> (自底向上) (重要知识点!)</p>
</li>
<li>
<p>LR分析表 (s-shift, r-reduce)</p>
</li>
<li>
<p>LR分析 – 有左递归不影响</p>
</li>
<li>
<p>预测分析中的错误恢复. 错误恢复 – 当预测分析器能够进行恢复处理后继续语法分析过程, 以便在一次分析中找到更多的语法错误. 但是有可能恢复不成功, 之后找到的语法错误有可能是假的.</p>
</li>
<li>
<p>2种错误恢复方法: 恐慌模式 (忽略掉某些符号, 通过识别同步符号如if, while来实现) ; 短语层次的恢复 (相当于把错的符号改变处理)</p>
</li>
</ol>
<h1>parser-antlr</h1>
<ol>
<li>
<p>目标: 1. 分析语法结构 2.打印语法分析树</p>
</li>
<li>
<p>语法规则:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">prog : (varDecl | functionDecl)* EOF</span><br><span class="line"></span><br><span class="line">varDecl : type ID (&#x27;=&#x27; expr)? &#x27;;&#x27; ;</span><br><span class="line"></span><br><span class="line">type : &#x27;int&#x27; | &#x27;double&#x27; | &#x27;void&#x27; ;</span><br><span class="line"></span><br><span class="line">functionDecl : type ID &#x27;(&#x27; formalParameters?&#x27;)&#x27; block;</span><br><span class="line"></span><br><span class="line">formalParameters : formalParameter (&#x27;,&#x27; formalParameter)* ;</span><br><span class="line"></span><br><span class="line">block : &#x27;&#123;&#x27; stat* &#x27;&#125;&#x27; ;</span><br><span class="line"></span><br><span class="line">stat : block</span><br><span class="line">	 | varDecl</span><br><span class="line">	 | &#x27;if&#x27; expr &#x27;then&#x27; stat (&#x27;else&#x27; stat)?</span><br><span class="line">	 | &#x27;return&#x27; expr? &#x27;;&#x27;</span><br><span class="line">	 | expr &#x27;=&#x27; expr &#x27;;&#x27;</span><br><span class="line">     | expr &#x27;;&#x27;</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">expr : ID &#x27;(&#x27; exprList? &#x27;)&#x27;</span><br><span class="line">	 | expr &#x27;[&#x27; expr &#x27;]&#x27;</span><br><span class="line">	 | &#x27;-&#x27; expr</span><br><span class="line">	 | &#x27;!&#x27; expr</span><br><span class="line">	 | expr ^ expr</span><br><span class="line">	 | expr (&#x27;*&#x27; | &#x27;/&#x27;) expr</span><br><span class="line">	 | expr (&#x27;+&#x27; | &#x27;-&#x27;) expr</span><br><span class="line">	 | expr (&#x27;==&#x27; | &#x27;!=&#x27;) expr</span><br><span class="line">	 | &quot;(&quot; expr &quot;)&quot;</span><br><span class="line">	 | ID</span><br><span class="line">	 | INT</span><br><span class="line">	 ;</span><br><span class="line">	 </span><br><span class="line">exprList : expr (&#x27;,&#x27; expr)* ;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二义性问题:</p>
<ol>
<li>悬空的else 1.改写成无二义性的 2. 利用最前优先匹配原则.</li>
<li>二元运算符结合性带来的二义性. 加标注 &lt;assoc = right&gt;</li>
<li>运算符优先级带来的二义性 1. 利用最前优先匹配原则 2. 利用 左递归 (左结合) 文法</li>
</ol>
</li>
<li>
<p>antlr4生成的文件:</p>
<p><code>ParseTreeWalker</code> 负责以DFS方式自动遍历语法树. 每进入一个节点, 触发EnterXXX事件, 每离开一个节点, 触发ExitXXX事件.</p>
</li>
<li>
<p><strong>antlr4允许给每一个备选分支加标签, 如: <code>#FuncCall</code> 也可以给每一个符号 (终结或非终结) 起别名.</strong></p>
</li>
</ol>
<h1>parser: context-free</h1>
<ol>
<li>
<p>冒号左边 head头部; 冒号右边 规则体 body</p>
</li>
<li>
<p>产生式 production (可以把左边的头部替换为右边的body)</p>
</li>
<li>
<p>左边的head是非终结符; 而body可能是非终结符可能是终结符.</p>
</li>
<li>
<p>这种文法, 叫作上下文无关文法. (表达能力比正则表达式更强)</p>
</li>
<li>
<p>上下文无关文法 G 是一个四元组 G = (T, N, S, P):</p>
<p>▶ T 是终结符号 (Terminal) 集合, 对应于词法分析器产生的词法单元</p>
<p>▶ N 是非终结符号 (Non-terminal) 集合</p>
<p>▶ S 是开始 (Start) 符号 (S ∈ N 且唯一)</p>
<p>▶ P 是产生式 (Production) 集合 A ∈ N → α ∈ (T ∪ N)^*^</p>
<p>头部/左部 (Head) A: <strong>单个</strong>非终结符</p>
<p>体部/右部 (Body) α: 终结符与非终结符构成的串, 也可以是空串 ϵ</p>
</li>
<li>
<p>扩展BNF范式 – 在原来的上下文无关文法中扩展了 * ? + 符号</p>
</li>
<li>
<p>一个非终结符展开成什么样取决于其上下文(左边右边的符号长什么样) -&gt; 上下文相关</p>
</li>
<li>
<p>推导: 将某个产生式的左边替换成它的右边</p>
</li>
<li>
<p>E ⇒ −E : 经过一步推导得出</p>
<p>E =^+^⇒ −(id + E) : 经过一步或多步推导得出</p>
<p>E =^*^⇒ −(id + E) : 经过零步或多步推导得出</p>
</li>
<li>
<p>Leftmost (最左) Derivation : 每一次选最左边的非终结符进行推导</p>
<p>Rightmost (最右) Derivation : 每一次选最右边的非终结符进行推导</p>
</li>
<li>
<p>句型: 经过任意步推导, 如果 S =^∗^⇒ α, 且 α ∈ (T ∪ N)^∗^ , 则称 α 是文法 G 的一个句型</p>
</li>
<li>
<p>句子: 如果 S =^∗^⇒ w, 且 w ∈ T ∗ , 则称 w 是文法 G 的一个<strong>句子</strong> (都是终结符)</p>
</li>
<li>
<p>(文法 G 生成的语言 L(G))</p>
<p>文法 G 的语言 L(G) 是它能推导出的所有句子构成的集合。 L(G) = {w | S =^∗^⇒ w}</p>
</li>
<li>
<p>关于文法G的2个基本问题: 1. 成员问题(给定字符串, 是否在G的语言里) 2. L(G)是什么</p>
</li>
<li>
<p>前面n个b, 中间任意个a, 后面2n个b</p>
<p>S → bSbb | A</p>
<p>A → aA | ϵ</p>
</li>
<li>
<p>a个数和b个数相等:</p>
<p>V → aV bV | bV aV | ϵ</p>
<p>V → V V | aV b | bV a | ϵ</p>
</li>
<li>
<p>a个数和b个数不等:</p>
<p>S → T | U</p>
<p>T → V aT | V aV</p>
<p>U → V bU | V bV</p>
<p>V → aV bV | bV aV | ϵ</p>
</li>
<li>
<p>证明: 上下文无关文法的表达能力严格大于正则表达式 (正则表达式 &lt; 上下文无关文法 &lt; 上下文相关文法 &lt; 递归可枚举)</p>
</li>
<li>
<p>证明1: 大于</p>
<p>每个正则表达式r对应的语言L®都可以使用上下文无关文法来描述.  构造性证明, 每一个状态-&gt; 头部, 状态转移-&gt; 加上一个符号作为右端体部.</p>
</li>
<li>
<p>证明2: 严格大于</p>
<p>L = {a^n^b^n^ | n&gt;=0 } 无法用正则表达式描述. 假设存在有限状态自动机 D® st. L(D®)=L, 设其状态数为 k &gt;= 1, 考虑输入a^m^ (m &gt;= k), 因为m足够大, 所以自动机必须接受这些输入(以防后面有b), 那么就一定会有j次(j &gt;= 1)一直在同一个状态打转, 那么这个打转的状态就可以用于构造a和b长度不等的同样会被接受的串.</p>
</li>
<li>
<p>Pumping Lemma for Regular Language (中间一定会有repeat若干次. )</p>
<p>If L is a regular language, then there exists a number p ≥ 1 (pumping length) such that any string s in L of length ≥ p can be divided into three pieces, s = xyz, satisfying the following conditions:</p>
<p>(i) |y| ≥ 1</p>
<p>(ii) |xy| ≤ p</p>
<p>(iii) ∀i ≥ 0 : xy^i^z ∈ L</p>
</li>
<li>
<p>例如 : 完全平方数个1的语言不是正则语言.</p>
</li>
<li></li>
</ol>
<h1>parser - ll</h1>
<ol>
<li>
<p>简单的: ll</p>
<p>困难的: lr (自底向上)</p>
</li>
<li>
<p>自顶向下的,</p>
<p>递归下降的, *(采用了递归算法, 也可以改成非递归的)</p>
<p>基于预测分析表的, *(本节的重点)</p>
<p>适用于LL(1) 文法的 *(局限性)</p>
<p>LL(1)语法分析器</p>
</li>
<li>
<p>自顶向下构建语法分析树:</p>
<p>根节点是文法的起始符号 S;</p>
<p>每个中间节点表示对某个非终结符应用某个产生式进行推导 (Q : 选择哪个非终结符, 以及选择哪个产生式)</p>
<p>叶节点是词法单元流 w$ 仅包含终结符号与特殊的文件结束符 $ (EOF)</p>
</li>
<li>
<p>Q : 选择哪个非终结符, 以及选择哪个产生式?</p>
<p>在推导的每一步, L<strong>L</strong>(1) 总是选择最左边的非终结符进行展开</p>
<p><strong>L</strong>L(1): <strong>从左向右</strong>读入词法单元</p>
</li>
<li>
<p>预测分析表</p>
<p><img src="https://box.nju.edu.cn/f/0ea8de3155ca430eba8b/?dl=1" alt=""></p>
</li>
<li>
<p>使用预测分析表确定产生式: 预测分析表 指明了每个非终结符在面对不同的词法单元或文件结束符时, 该选择哪个产生式 (按编号进行索引) 或者报错 (空单元格)</p>
</li>
<li>
<p>Definition: <strong>(LL(1) 文法)</strong></p>
<p>如果文法 G 的预测分析表是<strong>无冲突</strong>的, 则 G 是 LL(1) 文法。</p>
<p><strong>无冲突</strong>: 每个单元格里只有一个产生式 (编号) (事实上, LL(1)限制了多个规则不能有一样的开头, 这种局限性是很大的)</p>
</li>
<li>
<p>有些非LL(1)的文法需要往前看<strong>任意长</strong>个词法单元, 这种文法的处理会在下节课讲解.</p>
</li>
<li>
<p>如何计算给定文法 G 的预测分析表? (只要用First 和 Follow 2个集合)</p>
<ul>
<li>
<p>First(α) 是可从 α 推导得到的句型的<strong>首终结符号</strong>的集合</p>
<ul>
<li>
<p>Definition: (<strong>First(α) 集合</strong>)</p>
<p>对于任意的 (产生式的右部) α ∈ (N ∪ T) ^∗^ :                   //  N - 非终结符 ; T - 终结符</p>
<p>First(α) = { t ∈ T ∪ {ϵ} | α =^∗^=&gt; tβ ∨ α  =^∗^=&gt; ϵ }.     //  不仅仅要把所有可能推到的T加入集合, 还要把可能推到的ϵ 加入集合.</p>
</li>
<li>
<p>考虑非终结符 A 的所有产生式 A → α1, A → α2, . . . , A → αm, 如果它们对应的 First(α~i~) 集合互不相交, 则只需查看当前输入词法单元, 即可确定选择哪个产生式 (或报错).</p>
</li>
</ul>
</li>
<li>
<p>Follow(A) 是可能在某些句型中<strong>紧跟在 A 右边的终结符</strong>的集合</p>
<ul>
<li>
<p>Definition: (<strong>Follow(A) 集合</strong>)</p>
<p>对于任意的 (产生式的左部) 非终结符 A ∈ N :</p>
<p>Follow(A) = { t ∈ T ∪ {$} | ∃s. S  =^∗^=&gt;  s ≜ βA<strong>t</strong>γ }.     // 如果有一个句型长成这样: βA<strong>t</strong>γ , 那么相当于A后面可以跟一个终结符t.</p>
</li>
<li>
<p>考虑产生式 A → α, 如果从 α 可能推导出空串 (α =^∗^=&gt; ϵ), 则只有当<strong>当前词法单元 t ∈ Follow(A)</strong>, 才可以选择该产生式 (即<em>此时</em> (A后面出现了t) 允许将 A → α =^∗^=&gt; ϵ  这条产生式放入预测表)</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>具体怎么计算First和Follow集合呢?</p>
</li>
<li>
<p>先计算每个符号 X 的 First(X) 集合 :</p>
<p>procedure first(X)</p>
<p>​	if X ∈ T then 											▷ 规则 1: X 是终结符</p>
<p>​		First(X) = X</p>
<p>​	for X → Y1Y2 . . . Yk do 							▷ 规则 2: X 是非终结符</p>
<p>​		First(X) ← First(X) ∪ {First(Y1) \ {ϵ}}</p>
<p>​		for i ← 2 to k do</p>
<p>​			if ϵ ∈ L(Y1 . . . Yi−1) then                 // L 表示串Y1…Yi-1构成的语言 (所有可能的串的集合)</p>
<p>​				First(X) ← First(X) ∪ {First(Yi) \ {ϵ}}</p>
<p>​		if ϵ ∈ L(Y1 . . . Yk) then					 	▷ 规则 3: X 可推导出空串</p>
<p>​			First(X) ← First(X) ∪ {ϵ}</p>
<p>不断应用上面的规则, 直到每个 First(X) 都不再变化 (不动点!!!)</p>
</li>
<li>
<p>再计算每个<strong>符号串 α</strong> 的 First(α) 集合</p>
<p>对于 α = Xβ</p>
<p>First(α)  =</p>
<p>▶First(X) 									 ϵ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span></span></span> L(X)</p>
<p>▶(First(X) \ {ϵ}) ∪ First(β) 	 	ϵ ∈ L(X)</p>
<p>最后, 如果 ϵ ∈ L(α), 则将 ϵ 加入 First(α)。</p>
</li>
<li>
<p>为每个非终结符 X 计算 Follow(X) 集合 :</p>
<p>procedure follow(X)</p>
<p>​	for X 是开始符号 do								 ▷ 规则 1: X 是开始符号  (相当于X是整个程序)</p>
<p>​		Follow(X) ← Follow(X) ∪ {$}</p>
<p>// 以下都要从产生式右侧找X</p>
<p>​	for A → αX do											▷ 规则 2: X 是某产生式右部的最后一个符号</p>
<p>​		Follow(X) ← Follow(X) ∪ Follow(A)</p>
<p>​	for A → αXβ do										  ▷ 规则 3: X 是某产生式右部中间的一个符号</p>
<p>​		Follow(X) ← Follow(X) ∪ (<strong>First</strong>(β) \ {ϵ})</p>
<p>​		if ϵ ∈ <strong>First</strong>(β) then</p>
<p>​			Follow(X) ← Follow(X) ∪ Follow(A)</p>
<p>不断应用上面的规则, 直到每个 Follow(X) 都不再变化 (不动点!!!)</p>
</li>
<li>
<p>如何根据First 与 Follow 集合计算给定文法 G 的预测分析表?</p>
<p>对应每条产生式 A → α 与终结符 t, 如果</p>
<p>t ∈ First(α)										   (1)</p>
<p>α =∗⇒ ϵ ∧ t ∈ Follow(A) 					(2)</p>
<p>则在表格 [A,t] 中填入 A → α (编号)</p>
</li>
<li>
<p>Definition (<strong>LL(1) 文法</strong>) :</p>
<p>如果文法 G 的预测分析表是无冲突的, 则 G 是 LL(1) 文法。</p>
<p>(没有好的判断LL(1)文法方法, 必须要从头算一遍分析表)</p>
</li>
<li>
<p><strong>计算FIRST和FOLLOW每年必考.</strong></p>
</li>
<li>
<p>LL(1) 语法分析器</p>
<p>L : 从左向右 (left-to-right) 扫描输入</p>
<p>L : 构建最左 (leftmost) 推导</p>
<p>1 : 只需向前看一个输入符号便可确定使用哪条产生式</p>
</li>
<li>
<p>文法表达能力: LL(0) &lt; LL(1) &lt; LL(k) &lt; LR(k)   (严格包含关系, 即能分析的文法右边比左边)</p>
</li>
<li>
<p>如果不想写递归, 想写成迭代? – 需要用栈模拟: (核心还是预测分析表)</p>
</li>
<li>
<p><strong>非递归的 (栈) , 基于预测分析表</strong>的实现方法:</p>
<p>产生式: <strong>S -&gt; (S + F)</strong></p>
<p><em>转换成栈:</em></p>
<p>栈底 [$ , <s>S</s> , ), F, +, S, (</p>
<p>用栈模拟, 相当于把S弹出, 把S的右部压栈, 注意因为是栈结构</p>
<p>所以先压右括号 (<strong>从右往左压</strong>)</p>
<p>获得了一个栈, 就可以利用栈做语法分析了, 如果栈顶是一个终结符, 那么就弹出, 如果栈顶是一个非终结符, 就递归调用非终结符, 把产生式右部压入 (相当于语法树上此节点的下边缘).</p>
</li>
<li>
<p>但是, 实际上我们更喜欢递归下降的方式, 但栈的语言的描述你要能看懂.</p>
</li>
<li></li>
</ol>
<h1>parser - Adaptive LL(*)</h1>
<ol>
<li>
<p>由antlr作者提出</p>
</li>
<li>
<p>之前学习的LL(1) 无法处理的文法 1. 左递归 2. 左公因子</p>
</li>
<li>
<p>当然你可改写文法, 消除左递归, 提取左公因子, 但是这可能会冗长, all*给出了另一种解决方案.</p>
</li>
<li>
<p>(1) ANTLR 4 自动将类似 expr 的左递归规则重写成非左递归形式</p>
<p>(2) ANTLR 4 提供优秀的错误报告功能和复杂的错误恢复机制</p>
<p>(3) ANTLR 4 几乎能处理任何文法 (二义性文法✓ 间接左递归✗) (上下文相关也可以处理)</p>
<p>间接左递归, 自己的备选分支本身无左递归, 推导后出现左递归.</p>
<p>(antlr设计上, 对于间接左递归会报错)</p>
</li>
<li>
<p>antlr如何<strong>处理左递归+优先级</strong>? (优先级上升算法)</p>
</li>
<li>
<p>蓝色框中是非递归部分, 红色框中是<strong>递归部分</strong></p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220121957805.webp" alt=""></p>
<p>为什么 E: (INT | ID) {(’*’ | +) E}*</p>
<p>要有末尾的* ? 难道直接有递归不行吗?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def E(p):                   // p : 优先级</span><br><span class="line">	match(INT | ID) </span><br><span class="line">	</span><br><span class="line">	while (!EOF) &#123;</span><br><span class="line">		if (4 &gt;= p)</span><br><span class="line">			match(*): E(5)  // 匹配到*, 调用E(5)</span><br><span class="line">        elif (3 &gt;= p)</span><br><span class="line">        	match(+): E(4)  // 匹配到+, 调用E(4)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>expr推导式编写后, 赋予优先级 * 为 4; + 为 3; 后面2个终结符无所谓, 赋值为2和1.</p>
</li>
<li>
<p>例子: 1 + 2 + 3</p>
<p>start时, p=0, 所以先调用 E(0), 匹配到 ‘1’ ‘+’, 然后调用E(4), 由于优先级为4, 过大, 所以无法在 E(4) 层匹配’2’后再匹配 ‘+’ (这里关键在于优先级上升了一级, <em><strong>==优先级上升算法==</strong></em>), 退回至E(0), 开启新一轮while循环, match到 ‘+’, 这保证了 ‘+’ 运算符的左结合性!</p>
</li>
<li>
<p>类似地, 有例子 1 + 2 * 3 , 由于允许在 E(4) 里匹配乘号. 所以会保证乘号的优先级高于加号.</p>
</li>
<li>
<p><strong>根本问题:</strong> 究竟是在 expr 的当前调用中匹配下一个运算符, 还是让 expr 的<strong>调用者</strong> (上一层) 匹配下一个运算符。</p>
</li>
<li>
<p>更多例子:</p>
<ol>
<li>
<p>有 (expr) 的推导体, 因为(不是左递归的, 所以就是基础情况, 直接赋优先级为3, 然后递归调用E(0)</p>
</li>
<li>
<p>有右结合的运算符 (如 乘方 ^) 很简单, 只要让匹配右结合的运算符之后<strong>优先级不变</strong>即可实现右结合.</p>
</li>
<li>
<p>结论: 左结合的运算符<strong>优先级上升</strong>, 右结合的运算符<strong>优先级不变</strong></p>
</li>
<li>
<p>一元的运算符: 一元的运算符优先级应该最高 (高于二元的), 其中前缀运算符应该赋一个比后缀运算符更高的优先级</p>
<p>左结合 – 即前缀运算符, 优先级上升一级; 右结合 – 即后缀运算符, 后面没有expr了, 所以不用再加任何东西</p>
</li>
</ol>
</li>
<li>
<p>all(*)是怎么工作的? (the power of dynamic analysis)</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220133946836.webp" alt=""></p>
<p>即往前看任意多的字符也无法判断备选分支.</p>
<p>bc v.s. bd 怎么区分?</p>
<p>动态分析 而非 静态分析</p>
<p>静态分析角度, 需要考虑所有可能的最坏情况 – 不停机 (而allstar根据当前输入 Adaptive 地 做选择和决定, 这样就强大了很多)</p>
</li>
<li>
<p>增强的转移网络:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134014892.webp" alt=""></p>
</li>
<li>
<p>Adaptive LL(*) 算法:</p>
<p><strong>Incrementally and dynamically</strong> build up a <strong>lookahead DFA</strong> that <strong><u>map lookahead phrases to predicated productions</u></strong>.</p>
<p>lookahead phrases 向前看的短语 (可以向前看任意长的前缀)  --映射到–&gt; 一个specific的产生式</p>
<p>通过构建<em><strong>lookahead DFA</strong></em>, 不断接受字符, 最终转移到一个能确定备选分支的状态.</p>
<p>(pA, 1, p1) =&gt; (当前状态, 所探索的备选分支, 调用栈)</p>
<p>可以认为会出现图调用图, 然后, 就会有调用栈 (表示caller是谁).</p>
<p>这个调用栈可能会是指数级的, 所以antlr精心设计了处理这样的问题的数据结构.</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134205766.webp" alt=""></p>
</li>
<li>
<p>增量式, 动态地构建这样的lookahead DFA:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220134749427.webp" alt=""></p>
<p>在每一个需要做决策的点, 同时开启多个小的parser, 并行地探索各个备选分支.</p>
<p>所有的小的语法分析器并行地往前走, 如果不匹配, parser就死了; 如果走到了EOF, 就成功了; 如果多个分支交叉 / 都走到EOF =&gt; 有歧义, antlr会选第一个分支作为歧义消解策略.</p>
</li>
<li>
<p>各种文法的范围比较:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220094542795.webp" alt=""></p>
</li>
<li>
<p>更详细请见antlr的paper. (可能有点难读…)</p>
</li>
</ol>
<h1>parser-lr(0)</h1>
<ol>
<li>
<p>回顾: <strong>LL(1)</strong> 语法分析器</p>
<p>自顶向下的, 递归下降的, 基于预测分析表的,</p>
<p>适用于LL(1) 文法的</p>
<p>LL(1)语法分析器</p>
</li>
<li>
<p>核心 – 预测分析表的构建</p>
</li>
<li>
<p>LL(k)的弱点, 在仅看到右部的前k个词法单元时就必须预测要使用哪条产生式.</p>
</li>
<li>
<p>LR(k)的优点, 看到某个产生式的整个右部对应的词法单元后再决定.</p>
</li>
<li>
<p>LR语法分析 – 从左向右扫描输入的, 反向 (Reversed) / 最右 (Rightmost) 推导的 语法分析</p>
</li>
<li>
<p>自底向上的,</p>
<p>不断<strong>归约</strong>的,</p>
<p>基于<strong>句柄识别自动机</strong>的, (句柄 <strong>Handle</strong>, LR语法分析的关键)</p>
<p>适用于 LR 文法的,</p>
<p>LR语法分析器</p>
</li>
<li>
<p>自底 (叶节点) 向上 (根节点) – 不断归约; 自顶向下 – 不断推导</p>
</li>
<li>
<p>LR分析 – 找到唯一的归约, 是LL分析的逆过程</p>
</li>
<li>
<p>为什么是最右推导? – 因为<strong>归约时的顺序是自左向右的, 推导的顺序就是归约的反向顺序</strong>, 也就是最右推导.</p>
</li>
<li>
<p>LR语法分析器的状态 – 任意时刻, LR语法分析器的状态是, 语法分析树的<strong>上边缘</strong>与<strong>剩余的输入</strong>构成的当前句型, 语法分析树的归约过程使用<strong>栈</strong>来存储.</p>
</li>
<li>
<p>那么LR语法分析其实就是在做栈上的<strong>移入</strong>和<strong>归约</strong>.</p>
</li>
<li>
<p>问题1: 移入 or 归约 ?</p>
<p>问题2: 选哪个产生式归约?</p>
</li>
<li>
<p>在0号状态, 如果遇到id这个token, 就做s5操作 (s - shift, 移入输入符号, 并进入状态n)</p>
<p>r - 使用k<strong>号</strong>产生式进行归约</p>
<p>gn - goto n, 转换到状态n</p>
<p>acc - 成功接受, 结束</p>
<p>空白 - 错误</p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623112542197.png" alt=""></p>
</li>
<li>
<p>GOTO的含义, 如果进行一次归约后, 新压入一个非终结符, 此时是s状态, 相当于移入一个非终结符, 那么此时就要查GOTO表, 根据移入的非终结符跳转到对应状态.</p>
</li>
<li>
<p>一开始是0号状态. 然后把自左向右扫描并且不断移入归约跳转.</p>
</li>
<li>
<p>根据LR分析表, 对栈进行操作的算法:</p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623114459589.png" alt=""></p>
</li>
<li>
<p>如何构建LR分析表? LR分析表 – 描述在当前编号的状态下, 面对当前文法符号, 该采取什么动作.</p>
</li>
<li>
<p>状态 – 就是语法分析树的上边缘, 存储在栈中 (栈中存放了一系列的状态, 每个状态对应了一个文法符号(终结或非终结), 所以这个栈就很好地说明了如何一步一步推导到当前的句型的全过程. (也就是语法分析树的上边缘) )</p>
</li>
<li>
<p>句柄 (handle):</p>
<ul>
<li>反向最右推导唯一，所以归约过程唯一</li>
<li>所以归约条件是唯一确定的</li>
</ul>
<p>在最终的正确的推导中, 每一个实际用到的产生式的完整右部为<strong>句柄</strong></p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623114609881.png" alt=""></p>
</li>
<li>
<p>存在 一种满足 “句柄总是出现在栈顶” 性质的LR语法分析器. (证明略)</p>
<p>设计 满足这一性质的LR语法分析器 会比较简单.</p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623114709797.png" alt=""></p>
</li>
<li>
<p>那么满足 “<strong>句柄总是出现在栈顶</strong>” 性质的语言就构成了一个文法.</p>
</li>
<li>
<p>LR(0) 句柄识别有穷状态机: (自动机两要素 – 状态和状态之间的转移)</p>
<ul>
<li><strong>LR(0) 句柄识别有穷状态机</strong> 的<strong>状态</strong>是 “<strong>当前观察到的针对所有产生式右部的一个前缀</strong>” (因为有可能没有扫描完整的右部而只是一个前缀, 所有前缀的情况都要考虑到.) – 使用项来表示</li>
<li><strong>LR(0) 句柄识别有穷状态机</strong> 的<strong>状态转移</strong></li>
</ul>
</li>
<li>
<p>项 (item) 的概念:</p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623115102421.png" alt=""></p>
</li>
<li>
<p>项集: 项的集合; 项集族: 若干项集的集合</p>
</li>
<li>
<p><strong>句柄识别有穷状态机</strong>  – 就可以表示为一个项集族</p>
</li>
<li>
<p>增广文法 – 一种技术上的处理:</p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623115931589.png" alt=""></p>
</li>
<li>
<p>确定LR(0) 句柄识别有穷状态机的初始状态:</p>
<ol>
<li>增广加上了第0条产生式</li>
<li>展开的过程就是求这个项的<strong>闭包</strong></li>
<li>S’ -&gt;.S：初始状态下什么都没看到，期望看到是S</li>
<li>跟踪S，实际上就是在跟踪S+T或者T</li>
<li>跟踪T，实际上就是在跟踪T*F或者F</li>
<li>跟踪F，实际上就是在跟踪(E)或者id</li>
<li>.的右边的第一个符号不是非终结符，就不用再展开了，得到了初始状态</li>
</ol>
<p>以上过程求的是 <strong>CLOSURE({[S’ -&gt; .S]})</strong></p>
</li>
<li>
<p>状态之间如何转移:</p>
<p>根据终结符或非终结符进行转态转移 (求闭包, 即是新的状态) , 也就便于填写LR分析表的s和GOTO表项.</p>
<p><img src="https://chendingya.github.io/2023/04/08/23-Compilers/ch16-parser-lr0-LR0%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623141822699.png" alt=""></p>
</li>
<li>
<p>接受状态 (图中红色的框) :</p>
<ul>
<li>如果在某一个状态中有这样一个项：他的点是在产生式的最右端，就找到了一个可能的产生式句柄</li>
<li>但是句柄不一定能拿来做归约</li>
</ul>
</li>
<li>
<p>如何利用<strong>LR(0) 句柄识别有穷状态机</strong>构建<strong>LR(0)分析表</strong>?</p>
<ul>
<li>
<p>s (移入) 和 GOTO 只要翻译一下自动机里所有的状态转移即可.</p>
</li>
<li>
<p>r (归约) , 何时归约? LR(0)遇到接受状态 (除了产生式左部是S’) 即归约, 没有额外条件.</p>
<p>一旦遇到可以归约的状态, 例如2号状态, 则一行都直接填写对应的归约®, 而不管任何额外条件.</p>
<p>特殊情况, 如果产生式左部是S’, 则在$一列填写接受 <strong><code>acc</code></strong></p>
</li>
</ul>
</li>
<li>
<p>如此, 便构建好了LR(0)分析表. 如果表中某一格有2个动作 (ACTION) , 那么就冲突, 所有的不会导致LR(0)分析表有冲突的文法, 叫作 LR(0) 文法.</p>
</li>
<li>
<p>LR(0) 文法:</p>
<p><em>如果文法G的 <strong>LR(0) 分析表</strong> 是<strong>无冲突</strong>的, 则G是LR(0)文法.</em></p>
<ul>
<li>L – 从左向右扫描</li>
<li>R – 构建反向最右推导</li>
<li>0 – 归约时无需向前看</li>
</ul>
</li>
<li>
<p>LR(0) 自动机与栈之间的关系: (使用栈这一数据结构的原因, 方便回溯.)</p>
<p>自动机: 向前走  &lt;-&gt; 栈: 移入</p>
<p>自动机: 回溯      &lt;-&gt; 栈: 归约</p>
</li>
</ol>
<h1>parser-lr(1)</h1>
<ol>
<li>
<p>LR(0) 语法分析 – 可能产生 <strong>移入-归约冲突</strong></p>
</li>
<li>
<p>当发现一个句柄 s: A -&gt; α, 假设此时遇到了移入-归约冲突, 能不能做归约?  假设此时后一个遇到的终结符是t, 那么问题就在于t能不能跟在A后面, 即 t ∈ FOLLOW(A) 吗?</p>
</li>
<li>
<p>t ∈ FOLLOW(A) 是可以做归约的必要条件.</p>
</li>
<li>
<p>填LR分析表时, 如果 t ∈ FOLLOW(A)  就在对应列填归约, 这区别于LR(0)将每一列都填入归约, 这一算法叫作SLR(1)语法分析算法.</p>
</li>
<li>
<p>SLR(1), S的意思是Simple. 1的意思是向前看了1, 看了FOLLOW集合.</p>
</li>
<li>
<p>SLR(1)文法:</p>
<p>如果文法G的SLR(1)分析表是无冲突的, 则G是SLR(1)文法.</p>
</li>
<li>
<p>无冲突 – ACTION表中每个单元格最多只有一个动作.</p>
</li>
<li>
<p>即使我们考虑的FOLLOW集合, 但是移入-归约冲突还是可能存在, 原因是目前的算法忽视了生成到当前状态的之前的路径的信息.</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623162747639.png" alt=""></p>
</li>
<li>
<p>如果能够尽可能精确地获取到目前状态时, 之前遇到的输入符号, 则可以进一步提升语法分析能力.</p>
</li>
<li>
<p>之前的状态会不会对终结符t提出更高的要求?</p>
<p>例子: 如果下一个终结符其实是某一格非终结符γ的开头, 那么则要加上更多的限制条件 ( ∈FIRST(γ) ) .</p>
<p>由于 ∈FIRST(γ) 本身蕴含了  ∈FOLLOW(A) 条件, 所以只要用 ∈FIRST(γ) 就够了, 相当于对命题的加强.</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623163057551.png" alt=""></p>
</li>
<li>
<p>这样就相当于向前看了1个符号, 之前的状态也会被考虑到. 如此, 我们就需要修改项的定义:</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623164317410.png" alt=""></p>
</li>
<li>
<p>如何计算LR(1)项里面的a?</p>
<p>如果产生式右部紧跟着有终结符或非终结符, 就把它和当前的a拼接起来, 如此就能得到新的a. (不同的项之间a的更新算法)</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623164938536.png" alt=""></p>
<p>根据非终结符进行GOTO转移, 这就是项集之间的转移状态. *(状态转移不影响项的第二个分量a)</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623165244815.png" alt="image-20230623165244815"></p>
</li>
<li>
<p>初始状态: ($表示输入终止, 表示期望匹配S之外就是结束了($) )</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623165301238.png" alt="image-20230623165301238"></p>
</li>
<li>
<p>LR(1)对于可以归约的条件做了更严格的限制. (LR(1)和LR(0)只有在归约上的不同)</p>
</li>
<li>
<p>LR(1)通过不断向前看符号, 区分了LR(0)区分不了的状态. =&gt; 坏处: 自动机太大, 算法太复杂. (60-70s提出LR(1)但是因为内存不够所以强大但几乎没用).</p>
</li>
<li>
<p>优化: 把LR(0)不能区分的状态直接合并, 这样减少了状态数, 同时因为其他的状态还是有a项, 所以效果也不会变差.</p>
</li>
<li>
<p>LR(0)能区分的项 – LR(0)核心项 , 其实就是LR(1)项减去a.</p>
</li>
<li>
<p>如何做合并? – 对于具有相同核心项的状态, 先从没有出边的状态开始不断向内部合并, 直到合并完所有具有相同核心项的状态.</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623172636378.png" alt=""></p>
</li>
<li>
<p>如此, 就得到了LALR(1)语法分析算法 (LA – Look Ahead)</p>
</li>
<li>
<p>合并后得到的LALR(1)分析表是否会引入新的冲突. – 会, 引入归约-归约冲突. 所以LALR(1)分析能力弱于LR(1).</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623173217112.png" alt=""></p>
</li>
<li>
<p>LR(0) &lt; SLR &lt; LALR(1) &lt; LR(1)</p>
</li>
<li>
<p>定理: LALR(1)分析表不会引入移入-归约冲突.</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623172840842.png" alt=""></p>
</li>
<li>
<p>LALR(1)的优点:</p>
<p><img src="https://chendingya.github.io/2023/04/09/23-Compilers/ch17-LR(1)-LR(1)%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/image-20230623173404935.png" alt=""></p>
</li>
<li>
<p>明明基于的是LR(0)核心项, 但是你却通过 LR(1) 自动机构造 LALR(1) 项集族?</p>
<p>第 4.7.5 节 (本科教学版): 高效构造 LALR(1) 语法分析表的方法</p>
</li>
<li>
<p><strong>除LR(0)外, 以上各种LR类文法对应的<em>语言</em>是<em>等价</em>的.</strong> 注意, 是语言, 不是文法, 不同的LR文法有包含关系, 但是除LR(0), 表达语言的能力是一样的, 即: <strong>一个用LR(k) 文法描述的语言一定可以改用SLR文法表达</strong> (尽管实际上文法可能很复杂!)</p>
</li>
<li>
<p>回顾各种文法的关系:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220094542795.webp" alt=""></p>
</li>
<li>
<p>遇到二义性, 如何在不修改文法的前提下消解冲突? – 考虑<strong>结合性</strong>和<strong>优先级</strong>.</p>
</li>
<li></li>
</ol>
<h1>semantics - symtable</h1>
<ol>
<li>
<p>语义分析的任务很分散</p>
<ol>
<li>
<p>类型检查 (<strong>Type Checking</strong>)</p>
<ul>
<li>强类型语言 (如Java) – 类型检查更严格 (弱类型语言的类型检查 不严格 就像开玩笑一样, 如 while(1) – C语言 ); 动态类型语言 (运行时做类型检查) / 静态类型语言 (编译期做类型检查)  (<em>类型论 – Type Theory</em>)</li>
</ul>
</li>
<li>
<p>符号检查 (Symbol Checking)</p>
<ul>
<li>符号(Symbols): 变量名, 函数名, 类型名, 标签名, …</li>
<li>符号检查包括: 未定义的符号 / 重复定义 / 定义类型不匹配 (变量定义当函数名用)</li>
</ul>
<p>…</p>
</li>
</ol>
</li>
<li>
<p>Definition (符号表 (Symbol Table))</p>
<p>符号表是用于保存各种信息的数据结构.</p>
</li>
<li>
<p>领域特定语言 (DSL) 通常只有单作用域 (全局作用域)</p>
</li>
<li>
<p>通用程序设计语言 (GPL) 通常需要嵌套作用域.</p>
</li>
<li>
<p>符号的作用域:</p>
<p>不同的作用域通过数据结构维护</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140342843.webp" alt=""></p>
<p>在此我们认为作用域有3类:</p>
<ol>
<li>全局作用域</li>
<li>函数作用域 (其实这个定义假设了函数的形参是一个单独的作用域, 而不是和函数体合并为同一个作用域)</li>
<li>局部作用域</li>
</ol>
</li>
<li>
<p>设计作用域的接口:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140512430.webp" alt=""></p>
<p>局部作用域的标识采用父作用域来标识.</p>
</li>
<li>
<p>通过currentScope表示当前的作用域.</p>
</li>
<li>
<p>通过给语法分析的分支打Tag的方式进行监听进入和退出某个语法产生式的一个分支. (如: <strong># assign</strong>) 这是一个高效的方式.</p>
</li>
<li>
<p>类型符号 (如 int, void ) 也要作为符号加入到符号表里.</p>
</li>
<li>
<p>实现scope树的方法很简单, 利用监听器, 每监听到进入scope, 就将其的EnclosingScope设为currentScope, 进入scope的时机就是看到函数定义(FuncDecl) 或Block (局部作用域) . (索引上一个作用域便于解析符号和回退. )</p>
</li>
<li>
<p>提供的类体系参考设计(并不很好):</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220140908716.webp" alt=""></p>
</li>
<li>
<p>Symbol应该是一个由符号名索引相关信息的HashMap.</p>
</li>
<li>
<p>加入结构体, 结构体成员的访问, 其实也要检查符号是否定义过. 那么就多出了一个结构体成员的作用域, 甚至还有嵌套结构体.</p>
</li>
<li>
<p>符号表无论从概念上还是实践上都比较简单, 下面要讲的类型检查, 则更复杂些. (加入了数组 / 指针类型的语言则更加复杂)</p>
</li>
<li></li>
</ol>
<h1>semantics - ag</h1>
<ol>
<li>
<p>语义分析 - 用一个新的文法实现语义分析, 原来的上下文无关文法不够用了.</p>
</li>
<li>
<p>有一个人提出了加入了类型检查 / 符号检查的文法 – 属性文法. 这个人就是knuth.</p>
</li>
<li>
<p>属性文法 (Attribute Grammar) : 为上下文无关文法赋予语义.</p>
</li>
<li>
<p>父节点的属性仅仅依赖于子节点的属性 – 综合属性 (synthesized) 例如: SUM: NUM + NUM</p>
</li>
<li>
<p>子节点要从父节点继承一些信息 – 继承属性 (inherited)</p>
</li>
<li>
<p>knuth在论文中提出, 只要是基于综合属性和继承属性的属性, <strong>都可以高效计算出来</strong>.</p>
</li>
<li>
<p>任务: 利用属性文法编写交互式计算器.</p>
</li>
<li>
<p>原来我们利用监听器模式实现的交互式计算器实际是offline 的方式计算属性值, 已经构建好语法树了, 关键在于在DFS的合适时机做合适事情.</p>
</li>
<li>
<p>在语法分析中实现属性文法:</p>
<p>B -&gt; X**{a}**Y</p>
<p>语义动作嵌入的位置决定了何时执行该动作</p>
<p><strong>基本思想</strong>: 一个动作在它<strong>左边</strong>的所有文法符号都<strong>处理完</strong>之后立刻执行</p>
</li>
<li>
<p>计算器的实现:</p>
<p>给expr起别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr : l = expr op = (&#x27;*&#x27; | &#x27;/&#x27;) r = expr</span><br></pre></td></tr></table></figure>
<p>这样就可以使用l和r索引对应位置的语法单元.</p>
</li>
<li>
<p>添加属性: (给规则加了返回值 <strong>returns</strong> 之后, 我们后续就可以用val来获取这一属性值.)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@header &#123;</span><br><span class="line">	package ag.expr;</span><br><span class="line">	import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@parser::members &#123;</span><br><span class="line">	Map&lt;String, Integer&gt; memory = new HashMap&lt;&gt;();</span><br><span class="line">	int eval(int l, int r, int op) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expr returns [int val]</span><br><span class="line">	: l = expr op = (&#x27;*&#x27; | &#x27;/&#x27;) r = expr &#123; $val = $l.val $r.val; System.out.println($val); &#125;</span><br><span class="line">	| ...</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>插入一段java代码以告诉antlr如何计算属性值. 要在开头使用一个$符来引用对象.</p>
</li>
<li>
<p>插入的代码放在了产生式的最右端, 这不是为了好看, 而是说明<strong>前面所有操作执行过之后</strong>, 再执行花括号里的代码.</p>
</li>
<li>
<p>antlr4允许你在members里面填任何java代码. (@parser限定了只允许在生成的parser文件中插入代码, 而非全部)</p>
</li>
</ol>
</li>
<li>
<p>例子2: <strong>类型声明</strong>文法举例.</p>
</li>
<li>
<p>多了2种依赖: 1. 右兄弟对于左兄弟的属性值的依赖 2. 子节点对于父节点属性值的依赖.</p>
</li>
<li>
<p>如何支持上述2种依赖? 把属性值作为参数, 通过递归调用的方式把信息传递下去.</p>
</li>
<li>
<p>antlr对于给规则加参数的支持:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vars[String typeStr]</span><br><span class="line">	: vars[$typeStr] &#x27;,&#x27; ID</span><br><span class="line">		 &#123; System.out.println($ID.text + &quot;:&quot; + $typeStr); &#125;</span><br><span class="line">	| ID &#123; System.out.println($ID.text + &quot;:&quot; + $typeStr); &#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语法制导的定义 (SDD, Syntax-Directed Definition)</p>
<p>SDD 是一个上下文无关文法和属性及规则的结合.</p>
<p>每个文法符号都可以关联多个属性;</p>
<p>每个产生式都可以关联一组规则.</p>
</li>
<li>
<p>SDD唯一确定了语法分析树上每个非终结符节点的属性值.</p>
</li>
<li>
<p>SDD没有规定以什么方式, 什么顺序计算这些属性值.</p>
</li>
<li>
<p>综合属性 (Synthesized Attribute) 节点N上的综合属性只能通过N的子节点或N本身的属性来定义.</p>
</li>
<li>
<p><em>S属性定义</em>: 如果一个SDD的每个属性都是综合属性, 则它是S属性定义.</p>
<p>S属性定义的依赖图刻画了属性实例之间自底向上的信息流动.</p>
<p>此类属性值的计算可以在 <em>自顶向下的LL语法分析</em> <strong>过程中</strong>实现.</p>
</li>
<li>
<p>**依赖图: ** 用于确定一棵给定语法分析树中各个属性实例之间的依赖关系.</p>
</li>
<li>
<p>继承属性 (Inherited Attribute) 节点N上的继承属性只能通过N的父节点, N本身和N的兄弟节点上的属性来定义.</p>
</li>
<li>
<p>继承信息流: 从上至下, 从左至右 (因为语法分析树是这样构建的)</p>
</li>
<li>
<p><em>L属性定义</em> :</p>
<p>如果一个SDD的每个属性</p>
<p>(1) 要么是综合属性,</p>
<p>(2) 要么是继承属性, 但是它的规则满足以下限制:</p>
<p>​	对于产生式 A -&gt; X~1~X~2~…X~n~ 及其对应规则定义的继承属性 X~i~.a, 则这个规则只能使用</p>
<p>​	(a) 和 <strong>产生式头 A</strong> 关联的继承属性</p>
<p>​	(b) 位于X~i~ 左边的文法符号实例 X~1~ X~2~ … X~i-1~ 相关的继承属性或综合属性</p>
<p>​	© 和这个X~i~ 的实例本身相关的继承属性或综合属性, 但是在由这个X~i~ 的全部属性组成的依赖图中不存在环.</p>
<p>则它是 L属性定义.</p>
</li>
<li>
<p>语义分析时, 先自左至右自上至下构建一遍, 完成<strong>继承属性</strong>; 再自下至上走一遍, 完成<strong>综合属性</strong>. (2趟)</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220210256289.webp" alt=""></p>
</li>
<li>
<p>例子1: 属性文法计算后缀表达式. (S属性定义 / 只使用综合属性 / 通过返回值传递)</p>
</li>
<li>
<p>例子2: 数组类型解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[2][3]  ( int a[2][3]; )</span><br><span class="line">(2, (3, int))</span><br></pre></td></tr></table></figure>
<p>绿色框内为<font color=green><strong>继承属性</strong></font></p>
<p>红色框内为<font color=red><strong>综合属性</strong></font></p>
<p><img src="https://box.nju.edu.cn/f/a50b437ef26c446697fd/?dl=1" alt=""></p>
</li>
<li>
<p>更复杂的例子: 数组声明 / 数组引用 / 类型检查</p>
</li>
<li>
<p>online 方式: 属性文法; offline : visitor / listener; 第3种: addParseListener</p>
</li>
<li>
<p>例子: <strong>有符号二进制数</strong>文法</p>
</li>
<li>
<p>Definition (语法制导的翻译方案 (Syntax-Directed Translation Scheme; SDT))</p>
<p><strong>SDT</strong> 是在其产生式体中嵌入<strong>语义动作</strong>的上下文无关文法。</p>
</li>
<li>
<p>SDD规定了一些语义规则, 而SDT采用嵌入语义动作的方式实现这些语义规则, 所以说, SDT是SDD的一种实现.</p>
</li>
<li></li>
</ol>
<h1>LLVM</h1>
<ol>
<li>
<p>Chris Lattner – llvm项目的发起者. (此外他的贡献有: clang, swift语言, …)</p>
</li>
<li>
<p>llvm本身不是编译器, 而是编译的基础设施, 是一系列工具链. (llvm是模块化可重用的 (modular and reusable) )</p>
</li>
<li>
<p>llvm ir 是一种中间表示, 你只需要把你的语言编译成ir (前端), 就可以在任何平台上用已有的llvm ir的后端编译生成目标代码.</p>
</li>
<li>
<p><strong>“IR 设计的优秀与否决定着整个编译器的好坏”</strong></p>
</li>
<li>
<p>llvm ir: 带类型的, 介于高级程序语言与汇编语言之间的 (LLVM Assembly Language)</p>
</li>
<li>
<p>如何把一个.c文件编译为一个.ll文件? (一个.ll文件叫作一个module, 模块. )</p>
</li>
<li>
<p>一个module包括: 函数 / 全局变量</p>
</li>
<li>
<p>函数 – 有若干个基本块 (BB) 构成.</p>
</li>
<li>
<p>每一个基本块 由若干条指令构成.</p>
</li>
<li>
<p>代码实例:</p>
</li>
<li>
<p>例1: factorial0.c</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm -fno-discard-value-names factorial0.c -o f0-opt0.ll -O1 -g0</span><br></pre></td></tr></table></figure>
<p><code>-emit-llvm</code>: 翻译(发射)成llvm中间代码 (bitcode) , 而不是目标代码.</p>
<p><code>-S</code>: 翻译成人类可读的llvm ir</p>
<p><code>-g0</code>: 不生成任何debug信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(<span class="number">2</span>) * <span class="number">7</span> == <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220220126419.webp" alt=""></p>
</li>
<li>
<p>全局符号 函数名 / 全局变量 -&gt; 命名以<code>@</code>开头;</p>
<p>局部符号 -&gt; 以 <code>%</code> 开头. (寄存器, 虚拟的, 有无限多, 和真正的物理寄存器无关)</p>
<p>纯数字 -&gt; 立即数</p>
</li>
<li>
<p><code>declare</code>声明, <code>define</code>定义</p>
</li>
<li>
<p><code>icmp</code> int型数比较.</p>
</li>
<li>
<p>1bit的信息, 如bool型, 就用 <code>i1</code></p>
</li>
<li>
<p>如何把1bit的整数扩展到32位的int? 零扩展!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%6 = zext i1 %5 to i32</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这种中间代码是一种 Three Address Code (TAC / 3AC)</p>
</li>
<li>
<p>llvm ir是满足<strong>静态单赋值</strong>性质的. (SSA)</p>
</li>
<li>
<p><strong>SSA</strong> 是什么?</p>
<ol>
<li>单赋值: 一个变量只被赋值一次</li>
<li>静态</li>
</ol>
</li>
<li>
<p>SSA带来的在静态分析时的优势远远大于SSA带来的冗余.</p>
</li>
<li>
<p>过程内控制流图 : Intra-procedure CFG</p>
</li>
<li>
<p>Definition (CFG):</p>
<p>Each node represents a <em>basic block</em> (BB),</p>
<p>i.e. a straight-line code sequence with no <strong>branches/jumps</strong> in except to the entry point and no <strong>branches/jumps</strong> out except at the exit point.</p>
<p><strong>Jump targets start a block, and jumps end a block.</strong></p>
<p>Directed <strong>edges</strong> are used to represent jumps in the control flow.</p>
</li>
<li>
<p>在栈帧上分配空间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%3 = alloca i32, align 4</span><br></pre></td></tr></table></figure>
<p>在栈帧上分配一个 i32 变量 %3 的空间.</p>
</li>
<li>
<p>store指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store i32 1, i32* %2, align4</span><br></pre></td></tr></table></figure>
<p>注意store / load要加*号, 表示取地址 (?).</p>
</li>
<li>
<p>为什么基本块的中间某条指令可以是 call 指令?</p>
<p>其实这是视角的问题, 因为函数最终会返回回到call指令的下一条, 相当于并没有真正离开这个基本块. 而jmp是真正会走的, 所以CFG的边专门由jmp生成. (有始有终 – call; 有始无终 – jmp)</p>
</li>
<li>
<p>不使用store / load, 怎么汇合同一个变量经过不同路径后的多个可能值?</p>
<p><strong>φ指令!</strong></p>
<p>但是事实上, x86等目标架构没有φ指令, 所以φ指令优化后的代码<strong>还是要还原至使用store / load的方式 (绕过了SSA的要求)</strong> (生成目标代码时).</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230220222623949.webp" alt=""></p>
<p><code>phi i32 [%6, %3], [1, %1]</code> 表示</p>
<p>​	<strong>如果是从%3来的, 就取值%6; 如果从%1来的, 就取值1.</strong></p>
</li>
<li>
<p>φ根据控制流决定选择y1还是y2.</p>
</li>
<li>
<p>φ指令对于<strong>SSA的构建</strong>十分重要! (把φ指令变成机器代码的实现, 叫作<strong>SSA的消去</strong>; 让机器指令重新拥有φ指令的性质 - <strong>SSA的重建</strong>)</p>
</li>
<li>
<p>没必要一上来就读llvm文档, 可以阅读ppt上的资源和llvm开发者的tutorial.</p>
</li>
<li>
<p>我们的实验 – 使用Java api生成LLVM IR. 课程实验可以自学生成φ指令的算法, 也可以直接写load store指令 (不开优化时生成的代码).</p>
</li>
<li>
<p>简单的实验讲解:</p>
<ol>
<li>build对象 - 构建器 <code>  LLVMBuilderRef builder = LLVMCreateBuilderInContext(context);</code></li>
<li>用构建器构建各种东西</li>
<li><a target="_blank" rel="noopener" href="https://github.com/courses-at-nju-by-hfwei/2024-compilers-coding/blob/main/src/main/java/llvm/factorial/Factorial1.java">https://github.com/courses-at-nju-by-hfwei/2024-compilers-coding/blob/main/src/main/java/llvm/factorial/Factorial1.java</a></li>
</ol>
</li>
<li>
<p>llvm官方给出的一种小语言Kaleidoscope的编译器前端:</p>
<p><a target="_blank" rel="noopener" href="https://llvm.org/docs/tutorial/">https://llvm.org/docs/tutorial/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/courses-at-nju-by-hfwei/kaleidoscope-in-java">https://github.com/courses-at-nju-by-hfwei/kaleidoscope-in-java</a> (java版本的教程)</p>
</li>
</ol>
<h1>ir-expr</h1>
<ol>
<li>
<p>中间代码生成 - 表达式翻译</p>
</li>
<li>
<p>综合属性 <code>E.code</code>: 中间代码</p>
</li>
<li>
<p>综合属性 <code>E.addr</code>: <strong>变量名 (包括临时变量)、常量</strong>    (龙书上这样叫变量)</p>
</li>
<li>
<p>利用E.code和E.addr生成中间代码: (top就是当前作用域的符号表)</p>
<p><img src="https://box.nju.edu.cn/f/1155ffce45624c17bcab/?dl=1" alt=""></p>
</li>
<li>
<p>数组引用的中间代码翻译:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">3</span>]; </span><br></pre></td></tr></table></figure>
<p>需要计算<code>a[2][3]</code>相对于数组基地址 a 的<strong>偏移地址</strong>.</p>
<p>width既是继承属性又是综合属性, 4字节继承自int, 加上数组引用时综合出新的width.</p>
<p><img src="https://box.nju.edu.cn/f/e286f2195d974632adc1/?dl=1" alt=""></p>
</li>
<li>
<p>在已声明a的类型为<code>int a[2][3];</code>的前提下,  实现翻译数组访问 <code>a[i][j]</code>: (手写一遍更易理解!)</p>
<p>a</p>
<p>-&gt; a[i]      宽度 (width) 为12字节 (计算方式见上一张图)</p>
<p>-&gt; a[i][j]</p>
<p>语义规则: (同时还用了上一张图里的 <code>.width</code> 属性)</p>
<p><img src="https://chendingya.github.io/2023/04/04/23-Compilers/ch12-ir-expr-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BF%BB%E8%AF%91/image-20230526173312021.png" alt=""></p>
<p>形成<strong>注释语法树</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c + a[i][j]</span><br></pre></td></tr></table></figure>
<p><img src="https://chendingya.github.io/2023/04/04/23-Compilers/ch12-ir-expr-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BF%BB%E8%AF%91/image-20230526173353737.png" alt=""></p>
</li>
<li>
<p>llvm对于数组访问的实现:</p>
<p><img src="https://pictures-1312865652.cos.ap-nanjing.myqcloud.com/image-20230221083640233.webp" alt=""></p>
</li>
<li>
<p>使用alloca为数组分配内存空间, <code>[2 x [3 x i32]]</code> 几乎就是源码的直译.</p>
</li>
<li>
<p>而取数组里的内容, 用到了GEP指令.</p>
</li>
<li>
<p>GEP指令 (用于访问聚合类型, 如数组, 结构体 … ; 是用来操作指针的, 不是操作内存)</p>
</li>
</ol>
<p>GEP provides a way to access arrays and manipulate pointers</p>
<ol start="11">
<li>
<p>getelementptr</p>
<p>&lt;base-type&gt;, &lt;base-type&gt;* , &lt;base-addr&gt;, [i32/i64 &lt;index&gt; ]+</p>
<p>参数1: 被操作元素的类型</p>
<p>参数2: 数组的首地址</p>
<p>参数3: 从数组的首地址开始, 整体地偏移几个被操作元素的内存大小</p>
<p>参数4: 对数组做一次索引的取值, 可以重复索引多次.</p>
<p><code>a[1][2]</code></p>
<p><code>gep [1 x [2 x i32]], [1 x [2 x i32]]* %a, i32 0, i32 %1, i32 %2</code></p>
</li>
<li>
<p>更复杂的是涉及结构体, 以及结构体 / 数组嵌套时的GEP指令生成 (自学)</p>
</li>
<li>
<p>llvm的全局变量实际上都是指针.</p>
</li>
<li></li>
</ol>
<h1>ir-control</h1>
<ol>
<li>
<p>控制流语句的翻译和布尔表达式的翻译:</p>
<p>(把赋值语句抽象成一个终结符, B表示布尔表达式)</p>
<p><img src="https://chendingya.github.io/2023/04/05/23-Compilers/ch13-ir-control-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91/image-20230527114721450.png" alt=""></p>
</li>
<li>
<p>控制流的翻译方案: 1. 简单的方案 - 产生冗余  2. 困难的方案 - 更短, 更高效 (龙书)</p>
</li>
<li>
<p>分工与合作: B生成的代码和S生成的代码如何组合起来?</p>
</li>
<li>
<p>简单方案: 将B的逻辑值算出来 (<strong>B生成的代码</strong>) , 并保存到临时变量t1里. 然后利用br指令根据t1的真假跳转到B.true和B.false标签 (<strong>S生成的代码</strong>) .</p>
</li>
<li>
<p>实现顺序: 布尔表达式 - if - while - break - 短路求值</p>
</li>
<li>
<p>相关的产生式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">grammar Control;</span><br><span class="line"></span><br><span class="line"><span class="meta">@header</span> &#123;</span><br><span class="line"><span class="keyword">package</span> codegen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prog : stat ;</span><br><span class="line"></span><br><span class="line">stat : ID <span class="string">&#x27;=&#x27;</span> expr <span class="string">&#x27;;&#x27;</span>                      # AssignStat</span><br><span class="line">     | <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> bool <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> ifStat = stat <span class="string">&#x27;&#125;&#x27;</span> <span class="string">&#x27;else&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> elseStat = stat <span class="string">&#x27;&#125;&#x27;</span> # IfElseStat</span><br><span class="line">     | <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> bool <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> stat <span class="string">&#x27;&#125;&#x27;</span>       # IfStat</span><br><span class="line">     | <span class="string">&#x27;while&#x27;</span> <span class="string">&#x27;(&#x27;</span> bool <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> stat <span class="string">&#x27;&#125;&#x27;</span>    # WhileStat</span><br><span class="line">     | <span class="string">&#x27;break&#x27;</span> <span class="string">&#x27;;&#x27;</span>                          # BreakStat</span><br><span class="line">     | first = <span class="type">stat</span> <span class="variable">second</span> <span class="operator">=</span> stat           # SeqStat</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">bool : lhs = <span class="type">expr</span> <span class="variable">op</span> <span class="operator">=</span> (<span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span> | <span class="string">&#x27;==&#x27;</span>) rhs = expr   # RelExpr</span><br><span class="line">     | op = <span class="string">&#x27;!&#x27;</span> bool                                    # NotExpr</span><br><span class="line">     | lhs = <span class="type">bool</span> <span class="variable">op</span> <span class="operator">=</span> <span class="string">&#x27;&amp;&amp;&#x27;</span> rhs = bool                  # AndExpr</span><br><span class="line">     | lhs = <span class="type">bool</span> <span class="variable">op</span> <span class="operator">=</span> <span class="string">&#x27;||&#x27;</span> rhs = bool                  # OrExpr</span><br><span class="line">     | <span class="string">&#x27;true&#x27;</span>                                           # TrueExpr</span><br><span class="line">     | <span class="string">&#x27;false&#x27;</span>                                          # FalseExpr</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Section 6.4.1: grammar for expressions</span></span><br><span class="line"><span class="comment"> *   (array decl and references are not included yet)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">expr : <span class="string">&#x27;-&#x27;</span> expr         # NegExpr</span><br><span class="line">     | expr <span class="string">&#x27;*&#x27;</span> expr    # MultExpr</span><br><span class="line">     | expr <span class="string">&#x27;+&#x27;</span> expr    # ADDExpr</span><br><span class="line">     | <span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>     # ParenExpr</span><br><span class="line">     | ID               # IdExpr</span><br><span class="line">     | INT              # IntExpr</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">GT : <span class="string">&#x27;&gt;&#x27;</span> ;</span><br><span class="line">GE : <span class="string">&#x27;&gt;=&#x27;</span> ;</span><br><span class="line">EE : <span class="string">&#x27;==&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">ID : [a-z] ;</span><br><span class="line">INT : [<span class="number">0</span>-<span class="number">9</span>] ;</span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用访问者模式生成中间代码: (生成的ir没有行末分号)</p>
<p>对于具体的 and or 等表达式, 分别地进行visit并返回临时变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenVisitor</span> <span class="keyword">extends</span> <span class="title class_">ControlBaseVisitor</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">// stat -&gt; ID = expr</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">visitAssignStat</span><span class="params">(ControlParser.AssignStatContext ctx)</span> &#123;</span><br><span class="line">    	<span class="type">String</span> <span class="variable">expr</span> <span class="operator">=</span> visit(ctx.expr());</span><br><span class="line">    	emit(ctx.ID().getText() + <span class="string">&quot; = &quot;</span> + expr);</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// stat -&gt; if (bool) &#123; stat &#125;</span></span><br><span class="line">  	<span class="comment">// if语句</span></span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">visitIfStat</span><span class="params">(ControlParser.IfStatContext ctx)</span> &#123;</span><br><span class="line">   	 	<span class="type">String</span> <span class="variable">bool</span> <span class="operator">=</span> visit(ctx.bool());</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//生成label</span></span><br><span class="line">    	<span class="type">String</span> <span class="variable">trueLabel</span> <span class="operator">=</span> getNewLabel(<span class="string">&quot;b.true&quot;</span>);</span><br><span class="line">    	<span class="type">String</span> <span class="variable">falseLabel</span> <span class="operator">=</span> getNewLabel(<span class="string">&quot;b.false&quot;</span>);</span><br><span class="line">      	<span class="comment">//选择跳转的label</span></span><br><span class="line">    	emit(<span class="string">&quot;br &quot;</span> + bool + <span class="string">&quot; &quot;</span> + trueLabel + <span class="string">&quot; &quot;</span> + falseLabel);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//为真</span></span><br><span class="line">    	emitLabel(trueLabel);</span><br><span class="line">    	visit(ctx.stat());</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//直接跳到false</span></span><br><span class="line">    	emitLabel(falseLabel);</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>翻译break语句: 如果进入了一层while循环, 那么就将这一层的对应的false标签压栈, 退出循环体时, 就弹栈. <code>break</code>语句只要peek一下栈顶然后 <code>br</code> 跳转一下就行.</p>
</li>
<li>
<p>翻译continue语句: 类似break, 应该将循环入口压栈, 退出时弹栈, <code>continue</code>语句peek栈顶跳转到最内层循环入口.</p>
</li>
<li>
<p>实现布尔表达式的短路求值:</p>
<p>(思路: 以<code>and</code>为例, <code>B1 and B2</code>, 如果B1为false, 那么直接跳转到false目标, 不访问B2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bool -&gt; lhs = bool &amp;&amp; rhs = bool</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">visitAndExpr</span><span class="params">(ControlParser.AndExprContext ctx)</span> &#123;</span><br><span class="line">    <span class="comment">// short-circuit version</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lhs</span> <span class="operator">=</span> visit(ctx.lhs);</span><br><span class="line">    </span><br><span class="line">    emitCode(<span class="string">&quot;br &quot;</span> + lhs + <span class="string">&quot; &quot;</span> + trueLabel + <span class="string">&quot; &quot;</span> + falseLabel);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> getNewTemp();</span><br><span class="line"></span><br><span class="line">    emitLabel(trueLabel); <span class="comment">// trueLabel:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rhs</span> <span class="operator">=</span> visit(ctx.rhs);</span><br><span class="line">    emitCode(temp + <span class="string">&quot; = &quot;</span> + rhs);</span><br><span class="line">    emitCode(<span class="string">&quot;br &quot;</span> + endLabel);</span><br><span class="line"></span><br><span class="line">    emitLabel(falseLabel); <span class="comment">// falseLabel: </span></span><br><span class="line">    emitCode(temp + <span class="string">&quot; = false&quot;</span>);</span><br><span class="line"></span><br><span class="line">    emitLabel(endLabel); <span class="comment">// endLabel: </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之前的方案有冗余: <code>t1 = true</code> 可以直接常量替换, 并存在冗余的多级跳转.</p>
</li>
<li>
<p>复杂方案: 减少冗余的跳转路径, 生成更短, 更高效的代码.</p>
</li>
<li>
<p>直接用布尔表达式改变控制流, 无需计算最终逻辑值. <strong>从父节点获取<em>更具体</em>的跳转目标, 缩短跳转路径.</strong></p>
</li>
<li>
<p>语义规则: (根据<strong>继承下来的跳转目标</strong>跳转)</p>
<p><img src="https://chendingya.github.io/2023/04/06/23-Compilers/ch14-ir-control-%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BF%BB%E8%AF%91/image-20230602165059117.png" alt=""></p>
</li>
<li>
<p>重点在于根据if / while 的语义选择不同的翻译方案, 不同翻译方案的关键在于3个属性 <code>B.true</code> /<code>B.false</code> / <code>S.next</code> 如何取值. (根据语义确定取值, 再根据取值分配到具体的语义规则处理)</p>
</li>
<li>
<p>顺序语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; S1 S2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S1.next = newlabel()</span><br><span class="line">S2.next = S.next</span><br><span class="line">S.code = S1.code || label(S1.next) || S2.code </span><br></pre></td></tr></table></figure>
<p>为什么要在S1后面也加标签, 因为S1可能是if / while 语句, 需要有出口, 必须考虑它们需要出口的情况.  当然, 这种方式可能会引入多余的标签. (容易使用Basic Block优化)</p>
</li>
<li>
<p>布尔表达式的产生式和语义规则:</p>
<p><img src="https://chendingya.github.io/2023/04/06/23-Compilers/ch14-ir-control-%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BF%BB%E8%AF%91/image-20230622141759361.png" alt=""></p>
<p>这里每一个布尔表达式翻译后会直接<strong>生成跳转到目标位置</strong>的代码, 最终归结到 <code>true</code> / <code>false</code> 字面值 或者 表达式比较 (<code>E rel E</code>) .</p>
<p>(<strong>布尔表达式</strong> 的 2个作用 : 1. <strong>布尔值</strong> 2. <strong>控制流跳转</strong>)</p>
<p>至于B.true和B.false怎么来, 见上一点S的语义规则, 这2个属性是继承属性, 从S继承而来.</p>
</li>
<li>
<p>如果我们就只想单纯计算布尔表达式的值而不用它作跳转呢? 龙书6.6.6节: 分成2个函数 –  <code>jump()</code> 专门用于产生控制流跳转代码, <code>rvalue()</code> 专门用于生成求值 (并将值存入临时变量) 的代码, 并在不同的情景下选择仅使用 rvalue 还是2个都使用.</p>
</li>
<li>
<p>短路求值: 上图的 and 和 or 运算的语义规则都是短路求值的. 以 <code>or</code> 为例:</p>
<p><img src="https://chendingya.github.io/2023/04/06/23-Compilers/ch14-ir-control-%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BF%BB%E8%AF%91/image-20230622142051115.png" alt=""></p>
</li>
<li>
<p>一个综合的例子:</p>
<p><img src="https://chendingya.github.io/2023/04/06/23-Compilers/ch14-ir-control-%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BF%BB%E8%AF%91/image-20230622142430258.png" alt=""></p>
<p>翻译结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">goto</span> L2</span><br><span class="line">    <span class="keyword">goto</span> L3</span><br><span class="line">L3: <span class="keyword">if</span> x &gt; <span class="number">200</span> <span class="keyword">goto</span> L4</span><br><span class="line">    <span class="keyword">goto</span> L1</span><br><span class="line">L4: <span class="keyword">if</span> x != y <span class="keyword">goto</span> L2</span><br><span class="line">    <span class="keyword">goto</span> L1</span><br><span class="line">L2: x = <span class="number">0</span></span><br><span class="line">L1: </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用antlr4的实现 (使用Listenner) :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterWhileStat</span><span class="params">(ControlParser.WhileStatContext ctx)</span> &#123;</span><br><span class="line">    beginLabel.put(ctx, getNewLabel() + <span class="string">&quot;begin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    trueLabel.put(ctx.bool(), getNewLabel());</span><br><span class="line">    falseLabel.put(ctx.bool(), nextLabel.get(ctx));</span><br><span class="line">    nextLabel.put(ctx.stat(), beginLabel.get(ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitWhileStat</span><span class="params">(ControlParser.WhileStatContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s:%n%s%n%s:%n%s%n%s&quot;</span>,</span><br><span class="line">        <span class="comment">//对着规则一行一行翻译</span></span><br><span class="line">        beginLabel.get(ctx),</span><br><span class="line">        codeProperty.get(ctx.bool()),</span><br><span class="line">        trueLabel.get(ctx.bool()),</span><br><span class="line">        codeProperty.get(ctx.stat()),</span><br><span class="line">        <span class="string">&quot;goto &quot;</span> + beginLabel.get(ctx));</span><br><span class="line"></span><br><span class="line">    codeProperty.put(ctx, code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterIfStat</span><span class="params">(ControlParser.IfStatContext ctx)</span> &#123;</span><br><span class="line">    trueLabel.put(ctx.bool(), getNewLabel());</span><br><span class="line">    falseLabel.put(ctx.bool(), nextLabel.get(ctx));</span><br><span class="line">    nextLabel.put(ctx.stat(), nextLabel.get(ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitIfStat</span><span class="params">(ControlParser.IfStatContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s%n%s:%n%s&quot;</span>,</span><br><span class="line">        codeProperty.get(ctx.bool()),</span><br><span class="line">        trueLabel.get(ctx.bool()),</span><br><span class="line">        codeProperty.get(ctx.stat()));</span><br><span class="line"></span><br><span class="line">    codeProperty.put(ctx, code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterAndExpr</span><span class="params">(ControlParser.AndExprContext ctx)</span> &#123;</span><br><span class="line">    trueLabel.put(ctx.lhs, getNewLabel());</span><br><span class="line">    falseLabel.put(ctx.lhs, falseLabel.get(ctx));</span><br><span class="line"></span><br><span class="line">    trueLabel.put(ctx.rhs, trueLabel.get(ctx));</span><br><span class="line">    falseLabel.put(ctx.rhs, falseLabel.get(ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitAndExpr</span><span class="params">(ControlParser.AndExprContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s%n%s:%n%s&quot;</span>,</span><br><span class="line">        codeProperty.get(ctx.lhs),</span><br><span class="line">        trueLabel.get(ctx.lhs),</span><br><span class="line">        codeProperty.get(ctx.rhs));</span><br><span class="line"></span><br><span class="line">    codeProperty.put(ctx, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现在翻译的结果是只产生标签, 而不是真实的地址. 真实世界的编译器 (如<code>javac</code>) 真的会用这种方案吗? – 下节课.</p>
</li>
<li></li>
</ol>
<h1>ir-backpatch</h1>
<ol>
<li>
<p>上一节的翻译方案: 生成的是标签而不是地址 / 相对地址. (出于效率考虑, 希望一次扫描就能获得地址)</p>
</li>
<li>
<p>地址回填技术 (Backpatching) :</p>
<p>Backpatching is a technique used in compiler design to update previously generated code with the correct target addresses or labels. It helps establish the connections between control flow constructs, such as conditionals and loops, by setting the appropriate target addresses <strong>during code generation</strong>. (只进行一趟扫描)</p>
</li>
<li>
<p>先假设指令大小都是1, 那么地址就等于行号. 事实上, 一条指令可能占有多个字节, 如某条指令编号为3，占据了三个字节，下一个指令编号为6. 事实上, 接下来介绍的算法也很容易改成<strong>一条指令占据多个字节</strong>的版本.</p>
</li>
<li>
<p>回填 (Backpatching) 技术: 子节点挖坑、祖先节点填坑</p>
<ul>
<li>子节点暂时不指定跳转指令的目标地址</li>
<li>待祖先节点能够确定目标地址时回头填充</li>
</ul>
</li>
<li>
<p>子节点跳转的目标地址先不填, 而是通过 truelist / falselist 传递给父节点. 父节点通过<strong>综合属性</strong>收集子节点中具有<strong>相同目标</strong>的跳转指令.</p>
</li>
<li>
<p>向上传递的过程中, 需要用到 merge (union) 操作. (向上传递的过程中, true / false 的list属性要么向上层传递了, 要么被填上了)</p>
</li>
<li>
<p>语义规则:</p>
<p><font color=red><strong>B.falselist</strong></font> 保存所有需要跳转到 false 标签的指令, <font color=green><strong>S.nextlist</strong></font> 保存所有需要跳转到 next 标签的指令 (用于回填)</p>
<p><font color=lighblue><strong>backpatch</strong></font> 操作表示将跳转的目标位置回填到指令的list里.</p>
<p><img src="https://box.nju.edu.cn/f/65dab1df8a714ff18526/?dl=1" alt=""></p>
</li>
<li>
<p>则所有的信息流都是自底向上流动, 都是综合属性.</p>
</li>
<li>
<p>布尔表达式的产生式文法:</p>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622152721058.png" alt=""></p>
</li>
<li>
<p>M的引入是为了获取B2的第一行代码.</p>
</li>
<li>
<p>B -&gt; true  和 B -&gt; false 的翻译方案:</p>
<ul>
<li>B.truelist就是一个集合，将所有去往B.true的指令收集起来</li>
<li>makelist 创建一个list</li>
<li>nextinstr 是指示下一条指令的全局变量, 每生成一条指令就自增.</li>
</ul>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622152852697.png" alt=""></p>
<p>上面是回填的翻译方案, 下面的是上一节的方案. 可以看出, 二者是相对应的. (理解时建议对照理解)</p>
</li>
<li>
<p>关系表达式的翻译方案:</p>
<p>原来的 goto B.true 现在将标签空出, 并行号加入truelist即可.</p>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622153252292.png" alt=""></p>
</li>
<li>
<p>取反和括号的翻译方案:</p>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622153519707.png" alt=""></p>
</li>
<li>
<p>与 (&amp;&amp;) 操作的翻译:</p>
<ul>
<li>非终结符M的属性 instr 表示 <strong>下一条指令</strong>, 即B2的第一条指令的地址.</li>
<li>根据短路求值计算出 B 的 truelist 和 falselist.</li>
<li>如果B1 为 true, 那么B1跳转的目标已经能够知道了 (即B2的第一条指令) , 所以在此时回填 B1.truelist.</li>
</ul>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622153752740.png" alt=""></p>
</li>
<li>
<p>或 (||) 操作同理.</p>
</li>
<li>
<p>一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt; <span class="number">100</span> || (x &gt; <span class="number">200</span> &amp;&amp; x != y)</span><br></pre></td></tr></table></figure>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622154644961.png" alt=""></p>
<p>翻译结果: ( _ 的地方待上层节点填充 )</p>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622155316362.png" alt=""></p>
</li>
<li>
<p>控制流语句的翻译方案:</p>
<ul>
<li>
<p>除了之前用到的M, 还额外引入了N.</p>
</li>
<li>
<p>N的作用比M多一点, 除了获取下一条指令之外, 还负责生成一条goto指令.</p>
</li>
</ul>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622155336961.png" alt=""></p>
</li>
<li>
<p>if语句的翻译方案:</p>
<ul>
<li>生成要跳往 S.next 的指令集合 (S.nextlist), 为 B.falselist 和 S1.nextlist的合并.</li>
<li>发现B为true的跳转目标已知, 回填 B.truelist.</li>
</ul>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622155449711.png" alt=""></p>
</li>
<li>
<p>if else 的翻译方案:</p>
<ul>
<li>会生成一条 goto 指令 (通过 N)</li>
<li>S.nextlist 是 S1.nextlist, N.nextlist 和 S2.nextlist 三者的合并. (为什么? 因为N里面有goto语句, 需要回填, 而S1和S2都可能有break语句, 也可能需要回填)</li>
<li>B为true和B为false的跳转目标都已知, 所以 B.truelist 和 B.falselist 都回填.</li>
</ul>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622155719893.png" alt=""></p>
</li>
<li>
<p>while 语句的翻译方案:</p>
<ul>
<li>会生成一条跳回开头的 goto 语句, 这条goto语句的目标是已经经过的代码, 所以不用回填, 可以直接用M1.instr获取目标地址.</li>
<li>只有 B.false 会跳到 S.next, 所以 S.nextlist = B.falselist</li>
<li>B为真 和 S1的下一条指令 的地址都可以确定了, 所以都回填.</li>
</ul>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622155756022.png" alt=""></p>
</li>
<li>
<p>顺序语句: 2条语句 L 和 S 之间要插入M, 是为了如果L里有要跳出的 nextlist, 就可以使用M定位到跳出的位置 (S前面). 这样的做法解决了所有的跳转地址的确定, 并且与上一节所讲的加标签的做法相比, 这样的回填方案不会产生无用标签.</p>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622160637031.png" alt=""></p>
</li>
<li>
<p>加 {} 和 赋值语句 (A, assign) 的翻译方案:</p>
<p><img src="https://chendingya.github.io/2023/04/07/23-Compilers/ch15-ir-backpatch%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5%E7%BF%BB%E8%AF%91%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF/image-20230622160644159.png" alt=""></p>
</li>
<li>
<p>只需要理解回填的思想 <strong>(如何计算和传递几个综合属性, 何时回填 (能确定目标地址时), 何时生成goto指令)</strong> , 并且<strong>会读语义规则</strong>即可. 不需要记忆具体的语义规则.</p>
</li>
<li>
<p>switch语句的翻译 – 使用跳转表 (方便二分查找)</p>
</li>
<li></li>
</ol>
<h1>codegen - RISC V</h1>
<ol>
<li>
<p>目标 – 中间代码 -&gt; 汇编语言 (RISCV)</p>
</li>
<li>
<p>目标代码生成的困难 – 指令选择 (LLVM IR 与 目标代码不是一一对应的) / 寄存器分配 / 栈管理问题 (寄存器不够用, 放入栈 / 函数调用) / 目标代码优化</p>
</li>
<li>
<p>RISCV – Reduced Instruction Set Computer V 精简指令集计算机第5代</p>
</li>
<li>
<p>ISA (Instruction Set Architecture) as the Software/Hardware Interface 软件和硬件之间的接口, 为硬件定义了指令集. 数据类型, 寄存器, 基础特性, IO模型 …</p>
</li>
<li>
<p>CISC 复杂 (Complex) 指令集计算机. 可以做2件不同的事情 (如 load + 运算)</p>
</li>
<li>
<p>RISC 与 CISC 的区别:</p>
<ol>
<li>RISC指令只能做一件事 (不能同时做load / 运算)</li>
<li>RISC指令都是定长的 (RISCV32的指令长为 4字节), CISC指令可以是变长的.</li>
</ol>
</li>
<li>
<p>RISCV是开源指令集, RISCV国际基金会 (包括若干家中国企业)</p>
</li>
<li>
<p>全套大餐 (大而全, 增量式; x86)  菜单 (模块化; RISC-V)</p>
</li>
<li>
<p>RISCV的模块化使得其<strong>易扩展</strong>.</p>
</li>
<li>
<p><em>RISC-V开放架构设计之道</em>, 推荐, 其中除了RISC-V的设计之外, 还讲解了为什么要这样设计.</p>
</li>
<li>
<p>下面将带你入门RISC-V.</p>
</li>
<li>
<p>RISC-V寄存器 (32个, 0号-31号), 除了编号, 每个寄存器还有别名.</p>
</li>
<li>
<p>0号寄存器 zero : 永远是0</p>
</li>
<li>
<p>1号寄存器 ra : return address</p>
</li>
<li>
<p>t0-t6: 临时寄存器</p>
</li>
<li>
<p>pc: 程序计数器</p>
</li>
<li>
<p><code>add.asm</code>: li load immediate 加载立即数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li t0, 100</span><br><span class="line">li t1. 200</span><br><span class="line">add t2, t0, t1</span><br></pre></td></tr></table></figure>
<p><code>li</code> 是 RISC-V 里的伪指令, 也就是语法糖. 实际上 <code>li t0, 100</code> 是 <code>addi t0, zero, 100</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li t0, 100</span><br><span class="line">addi t1, t0, 200</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>add-sub.asm</code></p>
<p>f = (g + h) - (i + j)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">li t0, 0</span><br><span class="line">li t1, 10</span><br><span class="line">add t2, t0, t1</span><br><span class="line"></span><br><span class="line">li t3, 30</span><br><span class="line">li t4, 40</span><br><span class="line">add t5, t3, t4</span><br><span class="line"></span><br><span class="line">sub t6, t2, t5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>output.asm</code></p>
<p>想要将数值输出, 需要调用合适的系统调用.</p>
<p>阅读RISC-V手册可知:</p>
<p>step1: 将设备号加载到a7寄存器中.</p>
<p>step2: 将参数加载到 a0, a1, a2, a3, fa0, … .(寄存器 a0 的 a 就是 参数的意思)</p>
<p>step3: 发射一条ecall指令</p>
<p>step4: 取回返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li t6, -47</span><br><span class="line"># output:</span><br><span class="line">li a7, 1</span><br><span class="line">mv a0, t6</span><br><span class="line">ecall</span><br></pre></td></tr></table></figure>
<p>mv 也是伪指令, 作用是寄存器赋值.</p>
<p>(注意, <code>mov</code> 是 intel 格式的, 即 <code>mov</code> <code>dest</code> <code>src</code>)</p>
</li>
<li>
<p><code>data.asm</code></p>
<p>text段 – 放指令</p>
<p>data段 – 放数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">g: .word 0</span><br><span class="line">h: .word 10</span><br><span class="line">i: .word 30</span><br><span class="line">j: .word 40</span><br><span class="line"></span><br><span class="line">result: .word 0</span><br><span class="line"></span><br><span class="line">msg: .string &quot;The result is :&quot;	#.string会自动在末尾加\0;  .ascii则不会自动在末尾加\0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la t0, g  # la: load address</span><br><span class="line">lw t1, 0(t0) # lw: load word</span><br><span class="line"># lw t1, g</span><br><span class="line"></span><br><span class="line">la t0, h</span><br><span class="line">lw t2, 0(t0)</span><br><span class="line">add t3, t1, t2</span><br><span class="line"></span><br><span class="line">la t0, i</span><br><span class="line">lw t4, 0(t0)</span><br><span class="line"></span><br><span class="line">la t0, j</span><br><span class="line">lw t5, 0(t0)</span><br><span class="line">add t6, t4, t5</span><br><span class="line"></span><br><span class="line">sub t6, t3, t6</span><br><span class="line"></span><br><span class="line">la t0, result</span><br><span class="line">sw t6, 0(t0)</span><br><span class="line"></span><br><span class="line">li a7, 4 # 4号调用打印字符串</span><br><span class="line">la a0, msg	# a0是参数, 加载字符串的首地址即可</span><br><span class="line">ecall</span><br><span class="line"></span><br><span class="line">li a7, 1</span><br><span class="line">mv a0, t6</span><br><span class="line">ecall</span><br></pre></td></tr></table></figure>
<p>g是一个标签, 表示存储 数据 <code>0</code> 的那一段内存的首地址. <code>.word</code> 表示长度4字节. <code>.string</code> 表示是字符串.</p>
<p><code>la</code> 伪指令, 获得标签指示的内存的首地址</p>
<p><code>lw</code> 加载一个字.</p>
<p><code>0(t0)</code> 是RISC-V的寻址模式, 基址加偏移量.</p>
</li>
<li>
<p><code>array.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">numbers: .word -30, 30, -20, 20, -10, 10, 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la t0, numbers</span><br><span class="line">lw t1, 12(t0)  # numbers[3]</span><br><span class="line">addi t1, t1, 80</span><br><span class="line">sw t1, 12(t0)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>branch-max.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># c = max(a, b)</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">a: .word 100</span><br><span class="line">b: .word 200</span><br><span class="line">c: .word 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">lw t0, a</span><br><span class="line">lw t1, b</span><br><span class="line"></span><br><span class="line">bge t0, t1, greater_equal # br if t0 &gt;= t1</span><br><span class="line">mv t2, t1</span><br><span class="line">j end</span><br><span class="line"></span><br><span class="line">greater_equal:</span><br><span class="line">mv t2, t0</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">la t3, c</span><br><span class="line">sw t2, 0(t3)</span><br></pre></td></tr></table></figure>
<p><code>bge</code>: 伪指令, &lt;= , 跳转</p>
<p><code>j</code> : 伪指令, 无条件跳转</p>
</li>
<li>
<p><code>for.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 求数组中所有 正数 / 负数 之和</span><br><span class="line">.data</span><br><span class="line">numbers: .word -30, 30, -20, 20, -10, 10, 0</span><br><span class="line">size: .word 7</span><br><span class="line"></span><br><span class="line">positive_sum: .word 0</span><br><span class="line">negative_sum: .word 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la t0, numbers</span><br><span class="line">lw t1, size</span><br><span class="line"></span><br><span class="line">mv t2, zero # counter: i = 0</span><br><span class="line"></span><br><span class="line">li t3, 0 	# positive_number</span><br><span class="line">li t4, 0	# negative_number</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	bge t2, t1, end_loop</span><br><span class="line">	# numbers[i]</span><br><span class="line">	slli t5, t2, 2 # 即: mul t5, t2, 4</span><br><span class="line">	add t5, t0, t5</span><br><span class="line">	lw t5, 0(t5)  # numbers[i]</span><br><span class="line">	</span><br><span class="line">	addi t2, t2, 1</span><br><span class="line">	</span><br><span class="line">	bltz t5, negative  # br if less than zero</span><br><span class="line">	# positive</span><br><span class="line">	add t3, t3, t5</span><br><span class="line">	j loop</span><br><span class="line">	</span><br><span class="line">negative:</span><br><span class="line">	add t4, t4, t5</span><br><span class="line">	j loop</span><br><span class="line">	</span><br><span class="line">end_loop:</span><br><span class="line">	la t5, positive_sum</span><br><span class="line">	sw t3, 0(t5)</span><br><span class="line">	la t5, negative_sum</span><br><span class="line">	sw t4, 0(t5)</span><br></pre></td></tr></table></figure>
<p><code>slli</code> shift logical left immediate 逻辑左移一个立即数</p>
</li>
<li>
<p>riscv函数实现:</p>
<p><code>max.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">max_result: .word 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl main # the program entry</span><br><span class="line"></span><br><span class="line">max:</span><br><span class="line"># (3) get arguments (natrually)</span><br><span class="line"></span><br><span class="line"># (4) computing</span><br><span class="line">blt a0, a1, smaller</span><br><span class="line">j end_max</span><br><span class="line"></span><br><span class="line">smaller:</span><br><span class="line">mv a0, a1 	# 约定: a0, a1用作返回值寄存器.</span><br><span class="line"></span><br><span class="line">end_max:</span><br><span class="line">ret</span><br><span class="line">#jr ra</span><br><span class="line">#jalr zero 0(ra)  # jalr: jump and link register, link =&gt; save (pc + 4) in register &lt;zero&gt;</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">a: .word 100 # 定义全局数据变量</span><br><span class="line">b: .word 200</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line"># (1) preparing the arguments (a0, a1, ..., a7), 传参</span><br><span class="line">lw a0, a</span><br><span class="line">lw a1, b</span><br><span class="line"></span><br><span class="line"># (2) call the max function</span><br><span class="line">call max # jal max</span><br><span class="line">#jal ra, max   # jal: jump and link (jump: ra &lt;- pc + 4; pc &lt;- &amp;max)</span><br><span class="line"></span><br><span class="line"># (5) get return value</span><br><span class="line">sw a0, max_result, t0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>需要用到栈的例子:</p>
<p>(递归) <code>fact.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">factorial: </span><br><span class="line">beqz a0 base_case:</span><br><span class="line"></span><br><span class="line">addi sp, sp, -8</span><br><span class="line">sw a0, 4(sp)</span><br><span class="line">sw ra, 0(sp) # it&#x27;s key to save ra if call chain&#x27;s length &gt; 1</span><br><span class="line"></span><br><span class="line"># n &gt; 0: n * factorial(n - 1)</span><br><span class="line">addi a0, a0, -1 # no subi</span><br><span class="line">call factorial # get value -- factorial(n - 1) in a0</span><br><span class="line">mv t0, a0      # save ret value in t0</span><br><span class="line"></span><br><span class="line">lw a0, 4(sp)</span><br><span class="line">lw ra, 0(sp)</span><br><span class="line">addi, sp, sp, 8</span><br><span class="line"></span><br><span class="line">mul a0, a0, t0</span><br><span class="line">j end</span><br><span class="line"></span><br><span class="line">base_case:</span><br><span class="line">	li a0, 1</span><br><span class="line"></span><br><span class="line">end:	</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">## main ##</span><br><span class="line">.data</span><br><span class="line">n: .word 10 </span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">lw a0, n</span><br><span class="line">call factorial</span><br></pre></td></tr></table></figure>
<p>一般栈的空间的布局如下:</p>
<p>从高到低:</p>
<p>保存参数寄存器</p>
<p>保存返回地址寄存器 (ra)</p>
</li>
<li>
<p>复杂的例子: 中序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">tree_sum</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tree_node *node)</span> &#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        result += tree_sum(node-&gt;left);</span><br><span class="line">        result += node-&gt;value;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree_node</span> <span class="title">t</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">long</span> sum = tree_sum(&amp;t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">tree_sum:                               # @tree_sum</span><br><span class="line">        addi    sp, sp, -16</span><br><span class="line">        sw      ra, 12(sp)                      # 4-byte Folded Spill</span><br><span class="line">        sw      s0, 8(sp)                       # 4-byte Folded Spill</span><br><span class="line">        sw      s1, 4(sp)                       # 4-byte Folded Spill</span><br><span class="line">        beqz    a0, .LBB0_3</span><br><span class="line">        mv      s0, a0</span><br><span class="line">        li      s1, 0</span><br><span class="line">.LBB0_2:                                # =&gt;This Inner Loop Header: Depth=1</span><br><span class="line">        lw      a0, 0(s0)</span><br><span class="line">        call    tree_sum</span><br><span class="line">        lw      a1, 8(s0)</span><br><span class="line">        lw      s0, 4(s0)</span><br><span class="line">        add     a1, a1, s1</span><br><span class="line">        add      s1, a0, a1</span><br><span class="line">        bnez    s0, .LBB0_2</span><br><span class="line">        j       .LBB0_4</span><br><span class="line">.LBB0_3:</span><br><span class="line">        li      s1, 0</span><br><span class="line">.LBB0_4:</span><br><span class="line">        mv      a0, s1</span><br><span class="line">        lw      ra, 12(sp)                      # 4-byte Folded Reload</span><br><span class="line">        lw      s0, 8(sp)                       # 4-byte Folded Reload</span><br><span class="line">        lw      s1, 4(sp)                       # 4-byte Folded Reload</span><br><span class="line">        addi    sp, sp, 16</span><br><span class="line">        ret</span><br><span class="line">main:                                   # @main</span><br><span class="line">        addi    sp, sp, -16</span><br><span class="line">        sw      ra, 12(sp)                      # 4-byte Folded Spill</span><br><span class="line">        lui     a0, %hi(.L__const.main.t)</span><br><span class="line">        lw      a1, %lo(.L__const.main.t)(a0)</span><br><span class="line">        addi    a0, a0, %lo(.L__const.main.t)</span><br><span class="line">        lw      a2, 8(a0)</span><br><span class="line">        lw      a0, 4(a0)</span><br><span class="line">        sw      a1, 0(sp)</span><br><span class="line">        sw      a2, 8(sp)</span><br><span class="line">        sw      a0, 4(sp)</span><br><span class="line">        mv      a0, sp</span><br><span class="line">        call    tree_sum</span><br><span class="line">        mv      a1, a0</span><br><span class="line">        lui     a0, %hi(.L.str)</span><br><span class="line">        addi    a0, a0, %lo(.L.str)</span><br><span class="line">        call    printf</span><br><span class="line">        li      a0, 0</span><br><span class="line">        lw      ra, 12(sp)                      # 4-byte Folded Reload</span><br><span class="line">        addi    sp, sp, 16</span><br><span class="line">        ret</span><br><span class="line">.L__const.main.t:</span><br><span class="line">        .word   0</span><br><span class="line">        .word   0</span><br><span class="line">        .word   3                               # 0x3</span><br><span class="line"></span><br><span class="line">.L.str:</span><br><span class="line">        .asciz  &quot;sum = %ld&quot;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h1>codegen-isel</h1>
<ol>
<li>指令选择问题实际上是一个组合优化问题. (在理论上是 NP-hard 问题)</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaos-warzh.github.io">Zhaohui Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaos-warzh.github.io/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">https://chaos-warzh.github.io/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaos-warzh.github.io" target="_blank">chaos-warzh's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/08/22/2024%E6%AF%95%E6%98%87%E6%9D%AF%E6%80%BB%E7%BB%93/" title="2024毕昇杯总结.md"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">2024毕昇杯总结.md</div></div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhaohui Wang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chaos-warzh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/chaos-warzh" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>(2024-03-02) <br> Thank you for visiting my website! <br> I am an undergraduate student with a passion for exploring languages, logic, and software craftsmanship. </p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">intro</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">ANTLR 4</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Lexer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Lexer Analysis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">parser-antlr</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">parser: context-free</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">parser - ll</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">parser - Adaptive LL(*)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">parser-lr(0)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">parser-lr(1)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">semantics - symtable</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">semantics - ag</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">LLVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">ir-expr</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">ir-control</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">ir-backpatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">codegen - RISC V</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">codegen-isel</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/25/2024-NJUSE-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="2024-NJUSE-编译原理">2024-NJUSE-编译原理</a><time datetime="2025-02-25T06:50:49.000Z" title="发表于 2025-02-25 14:50:49">2025-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/22/2024%E6%AF%95%E6%98%87%E6%9D%AF%E6%80%BB%E7%BB%93/" title="2024毕昇杯总结.md">2024毕昇杯总结.md</a><time datetime="2024-08-22T14:24:48.000Z" title="发表于 2024-08-22 22:24:48">2024-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/18/RISC-V%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90%E8%B8%A9%E5%9D%91/" title="backend-bugs">backend-bugs</a><time datetime="2024-07-17T17:53:21.000Z" title="发表于 2024-07-18 01:53:21">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/Compilers%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/" title="Compilers 框架指南">Compilers 框架指南</a><time datetime="2024-05-30T10:01:30.000Z" title="发表于 2024-05-30 18:01:30">2024-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/04/Golang%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Golang复习笔记">Golang复习笔记</a><time datetime="2024-03-04T06:02:53.000Z" title="发表于 2024-03-04 14:02:53">2024-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zhaohui Wang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23ct3SpmblpGh2sl5A',
      clientSecret: '6a7a97e8ec634f5540e2964c1d00806f929aa6d7',
      repo: 'gitalk-comments',
      owner: 'chaos-warzh',
      admin: ['chaos-warzh'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'a6f8fd176a9fa96657f3c69ce363aa1e'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>