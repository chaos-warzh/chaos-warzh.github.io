<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言复习笔记</title>
    <link href="/2024/03/02/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/02/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言复习笔记"><a href="#C语言复习笔记" class="headerlink" title="C语言复习笔记"></a>C语言复习笔记</h1><h2 id="Lesson-1-输入输出"><a href="#Lesson-1-输入输出" class="headerlink" title="Lesson 1: 输入输出"></a>Lesson 1: 输入输出</h2><ol><li><p>program程序 Operations运算符 expressions表达式 statements语句</p></li><li><p>理解第一个程序<code>hello.c</code>的各个部分：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">#<span class="hljs-keyword">include</span> : preprocessor directive 预处理指令<br>main: <span class="hljs-function"><span class="hljs-keyword">function</span></span> 函数<br><span class="hljs-built_in">int</span> main(): takes no arguments, <span class="hljs-keyword">return</span> an <span class="hljs-keyword">integer</span> 无参数, 返回整型<br>main: .c <span class="hljs-keyword">contains</span> one and <span class="hljs-keyword">only</span> one main <span class="hljs-function"><span class="hljs-keyword">function</span></span> 一个.c文件有且仅有一个main函数<br>printf: <span class="hljs-built_in">print</span>+f: <span class="hljs-keyword">format</span> 格式化输出<br></code></pre></td></tr></table></figure></li><li><p><strong>%f或者%lf都表示匹配输出double类型的值；但是scanf输入只能使用%lf匹配</strong></p></li><li><p>如果是输入输出的是long double类型, 对应的格式串是 <code>%Lf</code>. </p></li><li><p><code>const double PI;</code>  定义常量, 常量要全大写命名。</p></li><li><p>% 和 f 中间可以有一些东西. 例如<code>%10.2f</code>这里的点不是小数点, 而是分隔的意思, 10表示字段的宽度为 10 个字符, 如果浮点数本身不足 10 个字符, 那么会在左侧用空格填充; 2表示小数点后要保留2位数字. </p></li><li><p><strong><code>%.2d</code> 或 <code>%02d</code> &#x2F;&#x2F; 最少这个整数要输出2个数字，不足则前面补0</strong></p><p><code>%.2s</code> &#x2F;&#x2F; 输出前2个字符 (如果不足2个字符就有多少输出多少), 空字符在尾部补齐</p><p><code>%2s</code> &#x2F;&#x2F; 输出长度为<strong>至少为2</strong>的字符串, 不够就在前面补空格 </p></li><li><p>注意字符串<strong>定义时要多定义一位</strong>，因为字符串的最后是\0,</p><p>例如: <code>char first_name[5] = &quot;Tayu&quot;;</code> </p></li><li><p><strong>%c在匹配用户输入的时候不会忽略空白符，所以要注意在scanf中就要加入空白符以匹配掉0到任意个空白符。</strong>     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s %c&quot;</span>,                               <br>     first_name, last_name, &amp;gender);       <br></code></pre></td></tr></table></figure></li><li><p>字符串越界, 会出现UB. 所以要用<code>%9s</code> 限制输入的最长长度。</p></li><li><p><code>%*lf</code>的意思是虽然让你输入, 但是变量该是什么还是什么. 这样的话<code>scanf(“%*f”,&amp;a);</code>用来输入double类型也是可以的。</p></li><li><p><code>printf</code> 默认遇到 ‘\0’ 就会停止打印.</p></li><li><p><code>pow</code>函数: 注意可能引起报错,  <strong>底数 a为负数并且指数 b 不是整数</strong>, 将会导致 domain error 错误</p></li></ol><h2 id="Lesson-2-if-for-array"><a href="#Lesson-2-if-for-array" class="headerlink" title="Lesson 2: if-for-array"></a>Lesson 2: if-for-array</h2><ol><li><p>要养成<strong>分行定义多个变量</strong>的编码风格. </p></li><li><p>变量在声明的时候一定尽可能给一个初始值, <code>int a = 0;</code></p></li><li><p>较小数程序: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a &gt;= b) &#123;<br>  min = b;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  min = a;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>? : &#x2F;&#x2F;Ternary Operator 三目运算符</p></li><li><p>输出单个字符也要用””, 因为是字符串:  <code>printf(&quot;A&quot;);</code></p></li><li><p>undefined behavior：未定义行为</p><p>例: </p><p><code>char a;</code></p><p><code>scanf(&quot;%d&quot;, &amp;a);</code></p><p>就是一个undefined behavior (UBs)</p><p>c语言标准没有规定发生什么情况, 出现任何情况都有可能, 这取决于编译器厂商.</p><p>所以, <em><strong>Avoid UBs! ! !</strong></em></p></li><li><p>用<strong>宏定义</strong>的常量叫<em><strong>符号常量</strong></em>, <code>const</code>关键字定义的叫字面常量. </p><p><strong>推荐所有的数组长度</strong>都用宏定义的符号常量</p></li><li><p>可变长数组: </p><p><code>int n;</code></p><p><code>int a[n];</code></p><p>这样做是<em><strong>非常不推荐的</strong></em></p></li><li><p><input disabled="" type="checkbox"> : subscript operator (下标运算符)</p></li><li><p>数组访问越界错误, 经典的UB, 编译器会悄无声息地换成另一个值. </p></li><li><p>for循环的第一部分 int i &#x3D; 1; 可以是一个定义(C99以后才可以).</p></li><li><p>下标0的元素可以被赋值一个不影响后面元素的值 , 后面所有其余元素<strong>自动被赋值为0</strong>.</p></li><li><p>一个变量有左值和右值, i &#x3D; 1; &#x2F;&#x2F;左值， 指代的是<em><strong>i所在的空间</strong></em></p><p>j &#x3D; i; &#x2F;&#x2F;右值，指的才是它<em><strong>真正的值</strong></em>   </p></li><li><p><code>int num[] = &#123;0&#125;;</code>这样只是开了一个元素, 不要以为开了任意个. 并且也不要不写长度.</p></li><li><p><code>int num[20] = &#123;[2] = 1&#125;;</code>这种写法是可以的</p></li><li><p><code>int  numbers[NUM] = &#123;&#125;;</code>什么都没有, 标准上这样<strong>不允许</strong>.</p></li><li><p>不推荐不对数组初始化.</p></li><li><p>如果<strong>字符数组</strong>不初始化(即在等号后面写上字面量的话), 那么它是什么值都有可能(<strong>每个元素都是垃圾值</strong>), 且**最后一位也&#x3D;&#x3D;不是’\0’&#x3D;&#x3D;**而是垃圾值. 所以要么就给出字面量, 要么就使用<code>sprintf</code>初始化, 否则自己一定记得把结尾后面的元素手动写成’\0’.  (另: <code>memset(str, 0, strlen(str))</code>是毫无问题的字符串初始化为全零的操作)</p></li></ol><h2 id="Lesson-3-for-while"><a href="#Lesson-3-for-while" class="headerlink" title="Lesson 3: for-while"></a>Lesson 3: for-while</h2><ol><li><p>VLA: variable-length array 可变长数组  C99 introduces VLA</p><p>C11 makes it optional 也就是说C11又把它去掉了(也就是说有没 有取决于编译器)</p><p>而且VLA在声明时不需要(也不支持)初始化</p></li><li><p>每写一段代码之后就应当下意识去运行一下, 以免错误积累… </p></li><li><p>如何输入任意次直到EOF: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> len = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;numbers[++len]) != EOF); <span class="hljs-comment">//先加，再判断。len++就是先判断再加</span><br></code></pre></td></tr></table></figure><p>这个操作值得掌握.</p></li><li><p>do-while 语句: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">//注意这里有一个分号, 不要忽略了</span><br></code></pre></td></tr></table></figure></li><li><p>程序员在写代码时不要太聪明 (不是说不设计一个好的算法) , 是说要让代码可读且简单.</p></li><li><p>写代码就像写诗 – 多换行. </p></li><li><p>在合适的场景多用<strong>布尔变量</strong>.</p></li><li><p><strong>scanf是有返回值的.</strong> 一般来说, <strong>匹配了几个就返回几</strong>.</p><p><code>%d%d%d, &amp;a, &amp;b, &amp;c</code></p><p>如果输入 1 2就返回2</p><p>如果输入 abc 不能匹配, 就返回0</p><p>如果是   “          “   这样的空输入就返回EOF, (end of file, 文件结束符, 一般来说其值&#x3D; -1 )</p></li><li><p>读取int数组: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    arr[i++] = n;<br>  &#125; <span class="hljs-keyword">while</span>( getchar() != <span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>读取字符串:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>( (<span class="hljs-built_in">string</span>[i++] = getchar()) != <span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">// 读入一个无换行的字符串,美中不足是最后一个位置会是&#x27;\n&#x27;(垃圾值)</span><br></code></pre></td></tr></table></figure></li><li><p><code>strlen()</code> 返回字符串长度</p></li><li><p><code>memset()</code> 只能初始化值为<strong>0和-1</strong></p></li></ol><h2 id="Lesson-4-多维数组"><a href="#Lesson-4-多维数组" class="headerlink" title="Lesson 4: 多维数组"></a>Lesson 4: 多维数组</h2><ol><li><p><code>game-of-life.c</code> 中涉及的系统调用: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//表示暂停的毫秒 ，在windows.h头文件下</span><br><br>system(<span class="hljs-string">&quot;cls&quot;</span>);  <span class="hljs-comment">//清屏</span><br><br><span class="hljs-comment">//Linux</span><br>sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">//表示暂停的秒数; 在unistd.h下</span><br>system(<span class="hljs-string">&quot;clear&quot;</span>); <span class="hljs-comment">// 在stdlib.h下</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033c&quot;</span>); <span class="hljs-comment">// 清空</span><br></code></pre></td></tr></table></figure></li><li><p>二维数组实现上下左右移动: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> vectors[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;  <span class="hljs-comment">// vector[i][j]可以认为是第i组里面的第j个元素</span><br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k) &#123;<br>    <span class="hljs-type">int</span> newI = i + vectors[k][<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> newJ = j + vectors[k][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (arr[newI][newJ] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123; <span class="hljs-comment">// 实现上下左右方向的统计雷的个数</span><br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Special-Lesson-Learning-debug"><a href="#Special-Lesson-Learning-debug" class="headerlink" title="Special Lesson: Learning debug"></a>Special Lesson: Learning debug</h2><blockquote><p>Don’t be too afraid, and learn from coding!</p></blockquote><ol><li><p><strong>debugging</strong>思想: 削减到最小出现bug的问题 (以方便集中注意力debug, 如果你不能debug, 那么至少你要先把bug的出现域缩小, 你可以另写一个函数, 最好就几行, 以便锁定bug, 节省自己和别的帮你debug的人的精力!) – by Mr. Niu</p></li><li><p>编写测试代码, 调用检查函数, 尝试发现到底错在哪里. </p></li><li><p>有用的检查错误命令: </p><ol><li><p>gcc -Wall hello.c</p></li><li><p>gcc -Wall -Werror hello.c</p></li><li><p>clang -Wall hello.c</p></li></ol></li><li><p>运行时内存检查: gcc -fsanitize&#x3D;address hello.c 可以看到泄漏的内存总大小 &#x2F; 泄漏位置, 有用极了. </p></li><li><p>函数性能分析 Linux 下用 <code>perf</code></p></li></ol><h2 id="Lesson-5-函数"><a href="#Lesson-5-函数" class="headerlink" title="Lesson 5: 函数"></a>Lesson 5: 函数</h2><ol><li><p>函数名命名使用大驼峰 (谷歌). </p></li><li><p>形参可以和实参同名. </p></li><li><p>避免全局变量. </p></li><li><p><code>int IsPrime(int number);</code></p><p>函数先声明, 后定义. </p></li><li><p><code>int BinarySearch(int key, int dict[], int len);</code> &#x2F;&#x2F; 这里的形参不能不写上数组长度.</p></li><li><p><code>int BinarySearch(int key, const int dict[], int len)</code></p><p>如果你不想修改数组， 那么传入时一定要用**<code>const</code>**修饰. </p></li><li><p>多维数组传值: 一定要写<strong>除了第一维以外所有维</strong>的数值, 如:arr[] [][][][[LEN] [LEN][LEN]</p></li><li><p>在函数定义上面写 &#x2F;** 加回车, 以对函数功能及参数含义作注解. </p></li><li><p>C语言只有传值, 以传地址的值的方法来实现传引用.</p></li><li><p>无参数输入的函数声明: int Fun(void);   C语言的老特性, 不能省略<strong>void</strong>, 否则可能出问题. 但是C++等其它语言则不需.</p></li></ol><h2 id="Lesson-6-递归"><a href="#Lesson-6-递归" class="headerlink" title="Lesson 6: 递归"></a>Lesson 6: 递归</h2><ol><li><p>how? C语言语法支持自调用甚至可以调用main函数自己 (c++就不能自调用main).</p></li><li><p>why? 适用情景: 解决问题时又遇到了和原问题差不多的问题.</p></li><li><p>会不会一直递归下去, 无穷无尽? 有可能.</p></li><li><p>要<strong>用递归的思维去思考问题</strong>: 子任务是比原来任务规模更小的任务, 直到最后碰到了一个最小的任务, 然后把它直接解决掉. (困难, 需要有意识训练, 需要花很长很长的时间).</p></li><li><p>训练递归思维 (Ask the mirror right questions) :  </p><p>a) &#x3D;&#x3D;What is a smaller task?&#x3D;&#x3D; (更小的问题是什么?) </p><p>b) How to solve the task given the solution to the smaller one? (如果知道了小问题的解, 怎么推出原问题的解?)</p><p>c) What is the smallest task? (最小规模的任务是什么?)</p></li><li><p>像一个计算机一样思考, 理解递归的底层实现. </p></li><li><p>栈空间(Stack), 堆空间(Heap), 栈帧(Stack Frame): </p><p><strong>Stack</strong></p><table><thead><tr><th>main                            (bottom)</th></tr></thead><tbody><tr><td>a  25                          |</td></tr><tr><td>b  37                          |</td></tr><tr><td>min 25                    (top)</td></tr></tbody></table><table><thead><tr><th>min</th></tr></thead><tbody><tr><td>a  25</td></tr><tr><td>b  37                    (new top)</td></tr></tbody></table><p>栈空间(用以存储局部变量), 生长的方向是从上往下(自底向顶).</p><p>调用一个函数时,会**为这个函数准备一个栈帧 ** 栈帧存储局部变量. 函数结束后, 栈帧消失.</p></li></ol><p>​   遵循FILO的一个结构. 最后调用的最先消失, 先是往栈空间不断压栈帧的过程, 后是不断弹出栈帧的过程.</p><ol start="8"><li><p>想要更深入理解栈空间&#x2F;堆空间, 请移步<em>计算机系统基础</em>. </p></li><li><p>注意函数里变量的生命周期问题, 函数里的数组如果是在栈空间里, 那么<strong>这个数组会随着函数的结束而消失</strong>, 所以你无法通过<code>&#123;int a[1005]; ... return a;&#125;</code>来用返回这个数组的首地址的方式试图返回这个数组&#x2F; 字符串字面量. </p><p>解决方案 1. <code>malloc</code>函数申请堆空间, 但是要注意判断是否申请成功, 且调用者须把空间free掉.    2. 操作外面的数组 (传入的&#x2F; 全局的)</p></li></ol><h2 id="Lesson-7-数据类型"><a href="#Lesson-7-数据类型" class="headerlink" title="Lesson 7: 数据类型"></a>Lesson 7: 数据类型</h2><ol><li><p>基础数据类型 int double char bool</p></li><li><p>聚合数据类型 []</p></li><li><p>整型 short (int) , int(至少4个字节), long (int), long long (int) (至少8个字节)  只是不会减少, 但不一定严格递增        signed vs. unsigned</p></li><li><p>printf函数 无符号整型<code>%u</code>, 有long就加一个l <code>printf(&quot;ULONG_MAX = %lu\n\n&quot;, ULONG_MAX);</code></p></li><li><p>有符号整数溢出是UB, 无符号整数溢出会发生<strong>回绕现象</strong>.</p></li><li><p>size_t 就是一个unsigned long long. 输出时使用%zu</p></li><li><p>混用有符号和无符号就会出错 -1 &gt; 256(unsigned). 所以尽量不要用无符号, 除非你很有把握不会与有符号数比较. (有符号会被隐式转换成无符号的)</p></li><li><p>注意 可以使用<code>typedef unsigned long long int size_t</code></p></li><li><p>如果只写一个char, 无从得知是有符号还是无符号. (看具体系统)</p></li><li><p>隐式类型转换  (1) 算术&#x2F;逻辑表达式(类型提升)   (2)定义初始化, 赋值(类型转换)    (3)函数调用时(类型转换)    (4)函数赋值时(类型转换)  </p></li><li><p>想要明确表示是float 后缀要加F. <code>float pi = 3.1415926F</code> 不加F的话就不是float, 默认是double.</p></li><li><p>long double 的话后缀加L.</p></li><li><p>在C语言中, <strong>0开头的数字为八进制数</strong>, 010就是十进制的8.</p></li><li><p>epsilon 表示浮点数所能表示的两个最近的能精确表示的数字之间的gap. (这个gap不可能为0, 为什么?)</p></li><li><p>浮点数实在太复杂, 但是好在我们实际上基本用不到. (如: 做web开发就几乎和浮点数无任何关系)</p></li><li><p>浮点数表示能力不够的情况除了overflow还有underflow也就是太接近0了, 无法表示(且这个gap一定会存在).</p></li></ol><h2 id="Lesson-8-指针"><a href="#Lesson-8-指针" class="headerlink" title="Lesson 8: 指针"></a>Lesson 8: 指针</h2><ol><li><p><code>printf(&quot;%p&quot;, &amp;radius);</code> &#x2F;&#x2F; 打印地址变量(指针)要用<code>%p</code>, 其输出为一个十六进制数</p></li><li><p>存储的其实是int类型中<strong>4个连续字节</strong>的<em><strong>首地址</strong></em>, 而不是一个字节一个字节地存储. 拿到这个首地址就可以根据int这个变量类型来解析出那4个所要的字节.</p></li><li><p><span id="jump"><em><strong>左值与右值</strong></em>, 等号左边叫左值, 代表变量所在的一块***&#x3D;&#x3D;存储空间&#x3D;&#x3D;***(not the first address), 而右值代表空间里的那个内容</span></p><p>所以, 我们可以使用 <code>(*ptr) = 20;</code> 这样的语句来给所指的变量赋值</p></li><li><p><code>int a = 0;</code> <strong>直接访问</strong>a, 或者可以<code>int *prt = &amp;a</code>;  访问*p来<strong>间接访问</strong>a</p></li><li><p><code>*</code> 叫作**”解引用运算符”**或者”间接寻址运算符”.</p></li><li><p>&#x3D;&#x3D;**动态数组: **&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> *numbers = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// (老版本 / C++)需要强制类型转换, 因为malloc返回值是void型; 且返回的是整块内存的首地址(所以使用指针变量来存).</span><br><br><span class="hljs-type">int</span> *numbers = <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(*numbers)); <span class="hljs-comment">// 本质上就是数组声明</span><br><br><span class="hljs-comment">// recommended way</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;numbers[i]);<br>  &#125; <span class="hljs-comment">// 把这块连续的空间当成数组使用(也可作其他用途)</span><br></code></pre></td></tr></table></figure></li><li><p>如果写<code>int *prt = ... </code>那么其实是无法判定指向的是一个int型变量还是一个以此变量开头的数组(需要C程序员自己清楚). </p></li><li><p>&#x3D;&#x3D;<em><strong>指针与数组</strong></em>&#x3D;&#x3D;  数组名即是数组第一个元素的地址(指向int的一个指针) 所以, 可以把指向一块内存空间的首个元素的指针名接作为数组名使用. </p><p>即 <code>numbers[i]</code> 就等价于 <code>*(numbers + i)</code></p><p>​<code>&amp;numbers[i]</code> 等价于  <code>numbers + i</code></p><p>数组的名字<strong>本质上不是一个变量</strong>, 而永远都是这个数组首元素的地址.我们只能取它的值, 而不能修改它(<strong>右值</strong>).</p><p>如果硬想把它变成一个变量, 则再定义一个指针等于它. <code>int *prt = arr;</code></p></li><li><p>指针的加法 <code>*(numbers + 1)</code> 并不是在数值上加1, 而是说一次跳过一块内存. (区别于普通的整数运算)</p></li><li><p>类似的, <em><strong>指针和指针可以相减</strong></em>, 不可以相加, 相减结果表示连续的一块内存地址两个地址之间相差的元素数. (<strong>注意不是字节数</strong>)</p></li><li><p>那么<code>arr[i]</code> 就是 <code>*(arr + i)</code> 就是 <code>*(i + arr)</code> 就是 <code>i[arr]</code> &#x2F;&#x2F; 但是你不要这么写, 码风不好. </p></li><li><p>另外<code>&amp;arr[i]</code> 就是 <code>&amp;(*(arr + i))</code> 就是 <code>arr + i</code>  </p></li><li><p>动态内存申请的空间用完了还需要还回去. </p><p>为什么要还, 因为此空间<strong>不是存在栈帧里的, 而是在堆上面</strong></p><p>如果不free的话, 申请这块内存的指针已经没了, 但是内存里这块空间还被占据着, 没人能够再访问它. 发生<strong>内存泄漏</strong> (引用这块内存的指针变量已经没有了但是没有释放被引用的内存)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(numbers); <span class="hljs-comment">// 注意: 同一块内存不能free两次</span><br></code></pre></td></tr></table></figure><p>Q: 怎么分析是否一块内存是否被free了两次, 这其实是无法<strong>静态分析</strong>出的. </p></li><li><p>如果不是堆空间不可free.</p></li><li><p>申请内存有可能失败, 失败就返回一个空指针.(指向NULL的指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (numbers == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 就是空指针</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error; No dynamic memory any more.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>calloc</code> : malloc 之后赋予所有元素0, 而非垃圾值</strong></p><p><code>realloc</code> : 重新申请一个内存, 并且把原来的数组已有值赋给现在的内存. </p></li><li><p><strong>指针和字符串</strong> 1) 声明 char msg[20] &#x3D; “Hello World!”;     也可以    char *msg &#x3D; “Hello World!”;  </p><p>​2) 默认的<strong>使用指针定义的字符串字面量不可以修改</strong>char *msg &#x3D; “Hello World!”;    msg[0] &#x3D; “N”;  &#x2F;&#x2F; 这是UB</p><p>​                        3) 但是如果用数组定义字符串字面量就可以修改 char msg[20] &#x3D; “Hello World!”;   msg[0] &#x3D; “N”;  &#x2F;&#x2F; 允许</p></li><li><p>()++的优先级高于*, (<strong>至于++(), 和 * 优先级相同</strong>) 所以以下语句先让<code>str++</code>, 且<code>str++</code>返回的是自增之前的值(不同于<code>++str</code>).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">＊str++ != <span class="hljs-string">&#x27;\0&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>const char ＊str</code> 作为参数的意思是, <strong>不允许通过str这个指针来修改它指向的字符</strong>, 不等同于不能修改这个字符本身. </p></li><li><p><code>const char ＊str</code> 和 <code>char const ＊str</code> 是一样的, 限制str指针所指向的字符不能修改. 但是, <code>char * const str</code> 就不同了, 它限制了str 这个指针是一个常量指向char类型,  限制指针不能被修改 (即<code>str++</code>不允许)</p></li><li><p><code>size_t</code> 是什么类型, 可以理解成无符号长长整型, 且与机器无关, 配合**%zu**使用. </p></li><li><p><strong>指针是怎么来的?</strong> 1) 所有的数据存放在内存里 2) 内存可以编号, 即地址, 通过地址可访问内容 3) 一个数据类型占有若干个byte(字节), 那么把其占据的几个byte的第一个byte的地址作为指针的值.</p></li></ol><h2 id="Lesson-9-指针高级"><a href="#Lesson-9-指针高级" class="headerlink" title="Lesson 9: 指针高级"></a>Lesson 9: 指针高级</h2><ol><li><p><code>strcpy</code>: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">StrCpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span> &#123;<br>  <span class="hljs-keyword">while</span> ((*dest++ = *src++)); <span class="hljs-comment">// 写成指针, 去掉循环控制变量, &#x27;\0&#x27; 的ascii就是 0</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>strncmp</code>: 比较两个字符串中的最多前n个字符 </p></li><li><p>指针数组: 每个元素是一个指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *names[LEN] <span class="hljs-comment">//指针数组定义</span><br><br>Swap(&amp;str[i], &amp;str[min_index]); <br><span class="hljs-comment">// 相应的, 要再取一次地址, 才能传入一个二级指针</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">char</span> **left, <span class="hljs-type">char</span> **right)</span> &#123;<br>  <span class="hljs-type">char</span> *tmp = *left; <span class="hljs-comment">// left 实际上是二级指针, 用 * 解一次引用解出来一个指向char的指针</span><br>  *left = *right; <span class="hljs-comment">// 这样修改的是指向字符串字面量的指针</span><br>  *right = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于多维数组, 你只需要记住: <strong>C语言没有二维数组, 只有数组的数组.</strong></p><p>二维数组是一个指向数组的指针, 二维数组是一个二级指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> score[ROWS][COLS] = <span class="hljs-built_in">malloc</span>(ROWS * COLS * <span class="hljs-keyword">sizeof</span> **score); <span class="hljs-comment">// 感觉不如写sizeof(int)</span><br><span class="hljs-keyword">if</span> (score == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>运算符优先级</strong> : </p><p>​(suffix)++, (), [], <strong>.</strong> , -&gt; </p><p>​                        ++(prefix) , * , &amp; , ! , <strong>~</strong> , sizeof</p><p>​*, &#x2F;, %</p><p>​+, -</p><p>​&lt;&lt;, &gt;&gt;</p></li><li><p>[] &#x2F;&#x2F; 取数组下标符具有左结合性, 即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> student_score_table[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>] = &#123;<br>      &#123;<span class="hljs-number">0</span>,  <span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;,<br>      &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;,<br>      &#123;<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;,<br>      &#123;<span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;,<br>      &#123;<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;<br>  &#125;; <span class="hljs-comment">// 可以理解为是一个大小为5的数组, 数组里面是一个大小为3的数组</span><br><br><span class="hljs-comment">/**指针访问二维数组*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_score_table[3][2] = %d\n&quot;</span>,<br>         student_score_table[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_score_table[3][2] = %d\n&quot;</span>,<br>         (*(student_score_table + <span class="hljs-number">3</span>))[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_score_table[3][2] = %d\n&quot;</span>,<br>         (*(*(student_score_table + <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>)));<br></code></pre></td></tr></table></figure></li></ol><h2 id="Lesson-10-函数指针-结构体"><a href="#Lesson-10-函数指针-结构体" class="headerlink" title="Lesson 10: 函数指针&#x2F;结构体"></a>Lesson 10: 函数指针&#x2F;结构体</h2><ol><li><p>main函数里面是可以有参数的, main函数可以接受两个参数 <code>argc</code> (argument count计数, 调用了几个参数) 和 <code>argv</code> (argument vector) 一个数组, 数组里每个元素是一个指针, 指向char.</p><p><code> int main(int argc, char *argv[]) &#123;&#125;</code></p></li><li><p>C语言中约定<code>argv[0]</code>存储了程序的名字(argv[0] is the name of program)(当然一些环境或操作系统中<code>argv[0]</code>是一个空指针, 不存放任何东西但是占了位), 所以<strong>真正的存入argv[]是从下标1开始存入的</strong>.</p></li><li><p>C语言标准规定 <code>argv[argc]</code> is NULL (一定是一个空指针).</p><p>如: hello world </p><p>argc &#x3D;&#x3D; 3;</p><p>argv[0] &#x3D;&#x3D; “echo”(文件名), argv[1] &#x3D;&#x3D; “hello”, argv[2] &#x3D;&#x3D; “world”, argv[3] &#x3D;&#x3D;NULL</p></li><li><p><code>printf</code>函数可以结合表达式使用 <code>printf((argc &gt; 1) ? &quot;%s &quot; : &quot;%s&quot;, *++argv);</code></p></li><li><p><code>void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );</code>  </p><p>参数含义: 1. 待排序数组首地址(数组名) 2. 数组中元素数 3. 每一个元素的字节数 4. comp是一个指针, <strong>指向一个函数</strong>  &#x3D;&#x3D;<strong>(函数指针, functional pointer)</strong>&#x3D;&#x3D;, 指向的函数有两个参数是void型, 返回值是int.</p></li><li><p>如何获取数组长度: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> integers[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; <br><span class="hljs-type">int</span> size_of_integers = <span class="hljs-keyword">sizeof</span> integers / <span class="hljs-keyword">sizeof</span> *integers; <span class="hljs-comment">// 计算数组长度 sizeof一个数组就是返回整个数组的字节数, 注意这里sizeof不要在后面跟(), 但是sizeof(int)需要</span><br></code></pre></td></tr></table></figure></li><li><p>在C语言中<strong>函数名本身就是一个指针</strong>. <code>CompareInts()</code>这个函数, 在作为第四个参数传入<code>qsort()</code>时, 只要写<code>CompareInts</code>就代表一个函数指针. </p></li><li><p>当函数名出现在表达式中时, C语言解释其为函数指针(也就是说, C语言中, 函数就是函数指针). </p></li><li><p>函数指针和其它指针一样用, 你还可以构建一个<strong>函数指针数组</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> (*fps[<span class="hljs-number">2</span>])(<span class="hljs-type">double</span>) = &#123;<span class="hljs-built_in">sin</span>, <span class="hljs-built_in">cos</span>&#125;;  <span class="hljs-comment">// fps是一个数组, 有两个元素, 每个元素是一个指针, 指向一个函数, 这个函数接受一个double返回一个double</span><br></code></pre></td></tr></table></figure></li><li><p>函数指针说到底是一个变量, 是变量就可以声明, 可以修改.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*comp)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) = CompareInts; <span class="hljs-comment">// 很诡异的一个声明和赋值, 这样之后comp就完全等价于CompareInts, 在C语言中是不需要再对函数指针再解引用了(即不需要写*comp, 区别于传统指针)</span><br></code></pre></td></tr></table></figure></li><li><p>除了<code>qsort</code>, C语言还有<code>bsearch</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmem, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> (*comp)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>; <span class="hljs-comment">// base指向被查找的数组, nmem为查找长度, size为每个元素的大小, comp同qsort()的</span><br></code></pre></td></tr></table></figure></li><li><p>那么有了函数指针, 函数就是一个一般变量了, 可以作为<strong>函数的参数, 函数的返回值, 数组的元素</strong> , 可以声明, 定义, 可以赋值, 函数指针可以干任何一般变量能做到的. 函数就成为了一等公民.</p></li><li><p>复杂的函数声明: 核心是指针与数组 &#x2F;  <code>*</code>, <code>[]</code>, <code>()</code>三个运算符的结合与优先. </p><p>题目1: 解释以下输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*arr)[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu&quot;</span>, <span class="hljs-keyword">sizeof</span> (arr)); <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu&quot;</span>, <span class="hljs-keyword">sizeof</span> (*arr)); <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>题目2: 解释以下声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure></li><li><p>使用<code>typedef</code>定义特定类型<strong>函数指针的别名</strong> <code>typedef int (*NICKNAME)(int, int);</code> 这样 <code>NICKNAME fun;</code> 就是对fun的一个声明.</p></li><li><p><strong>struct</strong>: 一种数据类型, 与int, char等等一样. </p></li><li><p>使用 <code>typedef struct musician &#123;, , , ,&#125; Musician;</code> &#x2F;&#x2F; 用别名Musician替代struct musician</p></li><li><p>结构体<strong>填充&#x2F;内存对齐</strong>, 结构体的存储是有要求的, 结构体成员里面最大字节数如果为8, 那么必须要首地址是8的倍数, 尾地址也要是8的倍数. </p></li><li><p>结构体也可以通过赋值号( <strong>&#x3D;</strong> )来赋值, 当然, 前提是两个结构体类型相同.</p></li><li><p>结构体变量也可以<strong>直接</strong>作为参数进行函数传参, 但是, 应该使用结构体指针进行传参以避免直接传结构体降低程序效率.</p></li><li><p>结构体成员名可以和main函数中的变量重名.</p></li><li><p>使用   <em><strong>结构体变量名</strong></em> <strong>.</strong>  <em><strong>内部的变量名</strong></em>  (点表达式) 来访问结构体内部. </p></li><li><p>结构体变量名就是一个结构体变量, 对其取址(&amp;musician)得到的就是一个<strong>结构体指针</strong>(指向结构体变量的指针)  (用结构体指针可以实现结构体的跨函数传递, 比<em>直接传递结构体</em>性能更高).</p></li><li><p>C语言<strong>不支持结构体直接判断相等</strong>. 即<code>struct1 == struct2</code>是<strong>不可以</strong>的(<em><strong>C中能用&#x3D;&#x3D;判断相等的只能是基本数据类型</strong></em>), 思考: </p><pre><code class="hljs">1. `ptr1 == ptr2` **意味着什么? **2. `struct1`和`struct2 `的每一个成员都相等, **又意味着什么?** </code></pre></li><li><p>结构体指针示例: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PrintMusician</span><span class="hljs-params">(Musician *m)</span> &#123; <span class="hljs-comment">// m为一个结构体指针(特别常用的做法)</span><br>(*m).name <span class="hljs-comment">// 通过指针访问结构体内部的变量方法1(注意.的优先级最高, 所以括号不能省略)</span><br>    m-&gt;gender <span class="hljs-comment">// 通过指针访问结构体内部的变量方法2</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**动态申请结构体: **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> *<span class="hljs-title">book1</span>;</span><br>book1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*book1));<br><br><span class="hljs-comment">//也可以写成: </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> *<span class="hljs-title">book1</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*book1));<br><span class="hljs-comment">// malloc之后下意识检查是否malloc到了空指针</span><br><span class="hljs-keyword">if</span> (book1 == <span class="hljs-literal">NULL</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>enum</code> 枚举类型.</p></li></ol><p>​定义某一个数据类型, 这种类型只有几种可能, 在定义的同时将这些可能一一列举出来, 这样的类型就叫枚举.</p><h2 id="Lesson-11-链表"><a href="#Lesson-11-链表" class="headerlink" title="Lesson 11: 链表"></a>Lesson 11: 链表</h2><ol><li><p>链表的每一个**节点(Node)**就是一个结构体, 这个结构体的第一个域可以是一个整数, 第二个域需要是一个指针(叫作next, 指向链表的下一个节点). 链表就是通过指针把多个结构体连在一起.</p></li><li><p>链表和数组的区别在于数组的内存空间是连续的, 而链表每个节点都是<code>malloc</code>动态申请来的, 没法保证每一个的内存空间是连续的.</p><p>所以要访问链表的某个节点就只能从头开始往后扫描(最坏的时间复杂度是O(n)而数组为O(1) ).</p><p>(好处在于灵活, 所以插入&#x2F;删除链表节点时间复杂度O[1], 而插入&#x2F;删除数组元素时间复杂度最 坏O(n) )</p></li><li><p>链表实现了数据的动态保存, 不需要预先分配内存空间, 而是在需要时动态申请, 整个空间可以根据需要扩大或缩小.</p></li><li><p>双向链表: 一个指针(pre)指向前面, 一个指针(next)指向后面.</p></li><li><p>循环链表: 最后一个节点的next指针指向Head.</p></li><li><p>解决链表问题: 先想一般情况, 再讨论特殊情况 (空链表&#x2F;链表只有一个节点), 再看这两类有没有可以合并的. </p></li><li><p>删除节点函数Delete写的时候不应该传递被删除节点, 应传前一个指针. (双向链表无所谓)</p></li><li><p>如果删了head或tail节点, 要记得更新head或tail.</p></li><li><p>如果只想要在某函数符合特定条件的时候才调用一个函数, (如只有只剩1人时才return幸存者编号, 其它情况不使用该函数).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br>assert(IsSingleton(<span class="hljs-built_in">list</span>)); <span class="hljs-comment">// 做一个判断, 不成立就报错. (assert 断言)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* assert一般用于调试, 真正发布时, 要将assert去掉</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure></li><li><p>常见的链表操作补充: </p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(LinkedList *<span class="hljs-built_in">list</span>, Node *prev, <span class="hljs-type">int</span> val)</span>;<br>Node *<span class="hljs-title function_">Search</span><span class="hljs-params">(LinkedList *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> val)</span>;<br></code></pre></td></tr></table></figure></li><li><p>特殊头节点: 不存数据, 链表的长度. 对头节点的删除操作, 不用特殊化处理. (方便读取链表的长度, 可用于频繁获取链表长度的情形)</p></li><li><p>打印&#x2F;遍历链表: </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p-&gt;data);<br>p = p-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Lesson-12-预处理"><a href="#Lesson-12-预处理" class="headerlink" title="Lesson 12: 预处理"></a>Lesson 12: 预处理</h2><ol><li><p>预处理就是字符串替换.</p></li><li><p>宏函数<strong>可以</strong>接受不定长度的参数 </p><p>例如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(a, ...) <span class="hljs-keyword">if</span>(a) printf(...)</span><br><br>print(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;To C or not to C&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>当你想要把多个语句放在一起作为一个宏函数时, use <em><code>do&#123; &#125;while(0)</code></em></p><p>这样的好处是, 如果调用宏函数, 就需要在末尾加; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() do &#123;bar(); baz();&#125; while(0)</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) foo(); <span class="hljs-comment">// 这样就十分自然地写出了看起来没有问题, 实际上也没问题的代码.</span><br></code></pre></td></tr></table></figure></li><li><p>一些系统给的宏 <code>__x86_64__</code> 如果定义了就是在64-bit 环境下.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __x86_64__</span><br><span class="hljs-comment">// do sth</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br><span class="hljs-comment">// do sth</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 帮助定位错误的宏: </span><br>__FUNCTION__<br>__LINE__<br>    <br>__VA_ARGS__ <span class="hljs-comment">// C99引入, 表示一个或多个参数, 类似函数可变参数中的省略号</span><br><span class="hljs-comment">// 示例:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(format, ...) printf(format, ##__VA_ARGS__) <span class="hljs-comment">// 为什么使用## 如果不带##, __VA_ARGS__会替换为省略号匹配的所有参数, 同时会将省略号前面的一个逗号带上, 导致编译器报错, ##提示编译器把多余的逗号删除</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>#</code>和<code>##</code>运算符:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> concat(a, b) a ## b <span class="hljs-comment">// 把a和b字符串合并</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string(a) #a <span class="hljs-comment">// 给a的两边加上双引号, 变成字符串</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>##</code> 运算符</p><p><code>##</code>可以将两个记号 (如标识符) “<strong>粘合</strong>“ 在一起, 成为一个记号. (##运算符被称为”记号粘合”) 如果其中一个操作数是宏参数, “粘合”会在形式参数被相应的实参替换后发生. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MK_ID(n) i##n</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;<br><span class="hljs-comment">// 就是int i1, i2, i3;</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GENERIC_MAX(type)</span><br>type type##_max(type x, type y) &#123;  \<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y;  \<br>&#125;<br><br>GENERIC_MAX(<span class="hljs-type">float</span>)<br><span class="hljs-comment">// float float_max(float x, float y) &#123; return x &gt; y ? x : y;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>如果对于字符串进行宏定义替换, 替换之后又要进行 ## 或者是 # 的操作, 又不希望因为直接做##或#而忽略掉之前的宏定义, 就可以使用一个temp宏作为中介使得一趟替换之后没有到位, 而是转入temp宏, 这样就能够使得字符串替换不被忽略掉.</p></li><li><p><strong>预处理指令</strong></p><p><code>#include</code>  包含</p><p><code>#define</code>  宏定义</p><p>(根据条件判断来选择编译的内容)</p><p><code>#if </code>       如果, 则预定义</p><p><code>#else</code>   否则, 预定义</p><p><code>#elif </code>    否则如果, 则预定义</p><p><code>#endif </code> 结束条件判断</p><p><code>#ifdef</code>  如果定义了, 则 (if define)</p><p><code>#ifndef </code> 如果没定义, 则 (if not define)</p></li><li><p><code>#include</code></p></li></ol><p>​两种形式 &lt;&gt; 到配置目录中找和 “ “从当前目录开始找, 无则到配置目录里找.</p><p>​文件包含允许嵌套. A包含B, B包含C, 那么A包含了B和C</p><ol start="3"><li><p><code>#define</code> </p><p>宏定义, 可以带参数. </p></li><li><p>条件编译 (为了提高可移植性的)</p><p>#if (<strong>常量表达式</strong>)   –&gt; 注意常量, 非变量</p><p>仅当表达式为真, 才编译它与<code>#endif</code>之间的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> beta 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (status == debug)</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序调试中\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (status == beta)</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序测试中\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;欢迎使用正式版!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*-----------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PI        <span class="hljs-comment">// 这个判断是为了避免重复定义, 常用于一些复杂的文件</span></span><br>define PI <span class="hljs-number">3.14</span> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>         </span><br></code></pre></td></tr></table></figure></li><li><p>常用宏函数: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAP(a, b) \        <span class="hljs-comment">// 这里的反斜杠是续行, 一般在C语言中只在宏定义中才会用到</span></span><br>    <span class="hljs-keyword">do</span> &#123;           \        <span class="hljs-comment">// 为什么不给a, b加括号, 因为 = 是除了 , 最低优先级的运算符</span><br>        <span class="hljs-type">int</span> t = a; \<br>        a = b;     \<br>        b = t;     \<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>) <span class="hljs-comment">//宏需写在代码头文件下面，此为简单版，交换两个 int 型数字</span><br><br><span class="hljs-comment">// 最简洁的swap</span><br>x ^= y ^= x ^= y;  <span class="hljs-comment">//异或真神奇！不过这究竟是为什么呢？</span><br></code></pre></td></tr></table></figure></li><li><p>定义宏函数: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ture 1 <span class="hljs-comment">// 把前面的字符串替换为后面的字符串</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo(bar) bar + 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dist(x1, y1, x2, y2) (abs((x1) - (x2) + abs((y1) - (y2))) <span class="hljs-comment">// 注意这里每一个变量都要加括号, 以避免变量内部有一个比&#x27;-&#x27;优先级更小的运算符</span></span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x1 - x2) + <span class="hljs-built_in">abs</span>(y1 - y2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>#include</code> 预编译的机制, 其实就是把被 include 的代码copy到当前的c文件中, 只是做了一个substitute的工作, 你可以写出以下的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hello.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">printf</span>(<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;inc.h&quot;</span></span><br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// inc.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span> </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.h</span><br>hello world<br></code></pre></td></tr></table></figure></li><li><p>用gcc<strong>预编译</strong> <code>gcc -E a.c | less</code> </p></li><li><p>然后用vim命令<code>\printf</code>搜索对应的函数的声明</p><p><code>extern int printf (const char *__restrict __format, ...);</code></p></li><li><p>将这行代码copy也可以实现 <code>printf</code> 函数.  </p><p>其实 <code>#include &lt;stdio.h&gt;</code> 就是把以上预编译的东西全部粘贴过来, 而其中起作用的就是 <code>printf</code> 的声明.</p></li><li><p>这就是C语言的规定, **<code>#include</code> 做的就是<em>纯文本</em>的复制粘贴. **</p></li><li><p>预处理过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> aa == bb</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码被预编译为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其它信息全部被擦除了. 一个变量如果是在预编译指令中, 那么不需要定义就可以使用, 其值是系统赋予的, 如<code>__x86_64__</code>, 而本例中,  aa和bb都是空, 所以二者相等.</p></li><li><p>适当使用预编译指令, 不要滥用. </p></li><li><p>预编译也称为元编程 (meta-programing) , 发生在实际编译之前. (C++的模板元编程) (gcc的预处理器同样可以处理汇编代码)</p></li></ol><h2 id="Lesson-13-位运算"><a href="#Lesson-13-位运算" class="headerlink" title="Lesson 13: 位运算"></a>Lesson 13: 位运算</h2><ol><li><p>移位运算符: &lt;&lt;  &gt;&gt;  ( 有符号数右移, 高位补什么视编译器而定, 一般补的是符号位(最高位) )</p><p>为什么有符号数右移视编译器而定? 历史久, 需要兼容各类系统, C标准没有规定.</p><p>向右移动x位相当于除以$2^x$</p></li><li><p>移位运算的使用</p><ul><li>在能满足需求的情况下, 使用无符号数进行移位运算</li><li>如果需要使用有符号数的移位运算, 请验证高位补偿的规则并考虑可移植性问题.</li></ul></li><li><p>按位与 ( &amp; )  按位或 ( | )  按位异或 ( ^ ) </p></li><li><p>一元运算 按位取反 ( ~ )  会对操作数进行<em>整型提升</em> (不能忽略前面的位)</p></li><li><p>优先级: ~ &gt; 二元算术运算 &gt; <strong>&lt;&lt;, &gt;&gt;</strong> &gt; 关系运算 &gt; &amp; &gt; | &gt; 逻辑运算</p></li><li><p>几个常见的错误示例:</p><p><code>status &amp; 0x4000 != 0</code> 表示先不等于0, 然后与运算</p><p><code>i &lt;&lt; 2 + 1</code> 表示先把 2 + 1, 再移位</p></li><li><p>使用位运算访问位 将num的 (从低开始的) 第i位读取出来. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">num &amp; (<span class="hljs-number">1</span> &lt;&lt; i)<br></code></pre></td></tr></table></figure><p>将该位设置成0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">num &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; i)<br></code></pre></td></tr></table></figure><p>将该位设置成1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">num |= (<span class="hljs-number">1</span> &lt;&lt; i)<br></code></pre></td></tr></table></figure></li><li><p>使用位运算访问位域</p><p>将 1 &lt;&lt; i 替换为多个1bit (如 0x0070) 操作第4 - 6位</p></li><li><p>异或加密 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">a <span class="hljs-built_in">^</span> a = 0<br>a <span class="hljs-built_in">^</span> 0 = a<br>a <span class="hljs-built_in">^</span> b <span class="hljs-built_in">^</span> b = a<br></code></pre></td></tr></table></figure><p>加密方式: 有信息M, 秘钥K, 可以使用M’ &#x3D; M ^ K获得密文, 再使用M’ ^ K &#x3D; M ^ K ^ K &#x3D; M进行解密.</p></li><li><p>bit vector 位向量</p><p>一个长度为N的bit流可以表示一个最多有N个元素的集合. 下标 i 对应元素的布尔值如果为true就代表i这个数字在集合set中, 以此表示一个N个元素的集合.</p><p>有什么用? 代替bool数组, (因为bool类型是C99后才有的), 可以换取空间优势.</p><p>做集合的 <strong>交 &#x2F; 并 &#x2F; 差</strong> 运算时性能可观. </p></li><li><p>例: 交换一个32位整数的高16位和低16位. </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">y = ((x &amp; <span class="hljs-number">0xFFFF</span>) &gt;&gt; <span class="hljs-number">16</span>) | ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span>)<br></code></pre></td></tr></table></figure></li><li><p>例: 取以2为底的对数的整数部分 [Log<sub>2</sub> x]</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getLg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xffff0000</span>) &#123;ans += <span class="hljs-number">16</span>; x &amp;= <span class="hljs-number">0xffff0000</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xff00ff00</span>) &#123;ans += <span class="hljs-number">8</span>; x &amp;= <span class="hljs-number">0xff00ff00</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xf0f0f0f0</span>) &#123;ans += <span class="hljs-number">4</span>; x &amp;= <span class="hljs-number">0xf0f0f0f0</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xcccccccc</span>) &#123;ans += <span class="hljs-number">2</span>; x &amp;= <span class="hljs-number">0xcccccccc</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xaaaaaaaa</span>) &#123;ans += <span class="hljs-number">1</span>; x &amp;= <span class="hljs-number">0xaaaaaaaa</span>;&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Sp-Lesson-1-git"><a href="#Sp-Lesson-1-git" class="headerlink" title="Sp Lesson-1 git"></a>Sp Lesson-1 git</h2><ol><li><p>git就是一系列快照, git add 就是把文件加到临时快照里, commit就是把临时快照持久化, 而分支就是不同的程序员在进行各自的开发时使用便于管理的.</p></li><li><p>常用命令: </p><p><code>git init</code><br><code>git status</code><br><code>git commit -m &quot;&quot;</code><br><code>git log</code><br><code>git add -A //把当前文件夹中所有的纳入跟踪, 添加到暂存区</code><br><code>git checkout fe923 // fe923就是你某一次提交代号的前几位</code><br><code>git checkout 8f49c // 回到某一次具体的提交(可以是已经被回退掉的版本号)</code></p><p><code>git checkout -b &quot;git&quot; // 新建并转到命名为&quot;git&quot;的分支</code><br><code>git checkout master // 回到&quot;master&quot;分支</code><br><code>git branch // 查看分支信息</code><br><code>git merge // 合并分支</code></p><p><code>git merge git 进入一个界面, vim模式, 先按i进行insert编辑后, 按esc退出</code></p></li><li><p>主流的版本控制器 Git SVN</p></li><li><p>版本控制分类 1) 本地版本控制 2) 集中版本控制(所有的版本数据存在服务器上, 代表工具<code>SVN</code>) 3) 分布式版本控制 (每个人都拥有全部的代码, 服务器或者任一用户的保存损坏了都不会有影响, 只要再重新拷贝一份就可以了, 代表Git)</p></li><li><p>Git是目前世界上最先进的分布式版本控制系统</p></li><li><p>2005 Linus Torvalds 用2周时间开发出了自己的版本控制系统, 也就是后来的Git (为了辅助Linux内核, 开源, 免费)</p></li><li><p>Git Bash: Unix 与 Linux 风格的命令行, 使用最多, 推荐最多</p><p>Git CMD: Windows 风格的命令行</p><p>Git GUI: 图形界面的Git, 不建议使用</p></li><li><p>环境变量只是为了全局使用.</p></li><li><p><strong>Git 基本理论</strong> </p><blockquote><p>工作区域 </p></blockquote><p>Git 本地有三个工作区域: <strong>工作目录 ( Working Directory )</strong> , <strong>暂存区 (Stage&#x2F; Index)</strong> , <strong>资源库 (Repository &#x2F; Git Directory)</strong> , 如果在加上<strong>远程的git仓库 (Remote Directory)</strong> 就可以分成四个工作区域. </p><ul><li>&#x3D;&#x3D;<strong>Workspace</strong>&#x3D;&#x3D;: 工作区, 就是你平时存放项目代码的地方</li><li><strong>Index &#x2F; Stage</strong>:  暂存区, 用于临时存放你的变动, 事实上只是一个文件.</li><li><strong>Repository</strong>: 仓库区 ( 或本地仓库 ) , 就是安全存放数据的位置, 有所有的版本的数据. 其中HEAD指向最新放入仓库的版本.</li><li>&#x3D;&#x3D;<strong>Remote</strong>&#x3D;&#x3D;: 远程仓库, 托管代码的服务器.</li></ul><p>HEAD一开始指向的是master分支 (主分支).</p><p>在文件中有一个隐藏文件夹<code>.git</code> 其中有Stage 和 Local Repo文件夹</p></li><li><p>git的工作流程: </p><ol><li>在工作目录中添加修改文件;</li><li>将需要进行版本管理的文件放入暂存区域; <code>git add .</code>    (**.**表示全部)</li><li>将暂存区域的文件提交到git仓库</li></ol></li><li><p>Git项目搭建</p></li></ol><blockquote><p>创建工作目录与常用指令</p></blockquote><p>   工作目录 (WorkSpace) 可以是项目的目录, 不要有中文. </p><blockquote><p>本地仓库搭建</p></blockquote><p>   一种方法是创建全新的仓库, 另一种是克隆远程仓库.</p><ul><li><p>创建全新的仓库, <code>git init</code> 执行后在项目目录多出了一个 .git目录, 关于版本的所有信息都在这个目录里面.</p></li><li><p>克隆远程仓库到本地. <code>git clone ... </code> 然后就行了 </p><table><thead><tr><th>HTTP</th><th>利于匿名访问</th><th>适合开源项目</th><th align="center">可以方便被别人克隆和读取(但没有push权限, push需验证)</th></tr></thead><tbody><tr><td><strong>SSH</strong></td><td><strong>不利于匿名访问</strong></td><td><strong>比较适合内部项目</strong></td><td align="center"><strong>只要配置了SSH公钥即可自由实现clone和push操作</strong></td></tr></tbody></table><center>(HTTP 和 SSH协议的对比)<center></li></ul><ol start="11"><li><p>Git文件操作</p><blockquote><p>文件4种状态</p></blockquote><ul><li><strong>Untracked</strong>: 未跟踪,在文件夹中, 但没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code>.</li><li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照与文件夹中内容一致, 如果被修改, 状态变为<code>Modified</code>. 如果使用<code>git rm</code>则成为<code>Untracked</code>文件.</li><li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 有两个去处, 通过<code>git add</code>可进入暂存<code>Stage</code>状态, 使用<code>git checkout</code>则丢弃修改, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改.</li><li><strong>Staged</strong>: 暂存状态, 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code>.</li></ul></li><li><p>git文件操作命令: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git status <span class="hljs-comment"># Untracked</span><br>git add .<br>git status <span class="hljs-comment">#  to be commit (在*暂存区*里)</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment"># 提交到本地仓库</span><br>git status<br>git push<br></code></pre></td></tr></table></figure><blockquote><p>忽略文件</p></blockquote><p>在主目录下建立”.gitignore”文件, 此文件有如下规则:</p><ol><li>忽略文件中的空行和以井号 ( # ) 开始的行.</li><li>可以使用Linux通配符. 例如 : 星号( * )代表任意多个字符, 问号( ? )代表一个字符, 方括号 ( <strong>[…]</strong> ) 代表可选字符范围, 大括号( **{…} **)代表可选的字符串等.</li><li>如果名称的最前面有一个感叹号 ( ! ) , 表示例外规则, 将不被忽略.</li><li>如果名称的最前面是一个路径分隔符 ( &#x2F; ) , 表示要忽略的的文件在此目录下, 而子目录中的文件不忽略.</li><li>如果名称的最后面是一个路径分隔符 ( &#x2F; ) , 表示要忽略的是此目录下该名称的子目录, 而非文件 (默认文件或目录都忽略).</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.txt <span class="hljs-comment"># 忽略所有.txt结尾的文件</span><br>!lib.txt <span class="hljs-comment"># 但lib.txt除外</span><br>/temp    <span class="hljs-comment"># 仅忽略项目目录下的TODO文件, 不包括其它目录temp</span><br>build/      <span class="hljs-comment"># 忽略build/目录下的所有文件</span><br>doc/*.txt   <span class="hljs-comment"># (忽略某个文件夹下的文件)会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Git分支</strong> </p><ul><li>master: 主分支</li><li>dev: 开发(develop)用</li><li>v4.2: 不同版本的分支</li></ul><p>git中常用的分支命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment"># 列出所有本地分支</span><br>git branch -r  <span class="hljs-comment"># 列出所有远程分支</span><br>git branch [name]  <span class="hljs-comment"># 新建一个分支, 但依然停留在当前分支</span><br>git checkout -b [branch]  <span class="hljs-comment"># 新建一个分支, 并切换到该分支</span><br>git merge [branch]  <span class="hljs-comment"># 合并分支到当前分支</span><br>git branch -d [name]  <span class="hljs-comment"># 删除分支</span><br><br><span class="hljs-comment"># 删除远程分支</span><br>git push origin --delete [name]<br>git branch -dr [remote / branch]<br></code></pre></td></tr></table></figure><p>如果多个分支冲突了, 只要协商即可.</p></li><li><p><code>git commit --allow-empty</code> 允许无修改</p></li></ol><h2 id="Sp-Lesson-2-Vim"><a href="#Sp-Lesson-2-Vim" class="headerlink" title="Sp Lesson-2  Vim"></a>Sp Lesson-2  Vim</h2><ol><li><p><code>u</code> 撤销上一步操作</p></li><li><p><code>ctrl v</code> 块操作</p></li><li><p>强制退出 <code>:q!</code></p></li><li><p><strong>查找命令</strong>:  <code>:/</code> 正向查找   <code>:?</code> 反向查找 </p><p><code>n</code> 前向查找   <code>N</code> 反向查找</p><p>快速查找 : 1) 将光标移动到目标单词上  2) 按下<code>*</code>启动正向查找 <code>#</code> 反向查找</p></li><li><p><code>gg</code> : 回到顶部 <code>G</code> : 回到底部</p></li><li><p><code>$</code>: 跳转行末</p></li><li><p><code>0</code>: 行首</p></li><li><p><code>Ctrl+f</code>：向文件尾翻一屏</p><p><code>Ctrl+b</code>：向文件首部翻一屏</p><p><code>Ctrl+d</code>：向文件尾部翻半屏</p><p><code>Ctrl+u</code>：向文件首部翻半屏</p></li><li><ol><li><p><code>dw</code>  从光标当前的位置开始删除，直到删到单词最后。</p></li><li><p><code>daw</code>  算是1的属性扩充版，这个命令可以直接删除光标所在的一个单词。为了方便记忆，可以记忆为delete a word缩写。</p></li><li><p><code>bdw</code>  这也是一个复合命令。b可以让光标回退到单词开头的位置，而<code>dw</code>则是第1个描述过的命令。</p></li><li><p><code>ciw</code>  修改一个单词，change in word的缩写。</p></li><li><p><code>Shift d</code> 从光标处删除到行末尾.</p></li></ol></li><li><p><code>vs</code> 分栏 <code>e 文件名</code> 切换到文件</p></li><li><p>重命名某一个字符串 <code>%s/原字符串/新的字符串/g</code></p></li></ol><h2 id="Sp-Lesson-3-命令行"><a href="#Sp-Lesson-3-命令行" class="headerlink" title="Sp Lesson-3 命令行"></a>Sp Lesson-3 命令行</h2><ol><li><p><code>cat /hello.txt </code> 查看文件 ( 将文件内容输出至终端 ) (catch 抓来看看)</p></li><li><p><code>date</code> 获取当前的日期和时间</p></li><li><p><code>pwd</code> 获取当前的路径 (print work directory)</p></li><li><p>Linux下有一个整体的根目录. (从UNIX过来) Windows没有 (从DOS过来)</p></li><li><p><code>.</code>表示当前目录, <code>./home</code></p></li><li><p><code>..</code> 表示上一级目录 </p></li><li><p><code>echo</code>: 回声</p></li><li><p><code>man ls</code> :  man即manual, 手册</p></li><li><p><code>which ls</code>: 查看命令的位置</p></li><li><p><code>echo hello &gt; hello.txt</code>  输出重定向到 <code>hello.txt</code> 里</p></li><li><p><code>time</code> 对于任何一个命令都可以使用 <code>time</code> 来查看运行时间. <code>time ./a.out</code> 来查看可执行文件的运行时间</p></li><li><p><code>timeout</code> 倒计时 .. 秒, 若进程没有终止则强行停止. (可用于检测程序性能, 强行终止死循环等)</p></li><li><p><code>find</code> 寻找文件, 如 <code>find . | grep \.cpp$</code></p></li><li><p><code>grep</code>命令用于查找文件里符合条件的字符串或正则表达式</p></li><li><p><code>wc</code> 统计行数, 加<code>-l</code>只输出行数.</p></li><li><p><code>find . | grep \.c$ | xargs cat | wc -l</code> 利用管道协作, 统计所有c语言代码行数 (xargs 的功能, 将输入转换成后面命令的参数)</p></li><li><p>使用 <code>... | vim - </code> , 用vim打开前面命令的输出.</p></li><li><p>什么是管道命令? <code>命令1 | 命令2</code> 命令1的标准输出是命令2的标准输入. (以前面命令的输出作为后面一个命令的输入, 以此类推 ) </p><p>(注: 管道命令后面接的命令必须能够接收输入的命令, 不能接不能接收输入的命令, 比如ls cp mv等)</p></li><li><p>命令行中, 若要使用括号, 需要写作<code>$( ... )</code>左括号前加$</p></li><li><p>Linux命令行编程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 1 100) <span class="hljs-comment"># 所谓 $(seq 1 100) 本质上就是文本, 即 1 2 3 4 5 ... 100</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>(命令行的 2 个关键词: 文本, 工具)</p></li><li><p>编写 .sh 文件 (shell 脚本) 来帮你对拍&#x2F; 调试程序. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>gcc bad.c -o bad.exe<br>gcc ok.c -o ok.exe<br><br>for i in $(seq 1 5)<br>do <br>echo ======= Test case $i ========<br>cp hello$&#123;i&#125;.in hello.in<br>./a.out<br>cat hello.out<br>done<br><br>for T in $(seq 1 100)<br>do<br>echo Testcase $T<br>./gen # 生成输入<br>echo &quot;100 + 200&quot; &gt; in.txt<br><br>diff -q \<br>&lt;(timeout 1 ./ok.exe &lt; in.txt) \<br>&lt;(timeout 1 ./bad.exe &lt; in.txt)<br>if [[ $? != 0]]<br>then <br>echo &#x27;Error!&#x27;<br>fi<br>done<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>run.sh</code> 文件, 编写文件内容为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in $(seq 1 3) <br>do <br>./a.out &lt; in$i.txt &gt; out$i.txt<br>diff ans$i.txt out$i.txt || echo &quot;Error on Testcase #$i&quot;<br>done<br></code></pre></td></tr></table></figure><p>这样就实现了一个对拍脚本. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">:: 在终端中运行脚本<br>bash run.sh<br></code></pre></td></tr></table></figure></li></ol><h2 id="Sp-Lesson-4-gdb"><a href="#Sp-Lesson-4-gdb" class="headerlink" title="Sp Lesson-4 gdb"></a>Sp Lesson-4 gdb</h2><ol><li><p><code>GDB</code>:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g ...<br>gdb ...<br></code></pre></td></tr></table></figure><p><code>start</code></p><p><code>next (n) 5</code> : 步过5行 </p><p><code>step (s)</code> : 步入</p><p><code>continue (c)</code>: &#x3D;&#x3D;跳转至下一断点所在行&#x3D;&#x3D; (from wherever we currently  are)</p><p><code>finish</code> : tell gdb to finish this current function call and then stop once we finish the call</p><p><code>bt</code> : back trace 查看若干级函数调用的历史记录和参数值</p><p><code>list</code> : 看代码</p><p> <code>b codes/main.c: 127</code> : 设置断点</p><p>( 另可在函数上打断点, <code>b main</code> )</p><p><code>info b  (i b)</code> : 查看断点信息</p><p><code>run (r)</code> : 从断点处或从头开始执行 (运行程序) </p><p><code>print i  (p i)</code></p><p><code>print &amp;i</code> : 查看 i 的地址值</p><p><code>set logging on</code> : 将gdb输出结果打印至日志文件中.                                                                  </p><p><code>watch</code> : 设置watchpoint以实时观察一个变量是否变化, 一旦变化, 就会输出变化信息. (查看设置了哪些watchpoint <code>info breakpoints(watchpoints)</code>) (用于避免反复<code>p</code>, 一般watch的是核心变量)</p><p><code>delete ID</code> : 删除断点 (delete 删除所有断点)  </p><p><code>display i</code> : 每次<code>n</code>都打印出i的值.</p><p><code>undisplay ID</code> : 停止跟踪ID下标的那个变量, 一般第一个display的下标为1  </p><p><code>up</code> : 返回上一级函数 (找到是谁在调用当前行)</p><p><code>backtrace</code> : 不再是一次一次地up , 而是直接全部 print the entire call stack , 看到所有的涉事指针作为参数传递时的函数调用栈. (进行 N 次<code>up</code>)</p><p><code>fin</code> : 执行完当前函数, 返回到上一调用层, 并打印返回值</p><p><code>whatis j (what j)</code> : 可以得知 j 的数据类型</p></li><li><p><code>gdb</code>高级</p><p><code>target record-full</code> : 记录所有东西</p><p><code>rn</code> (reversed-next) : 回退一步 ( <code>rs (reversed-step)  rc (reversed-continue)</code> )</p><p><code>set var x=15</code> : 改变x的值但是不退出gdb运行.</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/02/hello-world/"/>
    <url>/2024/03/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
