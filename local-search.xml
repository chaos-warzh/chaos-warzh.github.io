<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端测试框架指南</title>
    <link href="/2024/06/02/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/"/>
    <url>/2024/06/02/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="前端测试框架使用指南"><a href="#前端测试框架使用指南" class="headerlink" title="前端测试框架使用指南"></a>前端测试框架使用指南</h1><p>​由于观察控制台输出的测试方法不够便捷且不方便共享, 我们构建了测试框架. 利用此测试框架, 大家可以方便地为编译器前端构建测试用例, 从而更容易查出bug, 提高团队开发的效率. </p><p>​<mark>目前你可以在 <code>wzh-dev</code> 获取此测试框架alpha版, 经过重构和review后, 该测试框架会合并入 <code>main</code> 分支. </mark></p><h2 id="测试单个样例"><a href="#测试单个样例" class="headerlink" title="测试单个样例"></a>测试单个样例</h2><ol><li><p>首先, 在 <code>src/test/resouces/sy/</code> 目录下新建待测试的 <code>.sy</code> 源文件. </p><p> <img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240602155920823.png" alt="image-20240602155920823"></p><p>例如此处新建了 <code>merge-sort.sy</code> 文件:</p><p>在 <code>main</code> 函数中返回一个待测试的值, 我们的框架会测试<strong>该返回值是否正确</strong>.  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = right - mid;<br>    <span class="hljs-type">int</span> L[n1], R[n2];<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; n1) &#123;<br>        L[i] = arr[left + i];<br>        i = i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; n2) &#123;<br>        R[j] = arr[mid + <span class="hljs-number">1</span> + j];<br>        j = j + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    i = <span class="hljs-number">0</span>;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> k = left;<br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) &#123;<br>            arr[k] = L[i];<br>            i = i + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[k] = R[j];<br>            j = j + <span class="hljs-number">1</span>;<br>        &#125;<br>        k = k + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt; n1) &#123;<br>        arr[k] = L[i];<br>        i = i + <span class="hljs-number">1</span>;<br>        k = k + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (j &lt; n2) &#123;<br>        arr[k] = R[j];<br>        j = j + <span class="hljs-number">1</span>;<br>        k = k + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        mergeSort(arr, left, mid);<br>        mergeSort(arr, mid + <span class="hljs-number">1</span>, right);<br>        merge(arr, left, mid, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> arr_size = <span class="hljs-number">6</span>;<br>    mergeSort(arr, <span class="hljs-number">0</span>, arr_size - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> first = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> first;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后, 在测试类 <code>TestFrontEnd</code>的 <code>testFrontEnd</code> 方法上增加注解 <code>@StringSource(&quot;merge-sort&quot;)</code></p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240602160612264.png" alt="image-20240602160612264"></p></li><li><p>运行测试方法 <code>testFrontEnd</code> 即可</p></li></ol><h2 id="测试多个样例"><a href="#测试多个样例" class="headerlink" title="测试多个样例"></a>测试多个样例</h2><ol><li><p>利用 <code>@StringSource</code> 注解, 你可以方便地一次测试多个样例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ParameterizedTest</span><br><span class="hljs-meta">@StringSource(&quot;add&quot;)</span><br><span class="hljs-meta">@StringSource(&quot;array&quot;)</span><br><span class="hljs-meta">@StringSource(&quot;merge-sort&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testFrontEnd</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的测试方法运行时将会测试 <code>add</code> <code>array</code> <code>merge-sort</code> 这3个样例. </p></li><li><p>我们还提供了测试驱动方法 <code>testAll</code> , 运行此方法将自动测试 <code>src/test/resouces/sy/</code> 目录下的所有 <code>.sy</code> 文件.</p></li></ol><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240602160612264.png" alt="image-20240602160612264"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Compilers 框架指南</title>
    <link href="/2024/05/30/Compilers%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/"/>
    <url>/2024/05/30/Compilers%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Compilers-框架指南"><a href="#Compilers-框架指南" class="headerlink" title="Compilers 框架指南"></a>Compilers 框架指南</h1><h2 id="1-项目架构"><a href="#1-项目架构" class="headerlink" title="1. 项目架构"></a>1. 项目架构</h2><p> <img src="https://box.nju.edu.cn/f/0d4ee14124004c37af9c/?dl=1"></p><ol><li><code>Main</code> 项目启动类, 在其main方法中完成从源代码到生成目标代码的全过程 </li><li><code>frontend</code> 在这里进行前端开发 (包括词法分析, 语法分析, 语义分析, ir生成)</li><li><code>ir</code> 在这个包下模仿全部的llvm api  (<mark><strong>7.1之后的工作重点</strong></mark>)</li><li><code>test/java</code> 测试驱动类存放在此目录下</li><li><code>test/resources</code> 测试用例存放在此目录下</li></ol><h2 id="2-前端开发指南"><a href="#2-前端开发指南" class="headerlink" title="2. 前端开发指南"></a>2. 前端开发指南</h2><ol><li><p><strong>在main方法中加入与前端相关的代码.</strong> </p><ol><li><p>目前的main方法已实现了命令行参数的解析, 如图: </p><p><img src="https://box.nju.edu.cn/f/5b98c92cbdd74e9a80e9/?dl=1"></p><p>前端的任务有以下: </p><ol><li><p>当 <code>emitLLVM</code> 为 <code>true</code> 时, 能在 <code>main</code> 方法中生成一个类型为<code>LLVMModuleRef</code>临时变量, 代表翻译后得到的llvm ir. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LLVMModuleRef</span> <span class="hljs-variable">module</span> <span class="hljs-operator">=</span> ...;<br></code></pre></td></tr></table></figure></li><li><p>如果用户开启了 <code>--emit-llvm</code> 选项, 输出llvm ir到指定输出文件. </p></li><li><p>如果用户开启了 <code>-O2</code> 选项, 能够生成优化的llvm ir.</p></li></ol></li><li><p><strong>借助 antlr 完成词法分析, 语法分析.</strong> </p></li><li><p><strong>遍历生成的语法树完成语义检查, 并且完成错误报告和恢复.</strong> (需考虑<strong>运行时库</strong>)</p></li><li><p><strong>借助导入的llvm-platform包完成, 遍历语法树生成LLVM IR.</strong> (保证生成的IR的正确性, 并思考如何自己设计api.)</p></li><li><p><strong>实现运行时库的LLVM IR翻译.</strong></p></li></ol></li><li><p>涉及到的文件修改 (参考):</p><p><code>Main.java</code> (你需要在这里生成<strong><code>module</code></strong>)</p><p><code>src/main/java/cn.edu.nju.software/frontend</code> (所有前端代码请组织好放在此包下)</p></li><li><p>(选做) 建议在 <code>src/main/java/cn.edu.nju.software/ir</code> 包下放一些你所用到的 LLVM api 的类和方法的一份复刻. </p><p>例如, 如果你使用了 <code>LLVMModuleRef</code> 这个类, 你可以顺便在 <code>ir</code> 目录下增加一个名为 <code>ModuleRef</code> 的空的class. 如果你使用了 <code>LLVMAddGlobal()</code> 方法, 你也可以在<code>ir</code>目录下的相应位置添加一个名为 <code>AddGlobal</code> 镜像的空方法. </p><p><mark><strong>虽然现阶段选择使用 LLVM 的 api 来完成ir生成, 但是顺带着维护包含了所有用到的api的, 镜像ir包将会对你的后续开发带来显而易见的好处!</strong> </mark></p></li></ol><h2 id="3-后端开发指南"><a href="#3-后端开发指南" class="headerlink" title="3. 后端开发指南"></a>3. 后端开发指南</h2><p>TBD</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang复习笔记</title>
    <link href="/2024/03/04/Golang%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/04/Golang%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang复习笔记"><a href="#Golang复习笔记" class="headerlink" title="Golang复习笔记"></a>Golang复习笔记</h1><h2 id="1-intro"><a href="#1-intro" class="headerlink" title="1: intro"></a>1: intro</h2><ol><li><p>Golang: 极简单的部署方式</p><ol><li>可直接编译成机器码</li><li>不依赖其它库</li><li>直接运行可部署</li></ol></li><li><p>Golang是一门静态类型语言 – 编译时可检查出隐藏的问题</p></li><li><p>语言层面的并发</p><ol><li>天生支持并发</li><li>充分利用多核</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goFunc</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;goroutine &quot;</span>, i, <span class="hljs-string">&quot; ...&quot;</span>)<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> goFunc(i) <span class="hljs-comment">// 开启一个并发协程</span><br>    &#125;<br>    <br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>强大的标准库</p><ol><li>runtime系统调度机制</li><li>高效的GC (垃圾回收)</li><li>丰富的标准库</li></ol></li><li><p>简单易学</p><ol><li>25个关键字</li><li>内嵌C语法支持</li><li>面向对象</li><li>跨平台</li></ol></li><li><p>Golang的强项</p><ol><li>云计算基础设施</li><li>基础后端软件</li><li>微服务</li><li>互联网基础设施</li></ol></li><li><p>Golang的不足</p><ol><li>包管理, 大部分包都在Github上</li><li>所有的Exception都用Error处理 (没有try-catch)</li><li>对C的降级处理并非无缝, 没有C降级到asm那么完美 (例如序列化问题)</li></ol></li></ol><h2 id="2-basic-feature"><a href="#2-basic-feature" class="headerlink" title="2: basic feature"></a>2: basic feature</h2><ol><li><p><code>package main</code> 表示一个可独立执行的程序, 每个 Go 应用程序都包含一个名为 main 的包. </p></li><li><p>golang中的表达式, 末尾的分号<code>;</code>可加可不加, 建议不加. </p></li><li><p><code>import &quot;fmt&quot;</code> 表示导入fmt包, fmt包里包含了格式化IO的函数. </p></li><li><p>main函数式每一个可执行程序必须包含的. </p></li><li><p>注释, 类似C语言, <code>//</code> 单行注释;  <code>/* ... */</code> 块注释. </p></li><li><p><code>fmt.Println(...)</code> 与 <code>fmt.Print(...)</code> 格式化输出. <code>fmt.Scanln(...)</code>与<code>fmt.Scanf(...)</code>格式化输入. </p></li><li><p><code>Print</code> 类似python的语法, 而 <code>Printf</code> 类似C语言的用法. </p></li><li><p>变量声明: 使用<code>var</code>关键字</p><ul><li>指定变量类型, 若声明后不赋值, 默认值为0:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><ul><li>根据值自行判定变量类型:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure><ul><li><p>使用 <code>:=</code>, 注意, <code>:=</code> 左边的变量不能是已经声明过的</p></li><li><p>多变量声明:</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ( <span class="hljs-comment">// 这种写法一般用于全局变量</span><br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">bool</span><br>)<br><span class="hljs-keyword">var</span> c, d <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;str&quot;</span><br>result, err := funcCall()<br></code></pre></td></tr></table></figure></li><li><p>常量使用 <code>const</code> 关键字定义, 格式为: <code>const identifier [type] = value</code> , type可以省略, 由编译器进行类型推断. </p></li><li><p>常量的值必须是能够在编译期确定, 如:</p></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> c1 = <span class="hljs-number">1</span> * <span class="hljs-number">2</span> + <span class="hljs-number">3</span>; <span class="hljs-comment">// √</span><br><span class="hljs-keyword">const</span> c2 = getRes(); <span class="hljs-comment">// x</span><br></code></pre></td></tr></table></figure><ol start="11"><li><p>在编译期, 自定义函数不可作为常量的赋值, 但是内置函数可以, 如: <code>len()</code></p></li><li><p>数字型的常量是没有大小和符号的, 并且可以使用任何精度而不会导致溢出. (但是如果将常量赋值给某个特定类型变量, 则可能出现溢出)</p></li><li><p>常量可以用作枚举:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Mon, Tue, Wed = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>)<br><span class="hljs-keyword">const</span> (<br>    Female = <span class="hljs-number">1</span><br>    Male = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>也可以利用golang里面的常量计数器 <code>iota</code> , 每当const关键字出现时, 计数器清零, 然后按行常量声明值自增1. </p></li><li><p>以下是关于 <code>itoa</code> 的语法细节:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 一行多个itoa */</span><br><span class="hljs-keyword">const</span> (<br>    a, b = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span> <span class="hljs-comment">// a = b = 0</span><br>    c, d <span class="hljs-comment">// c = d = 0</span><br>)<br><span class="hljs-comment">/* 跳值占位 */</span><br><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-literal">iota</span> <span class="hljs-comment">// a = 0</span><br>    _<br>    b <span class="hljs-comment">// b = 2</span><br>)<br><span class="hljs-comment">/* 首行或中间插队 */</span><br><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-number">99</span><br>    b = <span class="hljs-literal">iota</span> <span class="hljs-comment">// b = 1</span><br>    c = <span class="hljs-number">97</span><br>    d = <span class="hljs-literal">iota</span> <span class="hljs-comment">// d = 3</span><br>   e  <span class="hljs-comment">// 没有表达式的常量定义复用上一行的表达式</span><br>)<br></code></pre></td></tr></table></figure></li><li><p><code>init</code> 函数: 一类特殊的函数, 不能被人为调用, 而是在每个包完成初始化后自动按包的依赖关系顺序执行. </p></li><li><p>可以在<code>init</code>函数中对变量初始化. </p></li><li></li><li></li><li></li><li></li></ol><h2 id="3"><a href="#3" class="headerlink" title="3:"></a>3:</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java复习笔记</title>
    <link href="/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/03/Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java复习笔记"><a href="#Java复习笔记" class="headerlink" title="Java复习笔记"></a>Java复习笔记</h1><h2 id="Java-Lesson-0-Resources"><a href="#Java-Lesson-0-Resources" class="headerlink" title="Java-Lesson 0 (Resources)"></a>Java-Lesson 0 (Resources)</h2><ol><li>Java 8 官方文档: <a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></li><li>Google Java Style Guide: <a href="https://google.github.io/styleguide/javaguide.html">https://google.github.io/styleguide/javaguide.html</a></li></ol><h2 id="Java-Lesson-1-Basic-Grammar"><a href="#Java-Lesson-1-Basic-Grammar" class="headerlink" title="Java-Lesson 1 (Basic Grammar)"></a>Java-Lesson 1 (Basic Grammar)</h2><ol><li><p>标识符: 标识类&#x2F; 变量&#x2F; 常量和方法的名字, 由字母 (A-Z, a-z) &#x2F; 特殊符号(<strong>$</strong>, _) 和数字 (0-9) 构成, 区分大小写, 名字的第一个字符不能为数字, 标识符不可为Java关键字.</p></li><li><p>Java数据类型可分为<strong>基本数据类型 ( Primitive type )<strong>和</strong>引用数据类型 ( Reference type )</strong>, 数组和对象都是引用数据类型. </p></li><li><p>Java基本数据类型有<code>byte</code>: -128~127 (1 byte) 的整数, <code>boolean</code>: 布尔型 (实际占1 byte), <code>char</code>: 占2 byte, (16-bit unicode)</p></li><li><p>Java大数: 对于高精度计算的需求, Java Math库提供了BigInteger 和 BigDecimal 以满足任意长度的整数运算和任意精度的浮点数运算, 有一些常量, 如 <code>BigInteger.ZERO</code>  <code>BigInteger.TEN</code>, 但是由于Java不像C++那样支持运算符重载, 所以其运算不是使用 + * , 而是add() multiply() 等. </p></li><li><p>Java也支持下划线分隔整数或浮点数, 以及科学记数法 (E或e).  <code>long hex = 0x7f_e9_b7_aa; float expf = 1.39E-43f;</code> </p></li><li><p>final关键字, 修饰常量. 常量命名常常全部大写 (<strong><code>final</code></strong>: 最后的, 没有后继者(不被修改&#x2F;改写, 不能被继承…) )</p></li><li><p>Java允许int类型溢出, 这一点与C十分相似.</p></li><li><p>java中的最大整数常量: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br></code></pre></td></tr></table></figure></li><li><p>类型转换: 自动类型转换 – 类型提升 强制类型转换 <code>(&lt;type&gt;)vari</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">doubleNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.9</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">intNum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)doubleNum; <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure></li><li><p>main() 方法要给外部JVM程序调用, 所以必须为public, 在对象没产生前, main()方法就已被JVM调用, 所以必须为static (类方法&#x2F; 静态方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-comment">// 访问修饰符 关键字 返回类型 方法名(参数)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-2-Control-Flow-Container"><a href="#Java-Lesson-2-Control-Flow-Container" class="headerlink" title="Java-Lesson 2 (Control Flow, Container)"></a>Java-Lesson 2 (Control Flow, Container)</h2><ol><li><p>switch语句中default的使用细节: </p><ol><li>default可以随意与case语句更换位置, 不论其在哪, 都是最后被执行</li><li>default语句如果在所有case后面使用, 则可以不用break语句</li><li>default语句如果在部分case之前, 或在所有case之前, 则建议在其语句中加入break语句. 否则, 执行完default语句后, 会从上往下顺序执行case语句, 直到遇到break语句, 如果一直不遇到break语句, 则<strong>执行完default下方所有的</strong>case语句.</li></ol></li><li><p><code>switch</code>的新特性: <strong>switch 表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DaysInMonth</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> today.get(Calendar.MONTH);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> today.get(Calendar.YEAR);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">daysInMonth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (month) &#123;<br>            <span class="hljs-keyword">case</span> Calendar.JANUARY,<br>                 Calendar.MARCH,<br>                 Calendar.MAY,<br>                 Calendar.JULY,<br>                 Calendar.AUGUST,<br>                 Calendar.OCTOBER,<br>                 Calendar.DECEMBER -&gt; <span class="hljs-number">31</span>;<br>            <span class="hljs-keyword">case</span> Calendar.APRIL,<br>                 Calendar.JUNE,<br>                 Calendar.SEPTEMBER,<br>                 Calendar.NOVEMBER -&gt; <span class="hljs-number">30</span>;<br>            <span class="hljs-keyword">case</span> Calendar.FEBRUARY -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; !(year % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>))<br>                        || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-number">29</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-number">28</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                    <span class="hljs-string">&quot;Calendar in JDK does not work&quot;</span>);<br>        &#125;;<br><br>        System.out.println(<span class="hljs-string">&quot;There are &quot;</span> + daysInMonth + <span class="hljs-string">&quot; days in this month.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意, 与C的区别, 分支的控制变量也可以是<strong>字符串</strong>. </p><p>变化1, switch 代码块出现在了赋值运算符的右侧. 这也就意味着, 这个 switch 代码块表示的是一个<strong>数值</strong>, 或者是一个变量. 换句话说, 这个 switch 代码块是一个表达式.</p><p>变化2, 是多情景的合并. 也就是说, 一个 case 语句, 可以处理多个情景. 这些情景, 使用逗号分隔开来, 共享一个代码块.</p><p>变化3, 无break.</p><p>变化4, <code>-&gt;</code>, 箭头标识符, 这个符号使用在 case 语句里, “case L -&gt;”. L就是要匹配的一个或者多个情景. 替代的是传统冒号标识符<code>:</code> , 但我们依然可以在 switch 表达式里使用冒号标识符, 使用冒号标识符的一个 case 语句只能匹配<strong>一个</strong>情景 (但是极不推荐你用这种形式).</p><p>变化5, 是箭头标识符的右侧, 可以是表达式&#x2F; 代码块或者异常抛出语句, 而不能是其他的形式. 如果只需要一个语句, 这个语句也要以代码块的形式呈现出来. (<strong>即必须括上大括号</strong>, 否则报错)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> Calendar.JANUARY,<br>     <span class="hljs-comment">// snipped</span><br>     Calendar.DECEMBER -&gt; &#123;  <span class="hljs-comment">// CORRECT, enclosed with braces.</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>foreach语法 <code>for (char c : array1) &#123; System.out.println(c); &#125;</code> </p></li><li><p>break标签 (, continue标签) : 可以打破任意层循环 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Loop1: <br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    Loop2: <br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">break</span> Loop1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>int[][] a = new int[3][4]; //矩阵 </code></p><p><code>int[][] a = new int[3][]; //不规则</code></p><p><code>a[0] = new int[3] &#123;1, 1, 4&#125;</code></p></li><li><p><code>ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; food = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>food.add(<span class="hljs-string">&quot;pizza&quot;</span>); <span class="hljs-comment">// 增</span><br>food.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;pasta&quot;</span>); <span class="hljs-comment">// 改</span><br>System.out.println(food.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 查</span><br>food.remove(<span class="hljs-number">0</span>); <span class="hljs-comment">// 删</span><br>food.size();<br>food.clear;<br></code></pre></td></tr></table></figure><p><strong>排序</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collections;<br><br>Collections.sort(food, Comparator.reverseOrder()); <span class="hljs-comment">// 列表排序, 而数组排序用Arrays.</span><br></code></pre></td></tr></table></figure><p><code>arraylist.sort(Comparator c)</code>  <code>list.sort(Comparator.reverseOrder()); // 从大到小排序</code></p><p><code>addAll(int index, Collection c)</code> 将c中所有元素插入到ArrayList中index的位置. (index缺省时为尾插) </p><p><code>removeIf(Predicate&lt;E&gt; filter)</code>  如 <code>list.removeIf(e -&gt; e.contains(&quot;Tao&quot;))</code></p><p><code>clone()</code> 复制一份 <code>contains</code>  <code>indexOf()</code>返回元素的索引</p><p><code>subList()</code> <code>toArray()</code> <code>toString()</code></p></li><li><p>注意, List只能装对象, <strong>不能装原始类型(int&#x2F; char&#x2F; float)</strong>! 所以常常要类型转换为<code>Integer</code>等类. </p></li><li><p>列表<code>ArrayList</code> 用作动态数组: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// 为什么不用List来new一个对象, 因为Java中List是接口, 而ArrayList可以看作是一个实现. List里面的方法, ArrayList都有</span><br>L.add(<span class="hljs-string">&quot;a&quot;</span>);<br><br>List&lt;Integer&gt; L1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>L1.add(<span class="hljs-number">1</span>);<br><br>Collections.sort(L1);  <br></code></pre></td></tr></table></figure></li><li><p><code>ArrayList</code>初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>));<br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>ArrayList</code> <strong>二维</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;ArrayList&lt;String&gt;&gt; groceryList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>groceryList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>().add(<span class="hljs-string">&quot;soda&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>拷贝数组: (比for循环拷贝更快)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.arraycopy(src, <span class="hljs-number">2</span>, dst, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// src, 偏移量, dst, 偏移量, 复制元素的个数</span><br></code></pre></td></tr></table></figure></li><li><p>Arrays类中常用函数</p><ul><li><code>Arrays.sort(array)</code> – 将<strong>数组</strong>排序 (升序)</li><li><code>Arrays.toString()</code> – 将数组变为已读的字符串</li><li><code>Arrays.asList()</code> – 将数组<strong>转换成列表</strong> <code>Arrays.asList()</code>方法返回由指定数组支持的固定大小的列表. 由于无法对数组进行结构修改, 因此无法向列表中添加元素或从中删除元素. 该列表将抛出一个<code>UnsupportedOperationException</code> 如果对其执行任何调整大小操作.</li></ul></li><li><p>List与数组之间相互转换 </p><ul><li>数组 -&gt; List</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">25</span>&#125;;<br><span class="hljs-comment">// int[] -&gt; Integer[]</span><br>Integer[] boxB = Arrays.stream(b).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>); <br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(boxB));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">25</span>&#125;;<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, a); <span class="hljs-comment">// 利用集合工具类</span><br></code></pre></td></tr></table></figure><ul><li>List -&gt; 数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// List转Object[]</span><br>Object[] objs = list.toArray();<br><span class="hljs-comment">// Object[] 转Integer[]</span><br>Integer[] nums = Arrays.stream(objs).toArray(Integer::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">// Integer[] 转int[]</span><br><span class="hljs-type">int</span>[] arr = Arrays.stream(nums).mapToInt(Integer::valueOf).toArray();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = list.stream().mapToInt(Integer::intValue).toArray;<br><span class="hljs-comment">// or </span><br><span class="hljs-type">int</span>[] arr = list.stream().mapToInt(Integer::valueOf).toArray;<br></code></pre></td></tr></table></figure></li><li><p>Java HashMap, 类似Python的字典. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.HashMap;           <br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;BMW&quot;</span>, <span class="hljs-number">10000</span>);<br>        System.out.println(map.get(<span class="hljs-string">&quot;BMW&quot;</span>)); <span class="hljs-comment">// 10000</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> Map&lt;String, String&gt; L = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(); <span class="hljs-comment">// 这是一种泛型的写法 </span><br> L.put(<span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;woof&quot;</span>);<br> L.put(<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;meow&quot;</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">sound</span> <span class="hljs-operator">=</span> L.get(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-3-File-Exception"><a href="#Java-Lesson-3-File-Exception" class="headerlink" title="Java-Lesson 3 (File, Exception)"></a>Java-Lesson 3 (File, Exception)</h2><ol><li><p>File类 (java.io.File)</p></li><li><p>创建文件, 可以使用 <code>createNewFile()</code> 方法, 此方法会返回一个布尔值: true 代表此文件成功创建; false 代表此文件已存在. 要注意此方法要放入 try … catch 中, 防止 IOException 异常的出现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandler</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">newFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newFile.txt&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            newFile.createNewFile();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果要给一个文件写入内容, 则需要 FileWriter 这个类, 以下的代码便会把 Hello World 写入 newFile.txt 文件中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">FileWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;newFile.txt&quot;</span>);<br>    writer.write(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    writer.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用Scanner来读取文件内容.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">myFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newFile.txt&quot;</span>);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">fileScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(myFile);<br>            <span class="hljs-keyword">while</span> (fileScanner.hasNextLine()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> fileScanner.nextLine();<br>                System.out.println(line);<br>            &#125;<br>            fileScanner.close(); <span class="hljs-comment">// 把文件关闭, 否则内存泄漏</span><br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>File类的内置方法: <code>getName()</code> <code>getAbsolutePath()</code>  <code>canWrite()</code>  <code>canRead()</code> <code>length()</code></p></li><li><p>删除 (空) 文件夹: <code>.delete()</code> </p></li><li><p>Java函数 (方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Fact(<span class="hljs-number">3</span>));<br>&#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n = <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n * Fact(n - <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>异常 (Exception)</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-number">0</span> / <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> []array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    System.out.println(array[<span class="hljs-number">3</span>]);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;continue...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关键字 <code>throws</code> <code>throw</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            badCode(); <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ArithmeticException, IndexOutOfBoundsException &#123;<br>        System.out.println(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>        System.out.println(array[<span class="hljs-number">3</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>throws关键字要写在会出现异常的方法后面 (称为”异常说明”), 并定义好会出现的异常类型, 如有多个异常, 则用逗号隔开. 这样我们就可以将处理异常这种麻烦事交给上层处理. (虽然异常说明跟在出异常的方法声明的后面, 但是它并不是方法签名或方法类型的一部分. )</p><p>我们可以使用throw关键字来抛出一个异常:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        checkAge(<span class="hljs-number">17</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">&quot;Access denied: You must be at least 18 years old.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Access granted: You are old enough!&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>可以抛出多个异常, 相应的, 也要处理多个异常.</p></li><li><p>检查型异常 (checked exception) : 在编译时被检查并强制实施的异常. 非检查型异常 (unchecked exception) : RuntimeException, 运行时异常. </p></li><li><p>子类重写父类方法要抛出与父类一致的异常, 或者不抛出异常 (在继承和重写中, 异常说明只缩不扩); 子类重写父类方法所抛出的异常不能超过父类本身的范畴. (如果子类多一个Runtime Exception, 那么编译器也不会报错. 因为运行时异常与编译无关, 如<code>NullPointerException</code> )</p><p>但是构造方法是个例外, 子类的构造器可以无视基类构造器随便抛出任何异常. 但是, 如果子类的构造器调用了基类的构造器或者被编译器自动加入了一个无参的基类构造器, 那么子类构造器必须抛出所有基类构造器抛出的异常. 而子类构造器不能捕获基类构造器所抛出的异常. </p></li><li><p>如果我们要创建一个自定义的异常, 只要继承<code>Exception</code>基类即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    MyException();<br>    MyException(String msg) &#123;<br>        <span class="hljs-built_in">super</span>(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>早抛出, 晚捕获.</p></li><li><p>对知道怎么解决的异常, 要捕获; 对于自己不知道怎么解决的异常, 要抛出. 例子如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;divided by zero&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>().div(Integer.parseInt(args[<span class="hljs-number">0</span>]), <br>                                                    Integer.parseInt(args[<span class="hljs-number">1</span>])));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结合日志使用异常.</p></li><li><p>异常链: 重新抛出异常时, 希望保留原始异常的信息. </p><p>所有的<code>Throwable</code>子类都可以选择在构造器中接受一个cause对象, 作为原始的异常. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Throwable(String message, Throwable cause)<br></code></pre></td></tr></table></figure></li><li><p>针对文件等资源的IO异常问题 (需要嵌套捕获, 不方便), Java 7引入了自动关闭资源 (回收), 在相关资源类 (如<code>FileInputStream</code>) 中实现了<code>AutoCloseable</code>接口, 里面具有<code>close</code>方法, <strong>会自动关闭打开的资源</strong>, 这样一定程度上避免了使用资源的IO时嵌套的复杂的异常捕获代码.  (注意以下代码中<strong>圆括号</strong>的使用) (圆括号里面的内容叫<strong>资源说明头</strong>, 事实上, 资源说明头可以包含多个定义语句)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryWithResources</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 不是直接 &#123;&#125; 而是在 &#123;&#125; 之前用 () 包裹一个准备资源的语句 -- ()里的语句也可能发生异常, 但是这个异常是自动被处理的 (自动关闭), 这样在进入实际的 try 的内部即&#123;&#125;内, 那么这个资源被保证一定正常打开了, 如果()内部异常了, 打开的资源会被自动关上. </span><br>        <span class="hljs-keyword">try</span> (<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hi.java&quot;</span>)); <span class="hljs-comment">// 此处(位于圆括号包围内容的结尾)的分号是可选的</span><br>            <span class="hljs-comment">// FileInputStream类实现了java.lang.AutoCloseable接口</span><br>        ) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">contents</span> <span class="hljs-operator">=</span> in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// handle the error</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于一段代码可能产生多个异常, 一种做法是逐个捕获, 即<code>try &#123;&#125; catch (Exception1) &#123;&#125; catch (Exception2) &#123;&#125; ...</code> 如果多个异常之间有继承关系, 那么子类捕获在前. ( 按从小到大顺序捕获异常, 先子类后父类. )</p><p>这样的做法可能不够灵活, 可以使用<strong>组合捕获</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    x();<br>&#125; <span class="hljs-keyword">catch</span> (Exception1 | Exception2 | Exception3 e) &#123;<br>    process();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是, 由于一次异常只可能是具体的一种, 所以在若干个catch块之中至多只会执行一个. </p></li><li><p>如果程序规模足够大, 那么使用检查型异常可能不是一个好主意 (详见 <em>On Java 基础卷</em> 第15章) , 有两种补偿的方法 – 1. 利用链式异常将检查型异常包在<code>RuntimeException</code>中 2. 创建自己的 <code>RuntimeException</code> 的子类. </p></li><li><p>字节码层面, 会有Exception table, 以便跳转.</p><p>Exception table: </p><p>from |to| target| type </p><p>0 4 8 Class java&#x2F;lang&#x2F;Exception </p><p>0 4 17 any</p><p>8 13 17 any </p><p>17 19 17 any</p></li></ol><h2 id="Java-Lesson-4-String"><a href="#Java-Lesson-4-String" class="headerlink" title="Java-Lesson 4 (String)"></a>Java-Lesson 4 (String)</h2><ol><li><p>String类: final的不可被继承, 本质是final的char数组</p></li><li><p>String中的内置函数</p><ul><li>length – 长度</li><li>toUpperCase – 转换为大写</li><li>indexOf(substr) – 找到特定字符<strong>串</strong>的位置</li></ul></li><li><p>**String类中的方法 **</p><p>&#x3D;&#x3D;<strong>(注意, 由于String是不可变类, 以下方法均不能修改字符串本身, 而是返回一个改后的String类对象)</strong>&#x3D;&#x3D;</p><p><code>.equals()</code> - 判断字符串&#x3D;&#x3D;是否相等 (<strong>所以常用equals()方法</strong>)&#x3D;&#x3D;, 而 <code>==</code> 是判断是否&#x3D;&#x3D;<strong>同一</strong>&#x3D;&#x3D;  (这是一个很坑的点, 应该说, 在Java判断相等的时候, 你&#x3D;&#x3D;<em><strong>只应该想到equals这一种做法!!!</strong></em>&#x3D;&#x3D;)</p><p><strong><code>trim()</code></strong> - 移出前导或尾随的空白符</p><p><code>toCharArray()</code> - <em><strong>转换成字符数组</strong></em></p><p> <code>substring(start, stop)</code>  [起始下标, 终止下标) <em><strong>终止下标可省</strong></em>, 表示到末尾 (<em><strong>前闭后开</strong></em>)</p><p><code>charAt(index)</code> 字符串里面下标为index的字符</p><p><code>replace(s1, s2)</code> 把字符串中的s1变为s2</p><p><code>.split()</code> 返回一个<strong>String[]</strong> 类型, 为分割出的子串的数组.</p><p><code>.length()</code> 返回长度</p></li><li><p>String类对象有个特殊的创建方式, <code>String x = &quot;abc&quot;</code> x是”abc”对象的地址, 也叫作”abc”对象的引用.</p></li><li><p>String对象可以通过 “+” 串联, 也可通过 concat() 来串联. 但是字符串连接符 <code>+</code> 可以把数字 (int&#x2F;double) 或 字符(char) 和字符串加在一起, 而<code>concat()</code>方法只能连接字符串. </p></li><li><p>也可以先转换成<code>StringBuilder</code>, 通过<code>append</code>来增加 (StringBuilder还自带了reverse方法), 然后通过<code>.toString()</code>方法回来.</p></li><li><p>从字节数组创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> System.in,read(buffer);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, len);<br></code></pre></td></tr></table></figure></li><li><p>Java常考题 – 以下代码输出什么: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(str1 == str2); <br><span class="hljs-comment">// true, 因为这里&quot;abc&quot;存在常量池中, 在代码区, 指向同一块内存</span><br><span class="hljs-comment">// 这是java的一个特性 (feature) 而判断相等(非同一)最好还是用.equals()方法</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.println(str1 == str2);<br><span class="hljs-comment">// false, 因为此时&quot;abc&quot;在堆区, 他们已是不同的对象</span><br><span class="hljs-comment">// PS: str1, str2这样的局部变量在栈区</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-5-OOP"><a href="#Java-Lesson-5-OOP" class="headerlink" title="Java-Lesson 5 (OOP)"></a>Java-Lesson 5 (OOP)</h2><ol><li><p>类声明</p><p>[modifiers] class <em>ClassName</em> [<strong>extends</strong> <em>SuperClassName</em>] [<strong>implements</strong> <em>InterfaceNames</em>] {…}</p></li><li><p>modifier (修饰符) </p><p><code>final</code>: 不可有任何子类</p><p><code>public</code>: 可被包外的类访问</p><p>缺省: 是一个缺省类 (the default 又叫包私有 package-private) 只可被当前包里的类访问.</p><p><code>abstract</code>: 虚类 (抽象类) 只可被继承, 不可被实例化对象</p></li><li><p>包 (package) 的概念 </p><p>如果我想写一个类叫Student, 但是另一个人也要写一个Student类, 这就会产生名字冲突, 为了解决这个问题, 我们需要 package. </p><p>Java定义了一种命名空间, 叫做包 (package). 一个类总是归属于某一个包, 所以一个类的完整名字便是 package_name.class_name.</p><p>JDK中的 Arrays 类存放在 java.util 包中, 那么完整类名就是 java.util.Arrays. </p></li><li><p>位于同一个包的类, 可以访问包作用域的属性和方法. 如果我们想要在其他的包中调用方法, 我们需要使用import关键字. </p></li><li><p>创建包的时候, 需要为这个包取一个合适的名字. 之后, 如果其他的一个源文件包含了这个包提供的类&#x2F; 接口&#x2F; 枚举或者注释类型的时候, 都必须将这个包的声明放在这个源文件的开头.</p><p>包声明应该在源文件的<strong>第一行</strong>, 每个源文件只能有<strong>一个包声明</strong>, 这个文件中的每个类型都应用于它. (package pkg1.pkg2…)</p><p>如果一个源文件中没有使用包声明, 那么其中的类&#x2F; 函数&#x2F; 枚举&#x2F; 注释等将被放在一个无名的默认包 (unnamed package) 中.</p></li><li><p>Maven: 用于调用包</p></li><li><p>Python目录里必须包含一个<code>__init__.py</code>文件以便被Python视为包. (这个 <code>__init__.py</code> 使得Python有类似Java的包结构, 可以为空, 也可以包含一些初始化代码 (被首先执行) )</p></li><li><table><thead><tr><th></th><th>描述</th><th>常用类</th></tr></thead><tbody><tr><td>java.lang</td><td>语⾔包 (默认引⼊)</td><td>Object、String、Math、System、Exception、Class、Thread、Throwale</td></tr><tr><td>java.io</td><td>输⼊输出流的⽂件包</td><td>OutputStream、InputStream、PrintWriter、File、FileInputStream、FileOutputStream、BufferedReader、BufferedWriter</td></tr><tr><td>java.util</td><td>实⽤⼯具包</td><td>Date、Calendar、List、Map、Set、Stack、Random、Currency、Locale</td></tr><tr><td>java.net</td><td>⽹络包</td><td>URL、Socket、ServerSocket、HttpCookie</td></tr><tr><td>java.sql</td><td>数据库处理包</td><td>Connection、Statement、PreparedStatement、ResultSet</td></tr><tr><td>java.text</td><td>⽂本处理包</td><td>Format、DateFormat、NumberFormat</td></tr></tbody></table></li><li><p>第三方java库: Junit(用于测试), Weka(机器学习), Hadoop(分布式)</p></li><li><p>成员变量</p></li></ol><p>   [accessSpecifier] [final] type varaibleName [&#x3D;initial_value];</p><p>   <strong>访问控制</strong></p><p>   public–所有都能访问  (<strong>可修饰类 (仅有public和default可以修饰类)</strong>)</p><p>   protected–当前类&#x2F;当前类所在包&#x2F;当前类的子类能访问, 其他不可 </p><p>   default (缺省)–当前类&#x2F;当前类所在包能访问, (不在同一个包的) 子类不可 </p><p>   private–只有<strong>当前类</strong>能访问 (所以可以设定get和set方法来进行访问和修改).</p><p>​(protected – 包可达性 + 子类可达; default – 包可达性)</p><ol start="11"><li><p>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> x.y;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 此处变量i仅能被y包下的类访问.</span><br><span class="hljs-comment">// 因为虽然A是public, 但是i是default, 所以A的子类不能存取i</span><br></code></pre></td></tr></table></figure></li><li><p>一般来说, 对于”敏感”的数据应该设为私有变量, 从而对外界进行隔离. 通过公共方法 (get和set) 来进行访问和修改这些变量. (Java的封装性)</p></li><li><p>get… 方法 -&gt; 访问子&#x2F; 观察子; set… 变异子</p></li><li><p>方法一旦被final修饰, 则不可被重写 (覆盖).</p></li><li><p>javadoc: 文档, 提供了类或者方法的一些说明, 如参数&#x2F; 返回值, 这是java注释的⼀种. &#x2F;** … *&#x2F;</p></li><li><p>java方法的参数如果是Primitive type, 则传递过来的必须是单一值, 称Pass by value;  如果是Reference type, 则传递过来的必须是内存地址, 称Pass by reference. </p></li><li><p>值传递 (Pass by value) 在java中, 方法的实参是通过值传递的, 当方法调用时, 实参的值的<strong>拷贝</strong>会赋给方法中的参数变量. 方法中本意读该拷贝值做改变, 但不会影响到原来的变量. (方法外和内严格分开, 且无指针, 所以Java写不出swap(a, b)函数.)</p></li><li><p>Java函数参数传递<strong>某个对象的引用</strong>, 如果这时函数<strong>通过该引用改变了这个对象</strong>, 那么<em><strong>外部的索引指向的对象&#x3D;&#x3D;也被改动了&#x3D;&#x3D;</strong></em>. (类似C的指针, 不是pure function, 不安全, 所以不推荐).</p></li><li><p><strong>Integer类型的整数对象, 因为是不可变类 (类属性不会被修改), 所以不会被函数传参后通过对形参的操作改变变量名指向的东西. String类也是不可变类, 所以&#x3D;&#x3D;函数内部改动无法影响到外部的引用名所指对象&#x3D;&#x3D;.</strong> 所谓的函数内部的改动只是把这个引用的副本指向了另外的东西, 而不是把引用的副本指向的东西修改了! (所以在外部, 那个引用该指向啥还指向啥)</p></li><li><p>Python中的方法中参数是什么传递? -&gt; 赋值传递, 与Java本质一样, 只是Python没有原始类型. (所以说Java的变量名也更像标签, 用Python理解Java, 这两种语言在 pass by assignment上J几乎一致)</p></li><li><p>对象数组: 先定义一个存放对象的数组, 再建立每个对象的存储空间.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    String name;<br>    <span class="hljs-type">double</span> price;<br>&#125;<br><br>Book[] books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 定义一个存放Book对象的数组</span><br><span class="hljs-comment">/* 建立每个对象的存储空间 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; books.length; i++)<br>    books[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>构造方法 (同名, &#x3D;&#x3D;无返回值&#x3D;&#x3D;)</strong>: 对象的实例化通过构造方法来实现, new语句时自动调用, 而不能显式地调用. </p><p>(1) 构造方法名字必须与类名相同. </p><p>(2) 构造方法无返回值 (不是返回void型, 不能加void修饰, <strong>加了返回值修饰的就成了一般方法&#x3D;&#x3D;不是构造方法&#x3D;&#x3D;</strong>). </p><p>(3) 构造方法可以有多个, 构造方法可以&#x3D;&#x3D;<strong>重载</strong>&#x3D;&#x3D; (运行时会根据参数形式来具体选择构造方法). </p><p>(4) 当没有声明构造函数时, 默认含有一个无参数的构造函数, 当显式声明构造函数后, 默认的构造函数就不存在.</p></li><li><p>继承: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">// 由于super就是父类名, 而父类构造方法和类同名, 所以此处子类的构造方法中用super调用了父类的构造方法</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greet</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;WangWang..., I am &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am running!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>&#x3D;&#x3D;<strong>静态类型和实际类型</strong>&#x3D;&#x3D;: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(); <span class="hljs-comment">// Base: 静态类型, Child: 实际类型</span><br></code></pre></td></tr></table></figure><p>一个变量都有两个类型.  </p><p><strong>静态类型: 引用变量的类型, 在编译期确定, 无法改变</strong></p><p><strong>实际类型: 实例对象的类型, 在编译期无法确定, 需在运行期确定, 可以改变</strong></p></li><li><p><strong>static</strong>关键字: 是Java中用来表达隶属于”类”本身, 而不隶属于类的对象的一个关键字. (可修饰变量(静态变量), 方法(静态方法), <strong>语句块(初始化类变量)</strong>)</p></li><li><p>类变量 (Class Variable) &#x2F; 静态变量: 表示类的属性, 为所有该类的对象所共有, 为了与实例变量有所区别, 前面加<strong>static</strong>. 用来表达所有对象的共有属性, 在java类1加载之后就得到了相应的内存, 其只有一份, 不会随着对象的创建增多.</p><p><strong>在创建实例之前就已经有了</strong>, <strong>即在初始化类时就已有了</strong>. 存在Metaspace里 (Metaspace存储元信息) (占用内存的时间最久, 最不能有效利用内存空间)</p></li><li><p>类方法&#x2F; 静态方法: 一个静态方法隶属于类, <strong>专门用于处理类变量的计算</strong>, 通过类名称来调用, 而无需实例化一个对象来调用, 必须加上一个<strong>static</strong>修饰词.</p><p>静态方法可以访问更改静态变量, 但不能直接访问非静态的成员(变量和方法). </p><p>在静态方法中,<strong>this</strong>(表示当前对象的引用) ( 当需要明确指出当前对象的引用时, 才使用this关键字, 如果是在同一个类中, 那么会自动加, <strong>不要滥用this, 为了代码可读性! 原则上, 只有当类中变量和成员变量重名时才使用this指针</strong> ) 和<strong>super</strong>(表示当前对象的相应父类对象引用) <em><strong>无法使用</strong></em>. (因为this&#x2F; super所代表的对象还没产生, 既然没有对象, 就不会有实例变量.)</p><p>(变量引用) 类名或对象名与变量名之间为<code>.</code>  (方法引用) 类名或对象名与方法名之间为<code>::</code> (这个语法来自C++)</p></li><li><p>这里的 this 可以认为就是类名(即构造方法名), 会看到this.xxx 或 this() 调用构造方法等等, 其实this 替换类名 (类的构造方法名) 类似于<em>字面</em>上替换. (super同理)</p></li><li><p><strong>静态语句块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">// 静态语句块</span><br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">A1</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>静态语句块用来初始化静态变量</li><li>静态语句块<strong>不能访问非静态成员</strong></li><li>静态语句块在main方法之前被调用</li></ul></li><li><p>静态语句块用于初始化静态变量, 那么什么语句块用于初始化成员变量? – 非静态语句块 (实例语句块), 会在执行某一个构造方法之前就执行, 是与静态块类似的语法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> &#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#123; <span class="hljs-comment">// 语句块</span><br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">A2</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一语法是<strong>匿名内部类</strong>初始化所必需的. </p></li><li><p>record类 (本条参考 - Java 17 updates) : </p><p>我们常常会写这样的代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> width;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">double</span> length, <span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">this</span>.length = length;<br>        <span class="hljs-built_in">this</span>.width = width;<br>    &#125;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length; &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">width</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.width; &#125;<br><br>    <span class="hljs-comment">// Implementation of equals() and hashCode(), which specify</span><br>    <span class="hljs-comment">// that two record objects are equal if they</span><br>    <span class="hljs-comment">// are of the same type and contain equal field values.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> equals...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> hashCode...<br><br>    <span class="hljs-comment">// An implementation of toString() that returns a string</span><br>    <span class="hljs-comment">// representation of all the record class&#x27;s fields,</span><br>    <span class="hljs-comment">// including their names.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了record关键字，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 就这一行代码</span><br><span class="hljs-keyword">record</span> <span class="hljs-title class_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">double</span> length, <span class="hljs-type">double</span> width)</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>record对于创建小型<strong>不可变</strong>对象很有帮助. </p><p>record classes 提供了 1. private final修饰的成员变量和相应的公共访问方法 (*get()*方法) 2. 全参的构造方法 3. equals&#x2F; hashCode&#x2F; toString方法.</p><p>record类是final的, 即不可被继承. </p></li><li><p>record类可以用作简单的 (不可变的) 数据容器. (serve as a simple “data carrier”)</p></li><li><p>我们知道class类可以在文件中声明，也可以在类中声明&#x2F; 方法中声明。那么record类也一样，它有这几种方式：</p><p>直接在文件中声明的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">range</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DidispaceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">range</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DidispaceTest</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">range</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变参数 – 语法糖, 类型后加 <code>...</code> 来表示.  必须放在参数列表最后, 实际会被编译器当成数组. 不同的是, 类似<code>String... trailing</code> 的参数声明可以接受空参数, 这带来了一定的灵活性. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(Integer... args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Integer i : args) &#123; <span class="hljs-comment">// Java 11 支持 for (var i : args) &#123;&#125; 的写法. </span><br>        System.out.println(i + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    f();<br>    f(<span class="hljs-number">1</span>);<br>    f(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用方法重载 (特设多态), 那么你应当在至多一个重载方法上使用可变参数列表.</p></li></ol><h2 id="Java-Lesson-5-1-inheritance"><a href="#Java-Lesson-5-1-inheritance" class="headerlink" title="Java-Lesson 5.1 (inheritance)"></a>Java-Lesson 5.1 (inheritance)</h2><ol><li><p>继承</p><p>Java通过关键字extends来表达继承关系.</p><p><code>class SubClass extends SuperClassName &#123;&#125;</code></p><p>Java只支持单继承, 只有一个”直接”父类. 父类的父类也是该子类的父类, 但不是直接父类, Java中所有类都是java.lang.Object 的子类.</p></li><li><p>实际编写代码中, 继承最好不要超过3层. </p></li><li><p>重新定义父类中的变量, 父类中相应的变量被隐藏 (hidden). 可以通过super关键词来访问这些隐藏的变量, 当然static的变量可以通过类名来访问. (隐藏和覆盖, 意思都是是其虽然被改写了, 但是依然可以通过super来调出来, 其区别在于运行前确不确定)</p></li><li><p>无论是什么类型的<em><strong>变量</strong></em>被重新定义都叫隐藏, <em><strong>静态方法</strong></em>被重新定义也叫隐藏. (隐藏在编译时就分开了)</p></li><li><p>重新定义签名相同的<em>成员方法</em> (<em><strong>前提是这些方法可达</strong></em>), 就是方法重写 (Overriding).  (重写在编译时是分不开的)</p></li><li><p>定义一个与private的方法同名的方法也不叫隐藏 (因为本来就不可达) , 也不叫覆盖. 但是两者依然是分开的, 可以认为是天然的隐藏起来了.</p></li><li><p>只有既没有static也没有private修饰的成员方法被重新定义才是覆盖&#x2F; 重写 (Overriding)</p></li><li><p><strong>隐藏和重写的区别</strong></p><p>重写对应&#x3D;&#x3D;<em><strong>运行时</strong></em>&#x3D;&#x3D;, Java会在运行时判断哪个方法会被调用</p><p>(It is for non-static methods.)</p><p>隐藏对应编译时, Java在编译阶段就已经确定好了调用的对象 (即静态和实例变量&#x2F;静态方法)</p></li><li><p>early binding&#x2F; late binding 早绑定 (编译时) &#x2F; 迟绑定 (运行时)</p></li><li><p>在Java中, 任何类的构造方法, <strong>第一行语句必须是调用父类的构造方法</strong>. </p><p>如果没有明确地调用父类的构造方法, 编译器会帮我们自动加一句super(); </p><p>&#x2F;&#x2F; 如果有参数, 那么只能自己写super(3);</p></li><li><p><strong>构造方法无法继承, 它隶属于特定的类.</strong> 因此, 如果即使类没有写构造方法, 那么其也会有一个默认的构造方法, 而不是继承于父类的构造方法.</p></li><li><p>什么样的类成员会被子类继承? </p><ol><li>私有的 (private) 类成员不能被子类继承</li><li>构造方法不能被继承</li><li>公共的 (public) 和保护性的 (protected) 类成员能被子类继承, 且子类和父类可以属于不同的包</li><li>无修饰的父类成员, 仅在同一个包中才能被子类继承</li></ol></li><li><p><strong>重写</strong>可继承的函数时, 其<strong>访问权限不能</strong>比父类中被重写方法的访问权限<strong>更低</strong>, 父类protected, 子类可为public. </p></li><li><p><strong>重写</strong>可继承的函数时, 返回值如果是原始类型, 必须与原函数一致,如果是对象类型, 必须是原函数返回值或是其<strong>子类</strong></p></li><li><p>以上2条只是对重写, 若是隐藏则无以上限制.</p></li><li><p>函数重载即特设多态 (Ad hoc polymorphism), 重载是不同的函数,因为虽然函数名相同但是参数不同.</p></li><li><p>⽽重写(也叫覆盖)是重新定义⽗类中签名相同的函数. 重载是特设多态, 重写是⼦类型多态. 重载在函数调⽤时所调⽤的具体函数 (函数绑定) 在编译时确定(early binding), 重写的函数绑定在运⾏时(late binding).</p></li><li><p>重载是重复利用名称, 而重写是重复利用方法的架构. </p></li><li><p>子类每个对象也是父类的对象 (is-a), 可以直接用子类对象赋给一个父类常量. 这种转化叫作: 向上转型 (upcasting)</p></li><li><p>父类的对象不能直接赋给子类. 但是可以强制转换 ( downcasting ). 想要安全的进行向下转型  ( 避免<strong>运行时</strong>产生异常 “ClassCastException” )  时, 一般需要用运算符instanceof (判断实例是不是一个类&#x2F; 接口的子类) 来进行判断. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Dog)<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) animal;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-6-Generics"><a href="#Java-Lesson-6-Generics" class="headerlink" title="Java-Lesson 6 (Generics)"></a>Java-Lesson 6 (Generics)</h2><ol><li><p>作为一种静态类型语言, Java对参数需要固定类型, 虽然增加了安全性, 但却失去了灵活性. 通过引入“泛型” (generics) 的概念, Java可以将类型也作为一种参数, 从而实现参数多态 (参数不同, 逻辑一致).</p></li><li><p>泛型的语法: </p><p>泛型类: <code>[modifiers] class className &lt;T, E, ...&gt; &#123;...&#125;</code></p><p>泛型接口: <code>[modifiers] interface interfaceName &lt;T, E, ...&gt; &#123;&#125;</code></p><p><strong>泛型方法</strong>: <code>[modifiers] &lt;T, E, ... &gt; returnType *functionName* ( parameterList ) &#123;...&#125;</code> </p></li><li><p>形式类型参数: 在定义类&#x2F; 接口或方法时使用的类型参数. 可以用任意字母来表示, 如T, E, K, V等, 常用T, 需要加尖括号. (这对尖括号&lt;&gt;叫菱形运算符 &#x2F; 钻石运算符)</p></li><li><p>泛型类: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;A&gt; &#123; <span class="hljs-comment">// 形式类型参数</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(A a)</span> &#123;...&#125;<br>    A <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stack&lt;Integer&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 使用时需要加上实际的数据类型</span><br>        <span class="hljs-comment">// 你也可以使用 class Stack&lt;T, E, F&gt; &#123;&#125; 以支持有3种变量类型元素的栈</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型接口: 与泛型类类似.</p></li><li><p><code>public class Computer&lt;T extends Disk&gt; &#123;...&#125;</code> T是Disk的一个子类, 通过这样的方式对类型作限制. 此处的 Disk 被称为该形式类型的限定类型 (bounding type)</p></li><li><p>泛型方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(T x)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E, V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(E[] list1, V[] list2)</span> &#123;<br>    <span class="hljs-keyword">for</span> (E e : list1) <br>        <span class="hljs-keyword">for</span> (V v : list2) &#123;<br>        System.out.println(e);<br>        System.out.println(v);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在返回类型之前加一个<code>&lt;E, V&gt;</code> (<strong>形式类型参数表</strong>, 后续可以使用于参数&#x2F; 函数体)</p></li><li><p>形式类型参数和普通类型用法一样. </p></li><li><p>实际类型参数, 必须为对象类型. 在构造对象类型时, 可显示声明, 也可缺省. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericsSample&lt;Integer, Long, List&gt; t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericsSample</span>&lt;Integer, Long, List&gt;();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericsSample&lt;Integer, Long, List&gt; t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericsSample</span>&lt;&gt;();<br></code></pre></td></tr></table></figure></li><li><p>这件事情 (泛型机制使得获取一个泛型返回类型时不用再人为向下转型) 听起来很完美, 但是事实上这只是因为编译器帮你做了转型, 是编译时刻的语法糖, 真正在运行时类型信息被擦掉了. 证据: 观察字节码可知, 泛型的实际类型根本就没有在字节码中出现, 而是以java.lang.Object (或是一个父类) 代替了. </p></li><li><p>泛型背后的机制: 其实Java的泛型都是伪泛型, 其为了能够后向兼容Java旧时代 (Java 4.0及以前, 当时还没有泛型) 代码, 并不是运行时进行泛型的支持, 而是通过编译器在编译阶段对类型进行擦除. (都被擦除成Object)  如果类型是受限的, 则会替换为其限定类型.</p></li><li><p>如果是这样的泛型, 观察字节码则会看到, 类型参数被擦除到了边界类型 (父类Disk). 事实上, Java泛型的实现方式即是<strong>边界类型替换</strong>. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Disk</span>&gt; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>所以, 如果泛型的类型不匹配, 如<code>Holder&lt;Integer&gt; holder = new Holder&lt;&gt;(); holder.set(&quot;string&quot;); </code>, 在编译期就会fail, 无法通过编译. </p></li><li><p>通过泛型背后机制 (伪泛型) 理解问题:</p><ul><li><p>为什么泛型的实际参数类型不能是原始类型 (因为都会被擦除为Object或其限定类) 所以<code>List&lt;Integer&gt;</code> 是可以的而不能是int.</p></li><li><p>为什么 instanceof 判断不了泛型, 比如: <code>arg instanceof T</code> 或 <code>T&lt;String&gt; a = …; a instanceof T&lt;Integer&gt;;</code>   &#x2F;&#x2F;  Error</p></li><li><p>为什么不能用泛型创建对象, 即 T a &#x3D; new T(); (因为本质上就是new Object()) &#x2F;&#x2F; Error</p></li><li><p>为什么不能用泛型创建数组对象, 即 T[] a &#x3D; new T[size]；&#x2F;&#x2F; Error</p></li><li><p>为什么不能声明静态的泛类型的变量，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T singleInstance; <span class="hljs-comment">// ERROR</span><br>&#125;<br></code></pre></td></tr></table></figure><p>擦除后就是Object类型. 导致用 <code>Singleton&lt;Integer&gt;</code> 和 <code>Singleton&lt;String&gt;</code> 所生成的静态变量都是Object类型, 都是存在相同的data space里面的Object, 从而没有意义 (产生了冲突) ! </p><p>而声明泛型的非静态的成员变量显然是可以的.</p></li></ul></li><li><p>既然这些行为都不能做, 那么泛型到底还有啥用? </p><p>泛型的语法会让编译器帮我们做各种检查: 编译器会做<strong>类型检查</strong>, 防止实参与要求的泛型实际类型不匹配. (注意, 由于<strong>自动包装机制</strong>, int类型会被自动转换为Integer). </p><p>编译器还会做其他事情: 将所有的T都<strong>替换成边界类型</strong> (常为Object); 涉及泛型作为返回值, 编译器会<strong>自动插入一个向下转型</strong>的操作. </p></li><li><p>字节码层面是看不见”泛型”的 (没有”泛型”的概念) , 泛型只是编译器层面提供的一套语法功能, 所以使用了泛型的代码完全可以在旧版本JVM上跑. </p></li><li><p>如果真的想生成泛型对象, 怎么办?</p><ul><li>使用工厂创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(IFactory factory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = factory.create(); <span class="hljs-comment">// 实现新建对象</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFactory</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">create</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newTwithFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Holder&lt;Integer&gt; holder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Holder</span>&lt;&gt;();<br>        holder.init(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integerfactory</span>()); <span class="hljs-comment">// 给holder一个具体的工厂</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用RTTI (运行时类型识别)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; kind;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Holder</span><span class="hljs-params">(Class&lt;T&gt; kind)</span> &#123;<br>        <span class="hljs-built_in">this</span>.kind = kind;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.t = kind.newInstance(); <span class="hljs-comment">// 这样的生成实例的写法要求kind必须有一个无参构造器 </span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Holder&lt;Integer&gt; holder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Holder</span>&lt;&gt;(Integer.class);<br>        holder.init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**<em>多个边界</em> (Bounds) – 这里传递出的信息是, 在表示边界时的 <em>extends</em> 关键字与表示类继承时的含义不一样, 表达边界时允许使用 <code>&amp;</code> 来表达还实现了若干个接口. **</p><p>Java只允许继承一个父类, 但是可以实现多个接口, 这使得泛型语法可以有多个边界. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasColor</span> &#123; java.awt.Color <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dimension</span> &#123; <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> x, y, z; &#125;<br><span class="hljs-comment">// ColoredDimension 里面的泛型类型T既继承了Dimension又实现了HasColor接口. </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColoredDimension</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dimension</span> &amp; HasColor&gt; &#123;...&#125; <span class="hljs-comment">//  &amp; 用来分隔多个边界.</span><br></code></pre></td></tr></table></figure><p>注意: 如果既有父类又有父接口, 那么仅有的那一个父类一定放在多个边界的第一个, 后面跟着的是若干个父接口. (为什么? 因为父类很特殊, 至多有一个, 其放在最前面对编译检查是有利的. )</p></li><li><p>例子: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plate</span>&lt;T&gt; &#123;<br><span class="hljs-keyword">private</span> T item;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Plate</span><span class="hljs-params">(T t)</span> &#123;item = t;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;item = t;&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> item;&#125;<br>&#125;<br><span class="hljs-comment">// 尝试创建一个装苹果的盘子</span><br>Plate&lt;Fruit&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plate</span>&lt;Apple&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>()); <span class="hljs-comment">// Compile Error! </span><br></code></pre></td></tr></table></figure><p>装苹果的盘子无法转换成装水果的盘子 (不是父类子类关系!) , 即使苹果是一种水果. </p><p>回到父类和子类的最初的定义: 子类是父类的特例, 父类具有的特性子类必须都要有. </p><p>所以, 装苹果的盘子不是装水果的盘子的子类, 它不具备装水果的盘子的性质 – 可以装任何水果 (香蕉, 蛇果, 车厘子, …) , 他们没有一个是另一个的特殊化的关系. </p></li><li><p>协变 (构造的复杂类型后保持原来的父子关系), 逆变 (仍然有父子关系, 但是与原来相反) , 不变 (没有父子关系) . (根据上一条所述, <em>水果 -&gt; 装水果的盘子</em> 是一种<strong>不变</strong>构造)</p></li><li><p>如何解决以上例子中的问题? </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示的是一个能放任意**一种**水果以及任意**一种**水果派生类的盘子</span><br>Plate&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plate</span>&lt;Apple&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br>List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; flist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Apple&gt;();<br></code></pre></td></tr></table></figure></li><li><p>泛型通配符 <strong><code>?</code></strong> 到底表达什么意思? </p><p>答: 表示一定是<strong>一个</strong>确定的具体的类型, 但是具体这个类型是什么, 不确定. </p><p>比如一个装苹果的盘子, 是装一种确定的水果的盘子的子类, 所以上一条中的写法是可通过编译的. </p><p>通配符带来的意思是a plate will hold “some specific (特定的) type of fruit which is not specify (不确定)”. </p></li><li><p>所以, 一个装任意一种特定类型水果的盘子不能再被存入任何元素, 无论是new Fruit() 还是 new Apple(), 因为编译器的能力无法确定这个 <strong><code>?</code></strong> 表示的确切类型是哪一种, 为了安全性, 编译器不会再允许放入任何元素. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Plate&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plate</span>&lt;Apple&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br><span class="hljs-comment">// 不能再存入任何元素</span><br>p.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>()); <span class="hljs-comment">// Error!</span><br>p.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>()); <span class="hljs-comment">// Error!</span><br><span class="hljs-comment">// 读取出来的东西只能放在Fruit或它的基类里</span><br><span class="hljs-type">Fruit</span> <span class="hljs-variable">newFruit1</span> <span class="hljs-operator">=</span> p.get();<br><span class="hljs-type">Object</span> <span class="hljs-variable">newFruit1</span> <span class="hljs-operator">=</span> p.get();<br></code></pre></td></tr></table></figure></li><li><p>超类通配符 (supertype wildcard)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Plate&lt;? <span class="hljs-built_in">super</span> Fruit&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plate</span>&lt;Apple&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>()); <span class="hljs-comment">// 只能初始化为Fruit及其超类</span><br><span class="hljs-comment">// 可以存入任何Fruit类及其子类</span><br>p.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>());<br>p.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br><span class="hljs-comment">// 读取出来的东西只能放在Object类里 (编译器不知道你这个超类有多超, 只能保守估计)</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">newFruit1</span> <span class="hljs-operator">=</span> p.get();<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">newFruit1</span> <span class="hljs-operator">=</span> p.get(); <span class="hljs-comment">// Error!</span><br></code></pre></td></tr></table></figure></li><li><p><strong>泛型的类型通配符 (Wildcard)</strong></p><ul><li><p>之前一个泛型对象名只能引用同一种泛型对象, 如GeneralType&lt;String&gt; a 只能指向GeneralType&lt;String&gt;的对象 (有时候不希望list&lt;A&gt;和list&lt;B&gt;无任何关系)</p></li><li><p>如果要使用同一个泛型对象名去引用不同的泛型对象, 就需要使用通配符 “?” 创建泛型类对象</p></li><li><p>但要求不同泛型对象的类型实参<strong>必须是某个类或者其子类, 或实现某个接口泛型类名</strong> &lt;? extends T&gt; 0 &#x3D; null;</p></li><li><p>除了可以利用extends限定实际类型参数是某个类型的子类外 (设置上限), 还可以用super 限定其是某个类的父类 (设置下限)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">泛型类型 &lt;? <span class="hljs-built_in">super</span> anyclass&gt; x = <span class="hljs-literal">null</span>; <br></code></pre></td></tr></table></figure></li></ul></li><li><p>例子: (extends 和 super 刚好是相反的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralType</span> &lt;T&gt; &#123;<br>  T obj;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span> <span class="hljs-params">(T obj)</span>&#123;<br>    <span class="hljs-built_in">this</span>.obj = obj;<br>  &#125;<br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getObj</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>&#125;<br><br>GeneralType &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; x = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 类型通配符创建类, 并实例化为x</span><br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneralType</span> &lt;Long&gt; ();<br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneralType</span> &lt;Integer&gt; ();<br><span class="hljs-type">Number</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x.getObj(); <span class="hljs-comment">// Correct</span><br>x.setObj(Integer.valueOf(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Error, 因为x类型并不可判定(编译器为了Safe而不让x写入)</span><br><br>GeneralType &lt;? <span class="hljs-built_in">super</span> Integer&gt; x = <span class="hljs-literal">null</span>;<br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneralType</span> &lt;Object&gt; ();<br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeneralType</span> &lt;Number&gt; ();<br><span class="hljs-type">Number</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x.getObj(); <span class="hljs-comment">// Error, x到底是什么类编译器不可判定, 为了safe-不能把超类赋值给子类</span><br>x.setObj(Integer.valueOf(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Correct</span><br></code></pre></td></tr></table></figure></li><li><p>Java&#x3D;&#x3D;<strong>泛型</strong>&#x3D;&#x3D;举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>List&lt;Number&gt; number = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( List&lt;?&gt; data )</span> &#123; <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;data.length(); i++) &#123; <br>    System.out.println(data.get(i)); <br>  &#125;<br>&#125;<br>printArray(name)<br>printArray(age)<br>printArray(number)<br></code></pre></td></tr></table></figure></li><li><p>Self-bounded types 自限定类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfBounded</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;T&gt;&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>目的是实现协变或者逆变 (参数协变(重载或者自限定), 返回值协变(Java 5自动支持) ), 非常漂亮的设计. </p><p>自限定的限制只服务于强制继承关系, 表示该类使用的类型参数和使用该参数的类是同一种基类. </p><p>也可以将自限定用于泛型方法:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;T&gt;&gt; T <span class="hljs-title function_">f</span><span class="hljs-params">(T arg)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>自限定类型</strong>自然地支持<strong>参数协变类型 (covariant argument type)</strong>: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfBoundSetter</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBoundSetter</span>&lt;T&gt;&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T arg)</span>;<br>&#125;<br><span class="hljs-comment">// 这里的set方法接收确切类型参数Setter</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Setter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBoundSetter</span>&lt;Setter&gt; &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfBoundingAndCovariantArguments</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Setter s1, Setter s2)</span> &#123;<br>        s1.set(s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Java Optional 类, 更优雅处理null.</p><p><strong>创建 Optional 对象</strong></p><p>1）可以使用静态方法 <code>empty()</code> 创建一个空的 Optional 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; empty = Optional.empty();<br>System.out.println(empty); <span class="hljs-comment">// 输出：Optional.empty</span><br></code></pre></td></tr></table></figure><p>2）可以使用静态方法 <code>of()</code> 创建一个非空的 Optional 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; opt = Optional.of(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(opt); <span class="hljs-comment">// 输出：Optional[name]</span><br></code></pre></td></tr></table></figure><p>当然了，传递给 <code>of()</code> 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>Optional&lt;String&gt; optnull = Optional.of(name);<br></code></pre></td></tr></table></figure><p>3）可以使用静态方法 <code>ofNullable()</code> 创建一个即可空又可非空的 Optional 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);<br>System.out.println(optOrNull); <span class="hljs-comment">// 输出：Optional.empty</span><br></code></pre></td></tr></table></figure><p><code>ofNullable()</code> 方法内部有一个三元表达式，如果为参数为 null，则返回私有常量 EMPTY；否则使用 new 关键字创建了一个新的 Optional 对象——不会再抛出 <code>NPE</code> 异常了。</p><p><strong>判断值是否存在</strong></p><p>可以通过方法 <code>isPresent()</code> 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 <code>obj != null</code> 的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; opt = Optional.of(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(opt.isPresent()); <span class="hljs-comment">// 输出：true</span><br><br>Optional&lt;String&gt; optOrNull = Optional.ofNullable(<span class="hljs-literal">null</span>);<br>System.out.println(opt.isPresent()); <span class="hljs-comment">// 输出：false</span><br></code></pre></td></tr></table></figure><p>Java 11 后还可以通过方法 <code>isEmpty()</code> 判断与 <code>isPresent()</code> 相反的结果。</p><p><strong>非空表达式</strong></p><p>Optional 类有一个非常现代化的方法——<code>ifPresent()</code>，允许我们使用函数式编程的方式执行一些代码，因此，我把它称为非空表达式。如果没有该方法的话，我们通常需要先通过 <code>isPresent()</code> 方法对 Optional 对象进行判空后再执行相应的代码：</p><p>有了 <code>ifPresent()</code> 之后，可以直接将 Lambda 表达式传递给该方法，代码更加简洁，更加直观。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; opt = Optional.of(<span class="hljs-string">&quot;name&quot;</span>);<br>opt.ifPresent(str -&gt; System.out.println(str.length()));<br></code></pre></td></tr></table></figure><p>Java 9 后还可以通过方法 <code>ifPresentOrElse(action, emptyAction)</code> 执行两种结果，非空时执行 action，空时执行 emptyAction。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; opt = Optional.of(<span class="hljs-string">&quot;name&quot;</span>);<br>opt.ifPresentOrElse(str -&gt; System.out.println(str.length()), () -&gt; System.out.println(<span class="hljs-string">&quot;为空&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>设置（获取）默认值</strong></p><p>有时候，我们在创建（获取） Optional 对象的时候，需要一个默认值，<code>orElse()</code> 和 <code>orElseGet()</code> 方法就派上用场了。</p><p><code>orElse()</code> 方法用于返回包裹在 Optional 对象中的值，如果该值不为 null，则返回；否则返回默认值。该方法的参数类型和值得类型一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">nullName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Optional.ofNullable(nullName).orElse(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(name); <span class="hljs-comment">// 输出：name</span><br></code></pre></td></tr></table></figure><p><code>orElseGet()</code> 方法与 <code>orElse()</code> 方法类似，但参数类型不同。如果 Optional 对象中的值为 null，则执行参数中的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">nullName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Optional.ofNullable(nullName).orElseGet(()-&gt;<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(name); <span class="hljs-comment">// 输出：name</span><br></code></pre></td></tr></table></figure><p><strong>获取值</strong></p><p>直观从语义上来看，<code>get()</code> 方法才是最正宗的获取 Optional 对象值的方法，但很遗憾，该方法是有缺陷的，因为假如 Optional 对象的值为 null，该方法会抛出 NoSuchElementException 异常。这完全与我们使用 Optional 类的初衷相悖。</p><p>建议 <code>orElseGet()</code> 方法获取 Optional 对象的值。</p><p><strong>过滤值</strong></p><p>新的任务：用户注册时对密码的长度进行检查。</p><p>Optional 类的 <code>filter()</code> 方法，就派上了用场。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterOptionalDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;<br>        Optional&lt;String&gt; opt = Optional.ofNullable(password);<br>        System.out.println(opt.filter(pwd -&gt; pwd.length() &gt; <span class="hljs-number">6</span>).isPresent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>filter()</code> 方法的参数类型为 Predicate（Java 8 新增的一个函数式接口），也就是说可以将一个 Lambda 表达式传递给该方法作为条件，如果表达式的结果为 false，则返回一个 EMPTY 的 Optional 对象，否则返回过滤后的 Optional 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 过滤长度6~10的密码 */</span><br>Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; <span class="hljs-number">6</span>;<br>Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; <span class="hljs-number">10</span>;<br><br>password = <span class="hljs-string">&quot;1234567&quot;</span>;<br>opt = Optional.ofNullable(password);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> opt.filter(len6.and(len10)).isPresent();<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p><strong>转换值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptionalMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;name&quot;</span>;<br>        Optional&lt;String&gt; nameOptional = Optional.of(name);<br>        Optional&lt;Integer&gt; intOpt = nameOptional<br>                .map(String::length);<br><br>        System.out.println( intOpt.orElse(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这个例子中，<code>map()</code> 方法的参数 <code>String::length</code>，意味着要 将原有的字符串类型的 Optional 按照字符串长度重新生成一个新的 Optional 对象，类型为 Integer。</p><p>把 <code>map()</code> 方法与 <code>filter()</code> 方法结合起来: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; <span class="hljs-number">6</span>;<br>Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; <span class="hljs-number">10</span>;<br>Predicate&lt;String&gt; eq = pwd -&gt; pwd.equals(<span class="hljs-string">&quot;password&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> opt.map(String::toLowerCase).filter(len6.and(len10).and(eq)).isPresent();<br>System.out.println(result);<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-7-FP-Interface"><a href="#Java-Lesson-7-FP-Interface" class="headerlink" title="Java-Lesson 7 (FP &amp; Interface)"></a>Java-Lesson 7 (FP &amp; Interface)</h2><ol><li><p>为什么要函数式编程? 因为如果没有函数式, 单纯面向对象, 一切都是名词, 基于名词去做某件事常常是不必要的, 这就导致Java代码中出现很多的不必要的繁杂繁冗. (函数式编程是一种声明式的编程风格, 函数是没有副作用的, 外部的状态不因函数的执行而改变, 这带来的好处就是使得并发度尽可能的高). </p></li><li><p>lambda表达式也是语法糖, 在JVM上, 一切都是类和对象. </p></li><li><p>Java Lambda表达式和使用函数作为参数:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] calculate(BiFunction&lt;<span class="hljs-type">int</span>[][], <span class="hljs-type">int</span>[][], <span class="hljs-type">int</span>[][]&gt; func) &#123;<br>    func.apply(A, B); <span class="hljs-comment">// 这里BiFunction为一个双参数的函数(单参数去掉Bi), 它被作为参数传入, 以待调用</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] plusFromConsole() &#123;<br><span class="hljs-keyword">return</span> calculate(<span class="hljs-built_in">this</span>::plus); <span class="hljs-comment">// 所在类里面的一个方法plus, 作为参数传入</span><br><span class="hljs-comment">//  return calculate((a, b)-&gt;plus(a, b)); // lambda写法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>lambda表达式: </p><p><code>(para1, para2, ...) -&gt; &#123; code block &#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>    System out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>() -&gt; System.out.println(<span class="hljs-string">&quot;Hello Java&quot;</span>);<br></code></pre></td></tr></table></figure><p>语法糖: </p><p>参数类型可以明确声明, 也可省略, 编译器根据上下文推断. </p><p>只有一个参数时, 圆括号可省略; </p><p>只有一条语句, {}可省略. 如:  <code>a -&gt; a + 1</code></p></li><li><p><strong>函数式接口</strong></p><ul><li>函数式接口是只包含一个抽象方法声明的接口</li><li>每个<strong>lambda表达式 (或一个形如<code>A::foo</code> &amp; <code>a::foo</code> 的方法引用, 本质上方法引用也是lambda表达式的简化) 都能隐式地赋给函数式接口</strong>.</li></ul><p><code>java.lang.Runnable</code>就是一种函数式接口, 在Runnable接口中只声明一个抽象方法<code>void run()</code></p></li><li><p><strong>其他常见的函数式接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Consumer&lt;E&gt; 函数式接口, 消耗一个E类型, 返回void.</span><br>Consumer&lt;Integer&gt; c = (<span class="hljs-type">int</span> x) -&gt; &#123;System.out.println(x) &#125;;<br><span class="hljs-comment">// BiConsumer&lt;K, V&gt; 和Consumer类似</span><br>BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="hljs-string">&quot; : &quot;</span> + y);<br><span class="hljs-comment">// Predicate&lt;E&gt; 预测. 参数是E, 返回布尔值</span><br>Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="hljs-literal">null</span> &#125;;<br></code></pre></td></tr></table></figure></li><li><p>定义自己的函数式接口 <code>@FunctionalInterface</code> 是Java 8新加入的一种接口, 用于指明该接口类型声明是根据Java语言规范定义的函数式接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WorkerInterface</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeWork</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>java.util.function包里的函数式接口:</p><p><code>Interface Function&lt;T, R&gt;</code> </p></li><li><p>实际使用举例: </p><p>使用现成的函数式接口: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, Integer&gt; myFunc = a -&gt; a + <span class="hljs-number">1</span>;<br>myFunc.apply(<span class="hljs-number">1</span>);<br>System.out.println(myFunc.apply(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>自己定义需要的函数式接口并使用: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Func</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">boolean</span> bl)</span>;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">Func</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> (a, b, c, bl) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (bl) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> a * b * c + <span class="hljs-number">114514</span>;<br>        &#125;<br>  &#125;;<br>    System.out.println( fc.apply(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>) );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果要用函数式编程的方式实现递归, 则为了避免使用未初始化变量, 需要运用<strong>字段</strong>来作为递归的函数式接口的声明. (对于纯函数的支持在这一点上不如Python, 然而Python的函数式也不够纯 (&gt;_&lt;) )</p></li><li><p>构造方法 (new) 的方法引用, 例如 <code>MakeNoArgs mna = Dog::new; </code> 然后就可以通过<code>mna,apply()</code>创建新<code>Dog</code>对象. </p></li><li><p>Java 8提供了有限但是还算可以的闭包支持, 也就是实际上lambda表达式也可以改变一些可达的变量. 到底哪些是可改变的? 1. 外围类的字段. 2. final的局部变量或者是实际上final的局部变量 (如<code>List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); l.add(5); </code> , l这个局部变量的指向实际上没有变, 尽管指向的对象自己发生了一些改变.)</p></li><li><p><strong>方法重载 Method Overloading</strong>:</p><p>方法重载可以让我们使用相同的方法名, 来处理不同的参数, 比如下面这些方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">float</span> num1, <span class="hljs-type">float</span> num2)</span> &#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> num1, <span class="hljs-type">double</span> num2)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>每个类中可以有一个特殊的构建函数, 它用于初始化实例. 构建函数是一个实例被创建时最先被调用的函数, 每次创建实例的时候, 它的构建函数都会被调用.</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        name = <span class="hljs-string">&quot;Samuel&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(student.name); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   上例中, Student就是构建函数, 构建函数不能有返回值, 而且函数名必须和类名一致.</p><ol start="11"><li><p>可以在类中创建了两个同名函数, 但是两者参数不同, 这就是重载 (Overload).</p></li><li><p>修饰访问权限的关键词是 public&#x2F; private&#x2F; protected. 被定义为public的class, attributes, method可以被任何类访问, 如果是private那么就无法被其他类访问, protected适用于继承关系间的类, 被定义为protected的属性和方法可以被子类访问.</p></li><li><p>Java继承 子类名 <code>extends</code> 父类名</p></li><li><p>数据抽象可以通过 abstract class 或 interface (接口) 实现. abstract 关键字是一个用于类和方法的修饰符, 我们无法创建 abstract class 类型的实例 ( 不能用new运算符 ), 这种抽象类<strong>只能被继承</strong>. 而 abstract method 只能定义在 abstract class 中, 这种方法没有具体执行内容. 一个抽象类既可以有抽象方法也可以有正常的方法: </p></li><li><p>如果一个类中没有包含足够的信息来描绘一个具体的对象 (方法没实现), 这样的类就是抽象类. 在抽象类⾥, 不定义⽅法体, 只需声明不实现的方法 – 抽象方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 抽象类只能被继承 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greet</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Zzz&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teenager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">greet</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a teenager.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>抽象类的子类可以是抽象类, 如果子类不是抽象类, 那么其必须实现父类中的所有抽象方法.</p></li><li><p>抽象类不能用final修饰. (抽象类就是为了继承, 而final不允许继承)</p></li><li><p>抽象类中不一定包含抽象方法, 但包含抽象方法的类一定为抽象类.</p></li><li><p><em><strong>接口 Interface</strong></em></p><p>另一个实现数据抽象的方式就是使用接口 (interface). 一个接口就是<em>完全的抽象类</em>, 其中<del>只</del>含有抽象方法 (不含一般的方法) , 这些方法中是没有任何逻辑代码的. 类的主要作用便是定义一些特定的方法, 具体逻辑让正常的类实现.</p><p>可以认为, 接口就是一个<em>抽象程度很高的基类</em>. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goToSchool</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeExam</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口没有构造方法.</p></li><li><p><strong>接口的变量都是 static final 修饰的</strong>, 缺省的也是静态常量, 所以<strong>必须赋初始值</strong>. (静态常量就是只有一份, 常量是没有一个实例就有一份, 一般常量一份就够了, 所以常常用static final)</p></li><li><p>接口的成员<strong>可访问性都是&#x3D;&#x3D;public (所以子类相应的成员必须也是public)&#x3D;&#x3D;</strong> (缺省也是public)</p></li><li><p>接口中除了抽象方法之外, 还可以含有<strong>静态方法</strong>和<strong>default</strong> (默认方法) . default方法中的实现会被所有implement了该接口的子类所具有.</p></li><li><p>如果要使用接口的方法, 那么具体的类必须实现 ( <strong>implements</strong> ) 其接口. 只要被实现, 具体的类必须将接口方法的具体逻辑全部实现: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Student</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goToSchool</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m going to school.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeExam</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m taking an exam.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意, 在接口中, 缺省的成员方法也是public, 但是在实现中, 每个方法的<strong>public</strong>修饰不能省, 否则会编译失败.</p></li><li><p>一个类可以实现 (implement) 多个接口 (interface) , 如: <code>public class Person implements Student, Employee &#123;...&#125;</code></p></li><li><p>&#x3D;&#x3D;接口可以作为一种<em><strong>引用类型</strong></em> (静态类型) 使用&#x3D;&#x3D;, (<strong>但是万万不可作为实际类型</strong>) 可以声明接口类型的变量或数组, 并用它来访问实现该接口的类的对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IShape</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br>  <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPI</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(PI);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;这是⼀个图形&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CireCleForI</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IShape</span>&#123;<br>  <span class="hljs-type">double</span> radius;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CireCleForI</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;<br>    <span class="hljs-built_in">this</span>.radius = r;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> PI*radius*radius;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*PI*radius;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestIShape</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">IShape</span> <span class="hljs-variable">cir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CireCleForI</span>(<span class="hljs-number">2.2</span>);<br>    System.out.println(<span class="hljs-string">&quot;⾯积 ： &quot;</span>+ cir.getArea());<br>    System.out.println(<span class="hljs-string">&quot;周⻓ ： &quot;</span>+ cir.getLength());<br>    cir.getInfo();<br>    IShape.showPI();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口继承: </p><ul><li>接口可通过extends关键字声明该新接口是某个已存在的父接口的子接口, 它将继承父接口的所有变量与方法 (静态方法除外, 静态方法只能通过接口名来访问)</li><li>接口支持多继承 (一个接口可以继承多个接口, <strong>接口不可以继承类</strong>, 多个父接口用逗号隔开)</li><li>如果接口中定义了与父接口同名的常量或相同的方法, 则<em><strong>父接口中的常量和静态方法被隐藏, 默认方法和抽象方法被重写</strong></em>.</li></ul></li><li><p>可以利用接口继承轻松地为接口创建一个别名: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">G</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">F</span> &#123;&#125; <span class="hljs-comment">// 接口G是接口F的别名. </span><br></code></pre></td></tr></table></figure></li><li><p>利用default方法实现混入: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 如果不用default的话则不能给出内部实现</span><br>    System.out.println(<span class="hljs-string">&quot;I can fly!&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I can swim!&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>, Swimmable &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意: 接口里面所有方法默认是public访问修饰的, 这里default关键字不是访问修饰符, 而是default关键字. </p></li><li><p>接口多继承中的名字冲突问题</p><ul><li>接口的多重继承中可能存在常量名或方法名重复的问题, 即名字冲突问题</li><li>对于常量, 若名称不冲突, 子接口可以继承多个父接口中的常量, 但如果多个父接口中有同名的常量, 则必须通过 <em>接口名.常量名</em> 区分.</li><li>对于多个父接口中存在同名的方法包含默认方法 (default) 时, 也会发生命名冲突, 这时不能通过 <em>接口名.默认方法名</em> 来解决. (显然是不能的, 因为default是实例方法, 都没有实例, 哪里有这个方法呢?) 必须要在当前类中自己新定义一个同名的方法来覆盖才行.</li><li>而此时如果想要调用被覆盖的方法, 要用<em>父接口名.super.方法名</em> (一般是super.方法名, 这里加一个父接口名是为说清楚到底是哪个父接口)</li></ul></li><li><p>如果发生了继承类和实现接口的命名冲突, 那么“类”优先, 继承的父方法中的同名方法. (先认为子类的方法是所继承的父类的方法)</p></li><li><p>继承代表的类之间的关系是 <code>is-a</code> 关系, 而接口的类之间关系则是<code>has-a</code> 关系 (组合)</p></li></ol><h2 id="Java-Lesson-8-Stream"><a href="#Java-Lesson-8-Stream" class="headerlink" title="Java-Lesson 8 (Stream)"></a>Java-Lesson 8 (Stream)</h2><ol><li><p>查看变量所在类和类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>System.out.println(a.getClass());<br>System.out.println(a.getClass().getSimpleName());<br>System.out.println(a.getClass().getTypeName());<br></code></pre></td></tr></table></figure></li><li><p>Java迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; i_ci = cities.iterator(); <br><span class="hljs-keyword">while</span>( i_ci.hasNext() ) &#123;<br>System.out.println(i_ci.next());<br>&#125;<br>Iterator&lt;Integer&gt; i_nu = numbers.iterator(); <br><span class="hljs-keyword">while</span>( i_nu.hasNext() ) &#123;<br>System.out.println(i_nu.next());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>迭代器的坑: 不要在列表迭代中对原来的迭代器作改变 (删除). </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>));<br><span class="hljs-keyword">for</span> (Integer num : numbers) &#123;<br> numbers.remove(num); <span class="hljs-comment">// dangerous!!! mutates the list we&#x27;re iterating over</span><br>&#125;<br>System.out.println(numbers); <span class="hljs-comment">/* list empty here? */</span><br></code></pre></td></tr></table></figure><p>正确的做法是, 新建一个数组, 过滤掉原来的. (本质是新建而不是删除)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-keyword">for</span> (Integer num : numbers) &#123;<br>  <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">100</span>)<br>    newList.add(num);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个正确但是<strong>不推荐</strong>的做法: (利用迭代器) (不推荐是因为 – 多个迭代器指向同一个对象时出问题; 多线程会出问题)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>));<br>Iterator&lt;Integer&gt; iter = numbers.iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> iter.next();<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">100</span>) <br>        iter.remove(); <span class="hljs-comment">// 此处迭代器会无误地指向删除元素的下一个, 从而正确完成过滤的任务</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数组合 <code>andThen</code> <code>compose</code> <code>and</code> <code>or</code> <code>negate</code></p></li><li><p>流的常用操作: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* map */</span> <br>List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <br>List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i * i).collect(Collectors.toList());<br>squaresList = numbers.stream().map( i -&gt; i * i).distinct().collect(Collectors.toList()); <span class="hljs-comment">// distinct去重复值</span><br><br><span class="hljs-comment">/* filter */</span><br>List&lt;String&gt;strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>); <br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();<br><br><span class="hljs-comment">/* sorted */</span><br>List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <br>List&lt;Integer&gt; sortedList = numbers.stream().sorted().collect(Collectors.toList());<br>List&lt;Integer&gt; sortedList = numbers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());<br>numbers.stream().sorted((a, b) -&gt; &#123;<span class="hljs-keyword">return</span> a.compareTo(b);&#125;).forEach( n -&gt; System.out.println(n) );<br><br><span class="hljs-comment">/* reduce */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">reduced</span> <span class="hljs-operator">=</span> IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>).reduce((a, b) -&gt; a + b).getAsInt();<br><br><span class="hljs-comment">/* Iterate */</span><br>Stream&lt;Integer&gt; stream = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">6</span>);<br>stream.forEach(System.out::println);<br><br><span class="hljs-comment">/* Match */</span><br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">allMatch</span> <span class="hljs-operator">=</span> list.stream().allMatch(e -&gt; e &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">//false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">anyMatch</span> <span class="hljs-operator">=</span> list.stream().anyMatch(e -&gt; e &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">//true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">noneMatch</span> <span class="hljs-operator">=</span> list.stream().noneMatch(e -&gt; e &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">/* Min, Max */</span><br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> list.stream().max((a, b) -&gt; a.compareTo(b)).get(); <span class="hljs-comment">// 5</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> list.stream().min(Integer::compareTo).get(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>创建一个String对象的”流”, 将其中每一个对象交给filter过滤, 最后forEach()会对每个保留下来的对象应用println方法引用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foobar&quot;</span>, <span class="hljs-string">&quot;foobaz&quot;</span>, <span class="hljs-string">&quot;fongopuckey&quot;</span>)<br>    .filter(s -&gt; s.length() &lt; <span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p>流是一个与任何特定存储机制都没有关系的元素序列, 事实上, 我们说流”没有存储”.</p></li><li><p>借助流显示随机的5-20之间的整数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// stream/Randoms.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Randoms</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>)<br>.ints(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>)<br>.distinct()<br>.limit(<span class="hljs-number">7</span>)<br>.sorted()<br>.forEach(System.out::println);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先为Random对象设置一个种子(这样程序每次运行都会得到相同的结果). ints() 方法会生成一个流, 两个参数可以设置所生成值的上下界. 这里生成了一个由随机的int组成的流, 我们使用中间流操作**distinct()<strong>去掉重复的值, 再使用</strong>limit()**选择前7个值. 然后我们告诉它, 希望元素是有序的(sorted()). 最后, 我们使用了 ForEach(), 它会根据我们传递的函数, 在每个流对象上执行一个操作. 这里我们传递了一个方法引用<code>System.out::println</code>, 用于将每个条目显示在控制台上.</p></li><li><p>collect会将将流 (惰性) 收集起来: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;Use&gt; predicate1 = user -&gt; user.getAge() &lt; <span class="hljs-number">21</span>;<br>List&lt;User&gt; collect = list.stream().filter(predicate1).filter(user -&gt; user.getSalary() &gt; <span class="hljs-number">2000</span>).collect(Collections.toList()).forEach(System.out::println);<br><span class="hljs-comment">// 构建流, 过滤, 收集器收集, 逐个打印</span><br></code></pre></td></tr></table></figure></li><li><p>foreach是对列表操作, map &#x2F; reduce则是对流操作: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** map */</span><br>list.stream().map(num-&gt;num + <span class="hljs-number">10</span>);<br><span class="hljs-comment">/** reduce */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span>, (a, b) -&gt; a + b).get()<br></code></pre></td></tr></table></figure></li><li><p>流还有 <code>distinct()</code>操作, 把相同的元素变为一个. 还有<code>sorted(Comparator.reserveOrder())</code></p></li><li><p>Iterate 迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">6</span>); <span class="hljs-comment">// 前项推后项, 从0开始</span><br>stream.forEach(System.out::print);<br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* Output: 0246810</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-9-Reflection"><a href="#Java-Lesson-9-Reflection" class="headerlink" title="Java-Lesson 9 (Reflection)"></a>Java-Lesson 9 (Reflection)</h2><ol><li><p>Introspection 自省: 运行时观察到类型信息</p></li><li><p>Reflection 反射: 不仅是检查当前对象的类型, 还可以修改对象的一些性质 (控制改变). </p></li><li><p>反射的核心是JVM在运行时动态加载类或调用&#x2F;访问属性, 它不需要事先 (静态编译器) 知道运行对象是谁. </p></li><li><p><em><strong>反射 (Reflection)</strong></em>  反射是一种在运行时可以检视自身程序和操纵程序内部属性的一种语言特性 (不是java独有的). 比如对于Java而言, 反射可以使其运行时动态的加载类并获取类的详细信息, 从而可以操作类和对象的属性和方法.</p></li><li><p>反射给静态语言Java带来了动态性. 反射机制允许程序在执行期借助反射API获得任何类的内部信息, 并能直接操作任意对象的内部属性和方法. (通过对象得到类的属性&#x2F; 方法&#x2F; 构造器…)</p></li><li><p>反射的坏处,  比正向直接执行相应的操作慢多了. (几十倍 - 上百倍) 关闭语言访问检查可以一定程度上快一些. </p></li><li><p>在加载完类后, 在堆内存区就产生了一个Class 类型的对象, 包含了完整的类的结构信息. </p></li><li><p>实体类 entity, 也称pojo (简单Java对象)</p></li><li><p><code>Class c = Class.forName(&quot;java.util.Stack&quot;);</code> 这里是大写Class, 是反射语法, Stack (栈) 这个类就被加载到 c 这个变量里面去了. 然后通过这个c 可以得到Stack的方法和变量. ( <code>c.getDeclaredMethods()</code> )</p></li><li><p>反射举例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DumpMethods</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Stack&quot;</span>);<br>Method m[] = c.getDeclaredMethods();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m.length; i++)<br>System.out.println(m[i].toString());<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>System.err.println(e);<br>&#125;<br>  &#125;   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Class类的创建方式: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> person.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.reflection.Student&quot;</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Student.class;<br><span class="hljs-comment">// 仅对内置类型的包装类</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Integer.TYPE;<br></code></pre></td></tr></table></figure></li></ol><p>​还可以用对象的 <code>.getSuperClass()</code> 方法. </p><ol start="12"><li><p>很多类型都有Class对象: 各种类, 接口, 数组, 枚举, 注解, 基本数据类型 (包装类), void.  数组只要是同样类型同维度都是同一个Class. </p></li><li><p>通过反射调用 (而不是正向调用)</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInvoke</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestInvoke&quot;</span>);<br>Class partypes[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">2</span>];<br>partypes[<span class="hljs-number">0</span>] = Integer.TYPE;<br>partypes[<span class="hljs-number">1</span>] = Integer.TYPE;<br><span class="hljs-type">Method</span> <span class="hljs-variable">meth</span> <span class="hljs-operator">=</span> cls.getMethod(<span class="hljs-string">&quot;add&quot;</span>, partypes);<br><span class="hljs-type">TestInvoke</span> <span class="hljs-variable">methobj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestInvoke</span>();<br>Object arglist[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">2</span>];<br>arglist[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">37</span>);<br>            arglist[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">47</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">retobj</span> <span class="hljs-operator">=</span> meth.invoke(methobj, arglist); <span class="hljs-comment">// 通过反射api调用方法</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">retval</span> <span class="hljs-operator">=</span> (Integer)retobj;<br>System.out.println(retval.intValue());<br>        &#125;<br><span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>System.err.println(e);<br>        &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="11"><li><p>通过反射可以获取很多类的信息. </p><p>c是Class类型.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> A.getClass();<br>c.getName(); <span class="hljs-comment">// 包名 + 类名</span><br>c.getSimpleName(); <span class="hljs-comment">// 类名</span><br><br>c.getFields(); <span class="hljs-comment">// public的属性</span><br>c.getDeclaredFileds(); <span class="hljs-comment">// 所有属性</span><br>c.getDeclaredFiled(<span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">// 获得name属性</span><br><br>c.getMethods(); <br>c.getDeclaredMethods(); <br>c.getMethod(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-literal">null</span>); <br>c.getMethod(<span class="hljs-string">&quot;set&quot;</span>, String.class); <br><br>c.getDeclaredConstructors(); <br></code></pre></td></tr></table></figure></li><li><p>反射获取类内的方法, 使用 <em>方法名.invoke(…)</em> 的方式, 以统一的方式调用类内函数. </p></li><li><p>反射可以用来创建类的实例对象. 可以对用反射创建的对象做很多事情.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.User&quot;</span>);<br><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)c1.newInstance(); <span class="hljs-comment">// 相当于调用一个无参的构造方法</span><br><span class="hljs-comment">// 调用有参的构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>,class, <span class="hljs-type">int</span>.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> (User)constructor.newInstance(<span class="hljs-string">&quot;chaos&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 调用方法(通过invoke)</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>setName.invoke(user2, <span class="hljs-string">&quot;kid&quot;</span>); <span class="hljs-comment">// 第一个参数是隶属的对象, 第二个是所invoke方法的参数列表</span><br><span class="hljs-comment">// 操作属性</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 不能对private属性直接修改, 但是可以加上下面这条语句以关闭Java的语言访问检查</span><br>name.setAccessible(<span class="hljs-literal">true</span>);<br>name.set(user2, <span class="hljs-string">&quot;Guy&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过反射获取泛型. </p><p>关于Java泛型，很多人都有一个误解，认为Java代码在编译时会擦除泛型的类型，从而在运行时导致没法访问其类型，这其实并不完全正确，因为有一部分泛型信息是可以在运行时动态获取的，这部分信息基本能够满足我们日常开发中的大多数场景，本节我们就来了解相关的知识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">getMethodReturnType</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>  <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> MyClass.class.getMethod(<span class="hljs-string">&quot;getStringList&quot;</span>,<span class="hljs-literal">null</span>);<br>  System.out.println(method.getReturnType());<br>  <span class="hljs-type">Type</span> <span class="hljs-variable">retrunType</span> <span class="hljs-operator">=</span> method.getGenericReturnType();<br>  System.out.println(retrunType);<br>  <span class="hljs-keyword">if</span>(retrunType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> (ParameterizedType)retrunType;<br>    Type[] typeArguments = type.getActualTypeArguments();<br>    <span class="hljs-keyword">for</span>(Type typeArgument : typeArguments) &#123;<br>      <span class="hljs-type">Class</span> <span class="hljs-variable">typeArgClass</span> <span class="hljs-operator">=</span> (Class)typeArgument;<br>      <br>      System.out.println(<span class="hljs-string">&quot;泛型类型：&quot;</span> + typeArgClass);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的关键在于 <code>ParameterizedType</code> 表示一种参数化类型. Java引入了包括<code>ParameterizedType</code> 的几种类型来支持反射操作泛型. 还有 <code>GenericArrayType</code> <code>TypeVariable</code> <code>WildcardType</code>.</p></li><li><p>反射操作注解 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建2个注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Interface</span> TableTest &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Interface</span> FieldTest &#123;<br>    String <span class="hljs-title function_">columnName</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">type</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-meta">@TableTest(&quot;database_student&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student1</span> &#123;<br>    <span class="hljs-meta">@FieldTest(columnName = &quot;database_id&quot;, type = itn, length = 10)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-meta">@FieldTest(columnName = &quot;database_age&quot;, type = itn, length = 10)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflection</span>() &#123;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.Student1&quot;</span>);<br>    <br>    <span class="hljs-comment">// 用反射获取注解信息</span><br>    Annotation[] ann = c1.getAnnotations();<br>    System.out.println(ann);<br>    <br>    <span class="hljs-type">TableTest</span> <span class="hljs-variable">tabletest</span> <span class="hljs-operator">=</span> (TableTest)c1.getAnnotation(TableTest.class);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> tabletest.value();<br>    System.out.println(val);<br>    <br>    <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">// 获取字段</span><br>    <span class="hljs-type">FieldTest</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> name.getAnnotation(FieldTest.class); <span class="hljs-comment">//获取注解</span><br>    System.out.println(annotation.columnName());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反射有什么用? </p><ul><li>Rapid Application Development (RAD)</li><li>Visual approach to GUI development</li><li>Requires information about component at run-time</li><li>Remote Method Invocation (RMI)</li><li>Distributed objects</li></ul><p>重要用途是各种通用框架的开发; 编写分布式代码; …</p></li></ol><h2 id="Java-Lesson-10-Annotation"><a href="#Java-Lesson-10-Annotation" class="headerlink" title="Java-Lesson 10 (Annotation)"></a>Java-Lesson 10 (Annotation)</h2><ol><li><p>注解 Annotation – 可以被其他程序 (编译器) 识别 ; 注释 comment</p></li><li><p>内置注解 </p><p><code>@Override</code> 重写(覆盖) </p><p><code>@Deprecated</code> 弃用 </p><p><code>@SuppressWarnings()</code> 抑制警告 <strong>必须要有参数</strong> <code>(&quot;all&quot;)</code> , <code>(&quot;unchecked&quot;)</code>, <code>(value = &#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</code> 等</p><p>参数可以有哪些呢? deprecation - 使用了过时的类或方法 ; fallthrough - switch块缺少了break ; finally - 任何finally字句不能正常完成 ; … ; all - 所有情况</p></li><li><p>元注解 meta-annotation 注解的注解. </p><p><del>只有4个</del>, 有6个, Java 8 新增了 <code>@Repeatable</code> (用于定义可重复注解) 和 <code>@Native</code> (表示变量可被本地代码引用) </p><p><code>@Target</code> 用于描述注解的适用范围 有TYPE, FIELD, METHOD, PARAMETER, …</p><p><code>@Retention</code> 表示在什么级别上保存该注释信息, 用于描述注解的生命周期. 有SOURCE (源码), CLASS (字节码), RUNTIME. 一般是 RUNTIME</p><p><code>@Documented</code> 该注解包含在javadoc中 – 在javadoc生成api文档时, 被这个注解标记的元素在文档上也会出现该注解. </p><p><code>@Inherited</code> 子类可以继承父类的注解, 只对目标为类&#x2F; 接口&#x2F; 枚举有效. </p></li><li><p>自定义一个注解: (元注解派上用场)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Target 元注解说明了注解适用范围是什么</span><br><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Interface</span> MyAnnotation &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>Target和Retention一般是必须的. </p></li><li><p>使用<code>@Interface</code>就定义了一个注解类型 (或称为<strong>元数据 meta-data</strong>) , 自动继承了<code>java.lang.annotation.Annotation</code>接口</p></li><li><p>如果在类内声明一个注解 不用加 public</p></li><li><p>定义自己的注解: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;Element,TYPE, Element.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-comment">// 以下的无参方法并不真的是方法, 而是注解的属性, default xxx;是该属性的默认值. </span><br>    <span class="hljs-comment">// 定义注解的属性 必须有(), 这里的()不是方法的那个括号</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 没有默认值必须在使用时加参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果有默认值, 可以不传入</span><br>    String[] schools();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果参数只有一个, 建议使用value命名, 此时可以省略 “value &#x3D;”, 但是如果用其它的名字就不能省略.</p></li></ol><h2 id="Java-Lesson-11-Testing"><a href="#Java-Lesson-11-Testing" class="headerlink" title="Java-Lesson 11 (Testing)"></a>Java-Lesson 11 (Testing)</h2><ol><li><p>为什么叫单元测试? – 这里的”单元”可以理解为Java中某个类的某个方法. </p></li><li><p>JUnit – 测试代码放在同一个包的不同目录 (&#x2F;tests) 下</p></li><li><p>不同的方法注解 <code>@Test</code> <code>@BeforeAll</code> <code>@BeforeEach</code> <code>@AfterAll</code> <code>@AfterEach</code> <code>@Ignore</code>(暂不执行该测试方法)</p></li><li><p><code>@Test</code> 注解其实是有属性的 (可以加参数)</p><ul><li><code>expected</code> 期望异常</li><li><code>timeout</code> 性能测试</li></ul><p>举例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test(expected = Exception.class)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>().factorial(-<span class="hljs-number">1</span>);<br>    fail(<span class="hljs-string">&quot;未抛出factorial参数负数异常&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test(timeout = 2000)</span><br>quickSort() &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p>Java assert – 不会执行, 除非加 <code>-ea</code> 选项. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> <span class="hljs-literal">false</span>: <br>  <span class="hljs-string">&quot;Message saying what happened here&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>Guava库中的测试方法 – <code>vertify(true);</code> <code>checkNotNull(s);</code></p></li><li><p>契约式编程 (DbC) : 客户调用某特定public方法时, 期望产生某些特定的行为</p><ol><li>可以明确规定这种行为, 就好像合同一样</li><li>可以通过某些运行时检查来保证这种行为, 也就是<strong>前置条件</strong>, <strong>后置条件</strong>和**不变项 (方法开头的, 方法末尾的) **.</li></ol></li><li><p>JUnit5 提供多种动态生成测试的方法, 如<code>DynamicTest.stream()</code></p></li><li><p>java <em><strong>日志</strong></em> – SLF4J &#x2F; Log4j &#x2F;…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">log.trace(<span class="hljs-string">&quot;&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;&quot;</span>);<br>log.info(<span class="hljs-string">&quot;&quot;</span>);<br>log.warn(<span class="hljs-string">&quot;&quot;</span>);<br>log.error(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>为什么使用日志? – 可以很容易地取消某个级别以下或全部日志, 且容易重新打开和禁止. 可以被定向到不同的处理器, 如控制台, 文件等. 过滤器可以按标准丢弃无用的记录项. </p></li><li><p>用getLogger创建自己的日志记录器. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作为静态字段</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.yourcompany.stack&quot;</span>);  <span class="hljs-comment">// 使用包名</span><br><br><span class="hljs-comment">// 自己创建处理器并且调整级别为FINE</span><br><span class="hljs-keyword">static</span> &#123;<br>    logger.setLevel(Level.FINE); <span class="hljs-comment">// 若此处设置级别为OFF, 即关闭日志</span><br>    logger.setUseParentHandlers(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">var</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleHandler</span>();<br>    handler.setLevel(Level.FINE);<br>    logger.addHandler(handler);<br>  &#125;<br></code></pre></td></tr></table></figure><p>然后, 在任何地方插入 <code>logger.fine()</code> 或其他的日志.</p></li><li><p>日志的常见用途是记录那些意料之外的异常, 以下两个方法通常使用:</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">throwing</span><span class="hljs-params">(String className, String methodName, Throwable t)</span> <br></code></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(Level l, String message, Throwable t)</span><br></code></pre></td></tr></table></figure><p>   例如:</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;...&quot;</span>) ;<br>logger.throwing(<span class="hljs-string">&quot;com.mycompany.Reader&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, e);<br><span class="hljs-keyword">throw</span> e;<br></code></pre></td></tr></table></figure><ol start="11"><li><p>日志执行的过程经过了 日志记录器 -&gt; 处理器, 还会有过滤器, 格式化器. 可以根据需要自己编写处理器和过滤器等. </p></li><li><p>由于所有级别为 INFO &#x2F; WARNING &#x2F; SEVERE 的消息都会显示到控制台上, 所以最好之将对用户有意义的消息设置为这几个级别, 而程序员想要的消息设置为FINE级别. </p></li><li><p>JMH基准测试工具.</p></li><li><p>JDK 默认附带 VisualVM 分析器. 静态分析器 - Findbugs (-&gt;Spotbugs)</p></li><li><p>要观察类的加载过程, 启动Java虚拟机时使用 -verbose 标志, 这样就可以看到类加载的信息, 有时候, 这对诊断类路径问题很有帮助. </p></li><li><p>- Xlint 选项告诉编译器找出常见的代码问题. </p></li><li><p>jconsole工具可以显示有关虚拟机的性能统计的结果, Java任务控制器 (Java Mission Control) 是一个专业级性能分析和诊断工具, 类似jconsole.</p></li></ol><h2 id="Java-Lesson-12-Collections"><a href="#Java-Lesson-12-Collections" class="headerlink" title="Java-Lesson 12 (Collections)"></a>Java-Lesson 12 (Collections)</h2><ol><li><p>for-in 语法适用于数组和任何Collection对象. </p></li><li><p>任何自定义的类, 只要实现了<code>Iterable</code>接口, 都可以用for-in语法. </p></li><li><p>其原理是, Java 5 引入了一个叫<code>Iterable</code>的接口, 该接口包含一个可以生成 <code>Iteraor</code> 的方法 – iterator() 方法. 这个接口就可以用来遍历序列, 所以只要implement了Iterable接口, 就可以用for-in语法遍历了.</p></li><li><p>使用<strong>适配器方法 (Adapter Method) 惯用法</strong>, 为容器List增加一个能够返回逆序元素迭代器的方法作为适配器方法. 这样就可以实现逆序的 for-in 遍历. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReversibleList</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">public</span> Iterable&lt;T&gt; <span class="hljs-title function_">reversed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt;() &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> size() - <span class="hljs-number">1</span>;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> current &gt; -<span class="hljs-number">1</span>;<br>          &#125;<br><br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> get(current--);<br>          &#125;<br>        &#125;;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br>    <br>ReversibleList&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReversibleList</span>&lt;String&gt;();<br><span class="hljs-keyword">for</span> (String s : strings.reversed()) &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>java.util.Collection</code> 和 <code>java.util.Collections</code> 的区别: </p><p><code>Collection&lt;E&gt;</code>是一个接口, 继承了 <code>Iterable&lt;E&gt;</code> , 是一个由单独元素组成的序列, 其子接口有<code>List&lt;E&gt;</code> <code>Set&lt;E&gt;</code> <code>Queue&lt;E&gt;</code>. (而存放一组键值对用接口 <code>Map&lt;K, V&gt;</code>) . 声明的方法有<code>size()</code> <code>add()</code> 等. </p><p><code>Collections</code> 是具体类, 提供了一系列操作或返回集合的静态方法.</p></li><li><p>在<code>java.util.Collections</code>类中定义了以下的<code>sort</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span><br></code></pre></td></tr></table></figure><p>该方法可以对列表进行排序, 但是要求列表中的所有元素必须实现 <code>Comparable</code> 接口 (中的<code>e1.compareTo(e2)</code>方法). </p></li><li><p>如果希望自己编写的类构成的列表可以排序, 需要在该类里实现一个<code>compareTo</code>方法. 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Employee&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Employee o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getId().compareTo(o.getId());<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然而<code>sort</code>方法还有一个重载版本: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span><br></code></pre></td></tr></table></figure><p>这里的参数多了一个比较器<code>Comparator&lt;T&gt;</code>, <code>Comparator&lt;T&gt;</code>接口是一个函数式接口, 它可以被赋值为lambda表达式或者是一个实现了该接口的对象. </p><p>这个接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以, 可以写出以下的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Employee&gt; compareById = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Employee&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Employee o1, Employee o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.getId().compareTo(o2.getId());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>利用Lambda表达式, 可以写的更优雅些:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Employee&gt; compareById = (Employee o1, Employee o2) -&gt; <br>    o1.getId().compareTo( o2.getId() );<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-13-Inner-Class"><a href="#Java-Lesson-13-Inner-Class" class="headerlink" title="Java-Lesson 13 (Inner Class)"></a>Java-Lesson 13 (Inner Class)</h2><ol><li><code>jdk.internal.loader.ClassLoaders$AppClassLoader</code>  其中, <code>$</code>符号后面的类是<code>$</code>前面的类的内部类, 这是 <code>$</code> 的含义.</li></ol><h2 id="Java-Lesson-14-Concurrency"><a href="#Java-Lesson-14-Concurrency" class="headerlink" title="Java-Lesson 14 (Concurrency)"></a>Java-Lesson 14 (Concurrency)</h2><ol><li><p>进程: <strong>操作系统</strong>进行资源分配和调度的一个独立单位, 也是一个具有独立功能的程序.</p><p>线程: 依托于进程而存在, 是CPU调度和分派的基本单位, 它是比进程<strong>更小的能独立运行的基本单位</strong>. 线程自己基本上不拥有资源, 但是它可与同属一个进程的其他线程共享进程所拥有的全部资源. </p><p>区别在于: 进程是资源分配的单位, 而线程是作业调度的单位; 进程拥有自己的地址空间, 而多个线程拥有自己的堆栈和局部变量, 并共享所依托于进程的资源.</p></li></ol><h2 id="Java-Lesson-14-1-Thread"><a href="#Java-Lesson-14-1-Thread" class="headerlink" title="Java-Lesson 14.1 (Thread)"></a>Java-Lesson 14.1 (Thread)</h2><ol><li><p>Java关于线程编程的抽象:</p><ul><li>Thread对象像是运载火箭, Runnable &#x2F; Callable的实现对象 (run方法) 像是一个荷载 (payload)</li><li>Runnable &#x2F; Callable –&gt; 任务; Thread –&gt; 让任务启动.</li></ul></li><li><p><code>Runnable</code>接口 – 一个函数式接口, 里面只有一个<code>run</code>方法. </p><p>实现<code>Runnable</code>接口实例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LiftOff</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">countDown</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// default</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> taskCount++;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LiftOff</span><span class="hljs-params">(<span class="hljs-type">int</span> countDown)</span> &#123;<br>        <span class="hljs-built_in">this</span>.countDown = countDown;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">status</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span> + id + <span class="hljs-string">&quot;(&quot;</span> + (countDown &gt; <span class="hljs-number">0</span> ? countDown : <span class="hljs-string">&quot;Liftoff!&quot;</span>) + <span class="hljs-string">&quot;), &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (countDown-- &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(status());<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainThread</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LiftOff</span> <span class="hljs-variable">launch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LiftOff</span>(<span class="hljs-number">10</span>);<br>        launch.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Thread</code>类, 表示线程, 如果要创建一个新线程, 就要新创建一个<code>Thread</code>. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicThreads</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 把任务装进线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiffOff</span>(<span class="hljs-number">10</span>));<br>        t.start();<br>        <span class="hljs-comment">// start 之后, 就会进入新线程的run()方法. </span><br>        System.out.println(<span class="hljs-string">&quot;Waiting for LiftOff&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>除了通过实现<code>Runnable</code>接口来实现新的线程之外, 还可以直接继承<code>Thread</code>类, 直接重写<code>Thread</code>类下的<code>run</code>方法即可. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">countDown</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(Integer.toString(++threadCount));<br>        start();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span> + getName() + <span class="hljs-string">&quot;(&quot;</span> + countDown + <span class="hljs-string">&quot;), &quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.print(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> (--countDown == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleThread</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这5个线程创建完之后, 线程运行的顺序不是你可以控制的, 多线程并发时, 执行的先后关系是不确定的, 这要交由操作系统的调度器决定. </p></li><li><p>创建线程并启动 (start) 后, 线程并不会立即执行, 而只是<strong>通知</strong>了JVM这个线程可以开始运行了. 然而调度过程不是由你控制的, 所以你不应该显式地调用<code>run</code>方法, 而是调用<code>start</code>方法. (run不是你能控制的)</p></li><li><p>尽管你知道你的机器是4核的, 并且写Java程序运行了4个线程, 但是这并不意味着就只有这4个线程, JVM底层还有线程, 所以, 一般我们不自己创建和销毁单个线程, 而是利用<code>ExecuteService</code>. </p></li><li><p>一般我们创建线程之后, 不会自己做启动这件事, 可以使用<code>ExecutorService</code>启动. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedThreadPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 这条语句会创建一个带缓存的线程池</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool(); <span class="hljs-comment">// 新的带缓存的线程池</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            exec.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiftOff</span>(<span class="hljs-number">10</span>));<br>        &#125;<br>        <span class="hljs-comment">// 关闭线程池, 不再接受新任务, 不是把虚拟机停掉, 只是不再给出任务</span><br>        exec.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>带缓存的线程池</em> – 根据需要创建新线程的线程池, 如果现有线程没有可用的, 则创建一个新线程并添加到池中, 如果有被使用完但是还没被销毁的线程, 就复用线程池. </p></li><li><p>每一个线程要能够执行, JVM会为之准备一堆的事情 (准备栈, PC, …), 严重地消耗时间和内存空间. 所以为了提高效率, 应该避免手动创建和销毁线程, 而是交给线程池管理. </p></li><li><p>还可以创建一个固定线程数的线程池 (FixedThreadPool), 在任何时候最多只有n个线程被创建, 若在所有的线程都处于活动状态时, 有其他任务提交, 他们将等待队列中直到线程可用. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>); <span class="hljs-comment">// 最多只有5个线程被创建</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    exec.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiftOff</span>(<span class="hljs-number">10</span>));<br>&#125;<br>exec.shutdown();<br></code></pre></td></tr></table></figure></li><li><p>线程池常见用法: </p><ol><li><p>调用 <code>Executor</code> 类的静态方法 新建带缓存的或者固定线程数的线程池.</p></li><li><p>调用 <code>submit</code> 提交 <code>Runnable</code> 或 <code>Callable</code> 对象. </p></li><li><p>保存好返回的 <code>Future</code> 对象, 以便得到结果或者取消任务. </p></li><li><p>当不想再提交任何任务时, 调用shutdown. (-&gt; 不是销毁掉, 而是进入不接受新任务的状态)</p></li></ol></li><li><p>如果需要获得一个返回值, 而不是像 run 方法一样返回void, 那么就使用 <code>Callable&lt;V&gt;</code> 对象, 而不是<code>Runnable&lt;V&gt;</code> 对象. </p></li><li><p>举例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;做一些耗时的任务...&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">5000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureSimpleDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-comment">// 这里使用的是submit, 而不是execute, 区别在于submit会返回一个Future类型的对象</span><br>        Future&lt;String&gt; future = executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        System.out.println(<span class="hljs-string">&quot;do something...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;得到异步任务返回结果: &quot;</span> + future.get());<br>        System.out.println(<span class="hljs-string">&quot;Completed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>什么是 <code>Future</code> 类型的对象? </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt;<br></code></pre></td></tr></table></figure><p>Future代表了一个异步计算的结果. 这个结果只有等到计算过程结束后, 才能通过<code>get()</code>方法获得, 如果还没有结束, get方法的调用就会阻塞 (block) .</p></li><li><p><code>Thread.sleep(1000); </code> 线程停止1000ms, 为了避免歧义, 现在通常使用<code>TimeUnit.MILLISECONDS.sleep(100); </code> 实际上使CPU处于了不是满载, 但是是停止状态, CPU在空转 (而不是在进行任何操作) , 等待若干时钟周期, 然后进入下一条指令执行. </p></li><li><p><code>yield</code> 让位. 提醒调度器当前线程愿意让出它当前对于处理器的使用, 由调度器决定是否要将此线程让出. </p></li><li><p><code>yield</code>和<code>sleep</code>的主要区别: </p><p>sleep是暂停CPU的处理下一条指令. </p><ol><li>yield会临时暂停当前线程, 让同样优先级的正在等待的线程有机会执行</li><li>若没有正在等待的线程或者所有正在等待的线程的优先级都较低, 则继续运行</li><li>执行yield的线程何时继续运行由线程调度器来决定, 不同厂商可能有不同行为</li><li>yield方法不保证当前的线程会暂停或停止, 但是可以保证当前线程在调用yield方法时会放弃CPU (让调度器决策一下)</li></ol></li><li><p>优先级 (priority) : 可以使用 <code>setPriority()</code> 方法来改变线程的优先级 (<code>Thread.MAX_PRIORITY</code>) , 但是不应该自己改变优先级, 而应该让系统自己决定. </p></li><li><p>Daemon线程, demon线程是一种不会阻止JVM退出 (JVM的main方法运行结束了) 的线程. 即main thread执行完了且其它所有的非daemon threads都执行完了, JVM就会退出.</p></li></ol><h2 id="Java-Lesson-14-2-Synchronize"><a href="#Java-Lesson-14-2-Synchronize" class="headerlink" title="Java-Lesson 14.2 (Synchronize)"></a>Java-Lesson 14.2 (Synchronize)</h2><ol><li><p>本节讲解线程之间的同步问题. </p></li><li><p><code>Thread</code> 类有一个 <code>join()</code> 方法, join方法直到run方法停止后才会执行, 若run方法运行被打断, 抛出异常. </p></li><li><p>利用 join() 可以保证一个线程在另一个线程之后执行. (实现<em><strong>线程同步</strong></em>)</p></li><li><p>例子: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> duration;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sleeper</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> sleepTime)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        duration = sleepTime;<br>        start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(duration);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(getName() + <span class="hljs-string">&quot; was interrupted.&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(getName() + <span class="hljs-string">&quot; has awakened&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Joiner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Sleeper sleeper;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Joiner</span><span class="hljs-params">(String name, Sleeper sleeper)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.sleeper = sleeper;<br>        start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleeper.join(); <span class="hljs-comment">// 必须sleeper线程运行完之后, join()方法才执行, joiner线程才能往下执行</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Interrupted&quot;</span>);<br>        &#125;<br>        System.out.println(getName() + <span class="hljs-string">&quot; join completed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Thread</code>类里面还有一个 <code>interrupt()</code> 方法, 给当前线程发一个interrupt消息打断这个线程, 如果线程在sleep中收到了interrupt消息, 就会触发一个<code>InterruptedException</code>. </p></li><li><p>每个线程运行时都可能发生异常 (这种运行时异常编译时往往无法捕获), 而这些异常显然无法通过在main thread里面写 try catch来捕获, 而是应该使用<em>UncaughtExceptionHandler</em>, 即<strong>创建一个异常处理器</strong>, 实现 <code>Thread.UncaughtExceptionHandler</code>接口, 然后对 (希望创建的) 线程t调用方法 <code>t.setUncaughtExceptionHandler(new ...)</code> 来设置异常处理器 (表示如果线程t中出现异常, 希望被怎么处理), <strong>设置了Uncaught异常处理器后</strong>线程t中抛出的异常就会被异常处理器处理 (从而没有直接抛出来, 而是被handler解决). </p></li><li><p>更进一步地, 当我们使用很多线程时, 我们希望对于这些所有线程, 对于整个JVM设置一个default的 UncaughtExceptionHandler. 这样在整个JVM运行中, 只要出现了运行时异常, 就会被默认Handler处理, 这是一个简单的做法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SettingDefaultHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Thread.setDefaultUncaughtExceptionHandler(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyUncaughtExceptionHandler</span>());<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        exec.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionThread</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><em><strong>资源共享问题</strong></em> </p><p>在数据库领域, 这个问题就是数据一致性. </p><p>例如: 多个线程同时操作同一个数据 (如局部变量), 由于堆区的数据是共享的, 所以数据不一致. </p></li><li><p>race condition(竞争条件) 多个资源竞争不能被同时访问的资源</p></li><li><p>解决方案: 对资源加锁, 确保一个时刻只有一个任务在使用共享资源 (使其互斥)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutexEvenGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IntGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentEvenValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 即创建一个锁</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>++currentEvenValue;<br>            Thread.<span class="hljs-keyword">yield</span>();<br>++currentEvenValue;<br>       <span class="hljs-keyword">return</span> currentEvenValue;<br>        &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 即是return了, finally里面的语句还会执行</span><br>            lock.unlock(); <span class="hljs-comment">// 一定要用try-catch的finally释放锁</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        EvenChecker.test(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MutexEvenGenerator</span>(), <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>ReentrantLock</code> 类, 里面的方法<code>tryLock()</code> 尝试获取锁, 返回成功与否, 若有参数 <code>tryLock(timeout, TimeUnit.SECONDS)</code>, 则会等timeout个TimeUnit的时间, 若这段时间内获取锁成功也返回true. </p></li><li><p><code>Synchronized</code> 关键字 – 只允许一个线程进入这一方法, 这整个方法不允许被多个线程同时调用. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>synchronized</code>标记了是一个 <strong>临界区 (critical sections)</strong> , 整个临界区一次只有一个线程可以进入. </p></li><li><p><code>synchronized</code>不仅可以用于修饰方法, 也可以修饰代码片段, 如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-type">int</span> field;<br>        <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            p.incrementX();<br>            p.incrementX();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要加 <code>this</code>? 这涉及了Java <code>synchronized</code> 的设计理念, <code>synchronized</code>实际上是对于对象加锁. </p><p>Java VM中为每一个对象都对应维护一个 <em><strong>monitor</strong></em> (管程) , 用于实现多个线程执行该对象上同步方法时JVM检查该对象的管程: </p><ul><li>如果该对象管程未被占有, 当前调用线程可获得所有权并被允许执行该方法; </li><li>如果一个管程被另一个线程所有, 则调用线程需要等待管程被释放.</li></ul><p>当一个方法完成同步方法调用时, 它释放管程所有权, 等待该管程的线程被允许执行同步方法. </p><p>而synchronized的实现就是通过控制<strong>管程</strong> <em>(monitor)</em> 的所有权做到的. </p></li><li><p>即, synchronized的方法的调用必须要获得该方法所在对象的管程所有权. </p></li><li><p><strong>生产者-消费者问题</strong>, 对于一个对象的<code>get</code>和<code>put</code>方法, 给二者加上<code>synchronized</code>修饰, 那么在执行put &#x2F; get时, 方法所在对象的管程被占有, 保证另一个方法不会同时执行. </p></li><li><p>如果buffer满了, 那么等待直到消费者来get. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Put</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">while</span> (count == buffer.length) &#123;<br>        <span class="hljs-keyword">try</span> &#123; wait(); &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;<br>        <span class="hljs-keyword">finally</span> &#123; &#125;<br>    &#125;<br>    <span class="hljs-comment">// producing...</span><br>    notify();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wait</code> 和 <code>notify</code> 是什么? </p><p><code>wait</code> – 释放锁 (管程), 停下此线程 (suspend the calling thread), 等待 (希望别人拿走管程) (release the ownership of the monitor), </p><p><code>notify</code>– 如果一个线程执行了<code>wait()</code>方法而被挂起, 那么只有当另一个线程调用了<code>notify() / notifyAll()</code>睡着的线程才会醒来.</p><p>简单来说, <code>notify</code> 就是<strong>提醒睡着的线程醒来</strong> (通知所有正在等待获取monitor所有权的线程醒来). </p></li><li><p><code>wait</code> 的作用是: 如果拿到了锁, 但是检查条件后发现不满足使用条件(不应该做后续事情), 那么不要拿着锁不放, 否则就死锁了. 通过wait方法把锁让出来, 使得别的线程可以调用synchronized方法. (在拿到锁后不应该做事时不要拿着锁死等不放)</p></li><li><p><code>wait()</code>和<code>notify()</code>都是Object类下定义的方法, 因为管程是每一个对象所维护的, 而这两个方法用于释放和转移monitor的所有权, 所以这两个方法在Object下定义, 而不是在<code>Concurrency</code>包下定义.  </p></li><li><p>举例: 生产者消费者 (<code>PC.java</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, in = <span class="hljs-number">0</span>, out = <span class="hljs-number">0</span>;<br>    <br>    Buffer(<span class="hljs-type">int</span> size) &#123;<br>        buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[size];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Put</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == buffer.length) &#123;<br>        <span class="hljs-keyword">try</span> &#123; wait(); &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125; <br>        <span class="hljs-keyword">finally</span> &#123; &#125; <br>    &#125; <br>        System.out.println(<span class="hljs-string">&quot;Producing &quot;</span> + c + <span class="hljs-string">&quot; ...&quot;</span>);<br>        buffer[in] = c;<br>        in = (in + <span class="hljs-number">1</span>) % buffer.length;<br>        count++;<br>        notify(); <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">char</span> <span class="hljs-title function_">Get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123; wait(); &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125; <br>        <span class="hljs-keyword">finally</span> &#123; &#125; <br>    &#125; <br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % buffer.length;<br>        count--;<br>        System.out.println(<span class="hljs-string">&quot;Consuming &quot;</span> + c + <span class="hljs-string">&quot; ...&quot;</span>);<br>        notify(); <br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Buffer buffer;<br>    <br>    Producer(Buffer b) &#123;<br>        buffer = b;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            buffer.Put((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;A&#x27;</span> + i % <span class="hljs-number">26</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Buffer buffer;<br>    <br>    Consumer(Buffer b) &#123;<br>        buffer = b;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            buffer.Get();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Buffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Buffer</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(b);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(b);<br><br>        p.start();<br>        c.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程状态: Start ; Runnable (等待运行状态, 可以由Running状态yield退回) ; Running ; Blocked(由Running状态<code>sleep</code>&#x2F;<code>suspend</code>&#x2F;<code>wait</code>进入, <code>resume</code>&#x2F;<code>notify</code>退出) ; Stop (线程执行停止)</p></li><li><p><strong><code>wait</code>和<code>sleep</code>的区别</strong>: </p><ul><li>调用wait方法时, 线程在等待时会释放掉它所获得的monitor, sleep则不会;</li><li>wait应该在同步代码块中调用, 而sleep可以在任何地方调用;</li><li><strong>Thread</strong>.sleep()是一个静态方法, 作用在当前线程上, 而wait是一个实例方法, 只能在其他线程调用本实例的<code>notify()</code>方法时被唤醒.</li></ul><p>只是要让线程停止一段时间 – sleep() ; 要实现线程之间通信 – wait() </p></li><li><p>线程本地存储 (Thread local Storage, TLS) : 变量的可见域为线程内. (在线程内全局可访问, 但是不能被其他线程访问到, 这样保证了数据的独立性, 从而避免了线程同步问题)</p></li><li><p>Java使用 <code>ThreadLocal</code> 对象实现线程本地存储: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Accessor</span><span class="hljs-params">(<span class="hljs-type">int</span> idn)</span> &#123;<br>        id = idn;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            ThreadLocalVariableHolder.increment(); <span class="hljs-comment">// 尽管是同一个静态字段, 但是由于引用者处于不同线程, 所以各自的线程拿到的和使用的数据是各自的</span><br>            System.out.println(<span class="hljs-built_in">this</span>);<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span> + id + <span class="hljs-string">&quot;: &quot;</span> + ThreadLocalVariableHolder.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalVariableHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;() &#123; <span class="hljs-comment">// 定义线程局部变量</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>);<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> rand.nextInt(<span class="hljs-number">10000</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        value.set(value.get() + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            exec.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Accessor</span>(i));<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);  <span class="hljs-comment">// Run for a while</span><br>        exec.shutdownNow();         <span class="hljs-comment">// All Accessors will quit</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Lesson-14-3-concurrent包"><a href="#Java-Lesson-14-3-concurrent包" class="headerlink" title="Java-Lesson 14.3 (concurrent包)"></a>Java-Lesson 14.3 (concurrent包)</h2><ol><li><p>Java中的 <code>java.util.concurrent</code>包下有很多有用的工具. </p></li><li><p><code>CountDownLatch</code> 允许一个或多个线程等待直到一系列操作在另外的线程中完成. (用于线程同步, 比<code>join</code>更灵活)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(N);<br>startSignal.countDown();      <span class="hljs-comment">// let all threads proceed //对计数器进行递减1操作，当计数器递减至0时，当前线程会去唤醒阻塞队列里的所有线程。</span><br>doneSignal.await();           <span class="hljs-comment">// wait for all to finish //阻塞当前线程，将当前线程加入阻塞队列。</span><br></code></pre></td></tr></table></figure></li><li><p><code>CyclicBarrier</code> 循环栅栏 : 只有当所有的栅栏拦住的所有线程都准备好时, 栅栏才放开. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(NUM, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregatorThread</span>()); <span class="hljs-comment">// 参数分别是 1:参与线程的个数 2: 线程到达屏障时, 优先执行的action</span><br>cyclicBarrier.await(); <span class="hljs-comment">// 表示线程已经到达栅栏</span><br></code></pre></td></tr></table></figure></li><li><p><code>ScheduledThreadPoolExecutor</code> 一种特殊的<code>ThreadPoolExecutor</code>(线程池执行者) , 比起<code>Cached</code>和<code>Fixed</code>的Executor, <code>ScheduledThreadPoolExecutor</code>可以让任务等一段时间在运行, 也可以规定多个任务以一个固定的速率启动. (can additionally schedule commands to run after a given delay, or to execute periodically.)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(<span class="hljs-number">1</span>); <br></code></pre></td></tr></table></figure></li><li><p><code>Semaphore</code> 信号量: 指定一个资源使用量的上限是多少. (若信号量为1, 即是互斥的资源)</p></li><li><p><code>CompletableFuture</code></p></li><li><p><code>Exchanger</code></p></li><li><p><code>DelayQueue</code> 放入数据设置delay时间, 只有过了指定的时间之后数据才能被取走. (用于服务器对于用户请求排队)</p></li></ol><h2 id="Java-Lesson-15-VM"><a href="#Java-Lesson-15-VM" class="headerlink" title="Java-Lesson 15 (VM)"></a>Java-Lesson 15 (VM)</h2><p>必读: <a href="https://blog.jamesdbloom.com/JVMInternals.html">https://blog.jamesdbloom.com/JVMInternals.html</a></p><p>参考: <a href="https://zhuanlan.zhihu.com/p/682004204">https://zhuanlan.zhihu.com/p/682004204</a></p><ol><li><p>Java虚拟机的内存包括以下5个区域 : </p><ul><li><p><strong>堆 (Heap)</strong> – new出来的对象, 可以被所有线程共享</p></li><li><p><strong>栈 (JVM Language Stacks)</strong> – 存放基本变量类型和引用类型</p></li><li><p><strong>方法区 (Method Area)</strong> – 包含了所有的class和static变量, 包含类的数据(静态变量, 静态方法, 常量池, 代码…), 被所有线程所共享 ( (HotSpot中) 方法区仅仅在逻辑上独立, 物理上包含在Java堆中 )</p></li><li><p><strong>PC Registers</strong></p></li><li><p><strong>Native Method Stacks</strong> (运行用C语言等编写的本地方法时使用)</p></li></ul></li><li><p>方法区中保存了每一个类的信息. 包括:</p><ul><li>Classloader Reference 由哪个类加载器加载的</li><li>Run Time Constant Pool 运行时常量池 (类似C&#x2F; C++的符号表)</li><li>Field data</li><li>Method data</li><li>Method code</li></ul></li><li><p>使用<code>javap</code>命令查看字节码信息. 敲入<code>javap -help</code>以获取帮助. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javap -v -p -s -sysinfo -constants MyClass<br></code></pre></td></tr></table></figure><p>获取字节码相关信息. </p></li><li><p>所有的类都是在对其<strong>第一次使用</strong> (类缓存保证了只加载第一次) 时, 动态加载到JVM中去的. </p></li><li><p>一旦某个类的 <code>Class</code> 对象被载入内存, 它就被用来创建这个类的所有对象.</p></li><li><p>当程序创建第一个对类的静态成员的引用时 (包括使用new语句新建对象) , JVM会使用类加载器根据类名查找.class文件.</p></li><li><p>类的加载 (Load) -&gt; 类的链接 (Link) -&gt; 类的初始化 (Initialize)</p></li><li><p>加载: 将class文件<em><strong>字节码</strong></em>内容加载到内存中, 并将这些静态数据转换成方法区的运行时数据结构, 然后生成一个代表这个类的java.lang.Class对象 ( Class对象在堆区 ). </p><p>Java类由 <code>java.lang.ClassLoader</code> 加载, 那么ClassLoader类由谁加载? – <code>Bootstrap Class Loader</code> ( <code>/ˈbutˌstræp/</code>) , 特殊的Class Loader, 一般不用Java语言编写, 而是用C语言等本地代码写, 与具体的平台实现相关. </p><p>此外, 还有extension class loader (java 9以后叫platform class loader), 用于加载放在 <code>java.ext.dirs</code> 目录下的java扩展类型.</p><p>system class loader &#x2F; application class loader, 加载你自己在java应用里面写的类型, 从命令行选项中的 <code>-classpath</code> 或 <code>-cp</code> 下寻找. </p></li><li><p>链接: 将Java类的二进制代码合并到JVM的运行状态之中的过程. </p><p>验证 – 验证加载的类信息没有安全方面的问题, </p><p>准备 – 在方法区为static变量分配内存并设置默认初始值, </p><p>解析– 常量池内的符号引用(name) 被替换为 直接引用(地址).</p></li><li><p>初始化:</p></li></ol><p>   执行类构造器中的&lt;clinit&gt;() 方法, 由所有static变量的赋值和静态代码块中的语句合并起来构成. (按源码的<strong>字面</strong>顺序执行静态语句) </p><p>   若发现其父类没有初始化, 先触发其父类的初始化</p><p>   保证一个类的&lt;clinit&gt;() 方法在多线程环境中被正确加锁和同步.</p><ol start="11"><li><p>什么时候会发生类的初始化? </p><ul><li><p>类的主动引用 (一定发生类的初始化)</p><p>​1. 虚拟机启动时, 先初始化main方法所在的类</p><p>​2. new一个对象时</p><p>​3. 调用类的静态成员 (除final常量) 和静态方法</p><p>​4. 使用<code>java.lang.reflect</code>包的方法对类进行反射调用</p><p>​5. 初始化一个类, 但是父类没有被初始化则会先初始化其父类</p></li><li><p>类的被动引用 (<strong>不会</strong>发生类的初始化)</p><ol><li>当访问一个静态域时, 只有真正声明这个域的类才会被初始化. 如: 当通过子类引用父类的静态变量, 不会导致子类初始化. </li><li>通过数组定义类引用, 不会触发此类的初始化. (数组只是给它定义一个名字) (<code>A[] arr = new A[5];</code>)</li><li>引用常量不会触发此类的初始化. (常量在链接时就被放入常量池了)</li></ol></li></ul></li><li><p>初始化的顺序: 静态字段和静态代码块初始化 -&gt; 成员变量和非静态代码块初始化 -&gt; 构造方法; 若有父类, 先初始化父类. </p></li><li><p><strong>类缓存</strong> – 标准的JavaSE类加载器可以按照要求查找类, 但一旦某个类被加载到类加载器中, 它将维持一段时间 (缓存), 不过JVM回收机制可以回收这些Class对象. </p></li><li><p>类加载器 – 用来把类 (class) 装载进内存. 有引导类加载器, 扩展类加载器, 系统类加载器 (AppClassLoader) (最常用, 用于加载用户自己写的类)</p></li><li><p>用户也可以自定义类加载器, 是Application Class Loader的子类. (重写类加载器类的<code>findClass(String name)</code> 方法即可实现自己的类加载器) 实现自己的类加载器是有用的, 例如浏览器使用独立的类加载器加载来自不同网页的小程序, 这样即使小程序重名也会被认为成是不同的部分. </p></li><li><p>双亲委派机制 – 类加载时, 类加载器会一直向父加载器 (parent class loader) 委派 (application class loader -&gt; platform class loader) , 直到根类加载器 (引导类加载器, bootstrap class loader), 如果父类加载器加载失败 (返回null) , 就依次交由下一级进行加载. (所以从库里找的顺序是从父到子.)</p></li><li><p>父类 (parent) 加载器并不是子类加载器的父类 (super class). </p></li><li><p>这一机制的核心思想在于, 当遇到一个加载请求时, <strong>先尝试的是向上委派, 而不是先尝试自己加载</strong>. <strong>下层加载的类型不能被上层看到</strong>.  </p></li><li><p><strong>所以你不能写个恶意的String类型替换掉系统内部的String.</strong> </p></li><li><p>类加载机制的高级应用: 对加载的字节码进行修改, 改变类的行为; 运行时动态创建类型 -&gt; 高级的Java应用技术. </p></li><li><p>Java类加载机制: 当触发类加载的时候，类加载器也不是直接加载这个类。首先交给 <code>AppClassLoader</code> ，它会查看自己有没有加载过这个类，如果有直接拿出来，无须再次加载，如果没有就将加载任务传递给 <code>ExtClassLoader</code> ，而 <code>ExtClassLoader</code> 也会先检查自己有没有加载过，没有又会将任务传递给 <code>BootstrapClassLoader</code> ，最后 <code>BootstrapClassLoader</code> 会检查自己有没有加载过这个类，如果没有就会去自己要寻找的区域去寻找这个类，如果找不到又将任务传递给 <code>ExtClassLoader</code> ，以此类推最后才是 <code>AppClassLoader</code> 加载我们的类。</p></li></ol><h2 id="Java-Regexes"><a href="#Java-Regexes" class="headerlink" title="Java Regexes"></a>Java Regexes</h2><ol><li><p>Java也有正则表达式, 常用于各种字符串处理.</p></li><li><p><code>.</code> 任意字符 (不能是换行)</p><p><code>*</code> 重复0次或更多次</p><p><code>+</code> 重复1次或更多次</p><p><code>?</code> <strong>重复0或1次</strong> (表示可选的)</p><p><code>&#123;m&#125;</code> 重复m次</p><p><code>&#123;m, n&#125;</code> 重复m ~ n次</p><p><code>^</code> 匹配字符串开头</p><p><code>$</code> 匹配字符串结尾</p><p><code>[]</code> 必须匹配括号里的内容</p><p><code>[^]</code> 必须匹配除了括号里以外的字符 (这里^的意思与之前)</p></li><li><p><code>\w</code>: [a-zA-Z0-9_] 即构成一个单词的所有可能组合, 字母数字下划线.</p><p><code>\d</code>: [0-9] digits</p><p><code>\D</code>: [^0-9] not a digit</p><p><code>\s</code>: 空白字符</p><p><code>\S</code>: 空白字符</p><p><code>\W</code>: [^a-zA-Z0-9_] 非单词字符以外所有字符</p></li></ol><h2 id="Jar包"><a href="#Jar包" class="headerlink" title="Jar包"></a>Jar包</h2><ol><li><p>只要涉及到Java的项目, 就不可避免地接触到jar包. 而实际开发中，maven, gradle等项目管理工具为我们自动地管理jar包以及相关的依赖, 让jar包的调用看起来如黑盒一般”密不透风”. 本节让我们打开这个黑盒, 了解有关jar包的知识. (参考 - Java核心技术)</p></li><li><p>jar包就是 Java Archive File, 是Java的一种文档格式, 是一种与平台无关的文件格式, 可将多个文件合成一个文件. 与zip包很相似, 准确的说, jar和zip的唯一区别就是在jar文件的内容中, 包含了一个 <code>META-INF/MAINIFEST.MF</code> 文件, 作为jar里面的详情单. </p></li><li><p>jar包主要是对class文件进行打包, 这意味着jar包是跨平台的. </p></li><li><p>使用指令 <code>jar -tf xxx.jar</code> 查看jar里面的内容. </p></li><li><p>可以查看到jar包里面一般有 .MF .class 文件, 还有静态资源文件如 .html, .css 以及 .js等. </p></li><li><p>jar包用于发布, 方便将自己实现的功能提供给别人使用. </p></li><li><p>还有war包, war包是一个可以直接运行的web模块, 通常应用于web项目中, war包可以部署到Tomcat等容器中, war包能打包的内容jar包都可以打包. </p></li><li><p>如何打jar包? 首先将编写好的java项目用<code>javac</code>命令生成字节码文件, 然后在命令行中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jar -cvf xxx.jar com/src/A.class com/B.class<br></code></pre></td></tr></table></figure><p>c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名.  </p></li><li><p>手动打jar包需要自己新建MANIFEST文件, 一般使用intellij idea打包, 步骤如下: </p><ol><li>找到FILE&#x2F; Project Structure</li><li>点击 Artifacts</li><li>点击绿色的 “+” 号, 选择JAR -&gt; Empty</li><li>然后按照提示设置jar包名, 目标路径, 需要打包的文件即可. </li><li>然后点击菜单中的Build, 选择Build Artifacts…, 然后双击弹窗中的Build即可. (END)</li></ol></li><li><p>如何执行一个jar包? 很简单, 一般只要执行指令: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar xxx.jar<br></code></pre></td></tr></table></figure><p>但是, 这样可能会出现不知道指定的main方法所在的问题, 可以通过一下指令动态指定: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp xxx.jar com.src.A<br></code></pre></td></tr></table></figure><p>即通过-cp指定main方法所在的类. </p></li><li><p>甚至用户可以通过双击JAR文件图标来启动应用程序. </p></li><li><p>读取jar包内的资源文件, 使用 <code>getResourceAsStream()</code> 这一api来实现. </p></li><li><p>如何使用IDEA导入第三方jar包: 使用IDEA打开项目, 找到FILE&#x2F; Project Structure , 然后选择 Modules -&gt; Dependencies -&gt; + -&gt; Jars or directories, 导入jar包所在的本地路径.</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言复习笔记</title>
    <link href="/2024/03/02/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/02/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言复习笔记"><a href="#C语言复习笔记" class="headerlink" title="C语言复习笔记"></a>C语言复习笔记</h1><h2 id="Lesson-1-输入输出"><a href="#Lesson-1-输入输出" class="headerlink" title="Lesson 1: 输入输出"></a>Lesson 1: 输入输出</h2><ol><li><p>program程序 Operations运算符 expressions表达式 statements语句</p></li><li><p>理解第一个程序<code>hello.c</code>的各个部分：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">#<span class="hljs-keyword">include</span> : preprocessor directive 预处理指令<br>main: <span class="hljs-function"><span class="hljs-keyword">function</span></span> 函数<br><span class="hljs-built_in">int</span> main(): takes no arguments, <span class="hljs-keyword">return</span> an <span class="hljs-keyword">integer</span> 无参数, 返回整型<br>main: .c <span class="hljs-keyword">contains</span> one and <span class="hljs-keyword">only</span> one main <span class="hljs-function"><span class="hljs-keyword">function</span></span> 一个.c文件有且仅有一个main函数<br>printf: <span class="hljs-built_in">print</span>+f: <span class="hljs-keyword">format</span> 格式化输出<br></code></pre></td></tr></table></figure></li><li><p><strong>%f或者%lf都表示匹配输出double类型的值；但是scanf输入只能使用%lf匹配</strong></p></li><li><p>如果是输入输出的是long double类型, 对应的格式串是 <code>%Lf</code>. </p></li><li><p><code>const double PI;</code>  定义常量, 常量要全大写命名。</p></li><li><p>% 和 f 中间可以有一些东西. 例如<code>%10.2f</code>这里的点不是小数点, 而是分隔的意思, 10表示字段的宽度为 10 个字符, 如果浮点数本身不足 10 个字符, 那么会在左侧用空格填充; 2表示小数点后要保留2位数字. </p></li><li><p><strong><code>%.2d</code> 或 <code>%02d</code> &#x2F;&#x2F; 最少这个整数要输出2个数字，不足则前面补0</strong></p><p><code>%.2s</code> &#x2F;&#x2F; 输出前2个字符 (如果不足2个字符就有多少输出多少), 空字符在尾部补齐</p><p><code>%2s</code> &#x2F;&#x2F; 输出长度为<strong>至少为2</strong>的字符串, 不够就在前面补空格 </p></li><li><p>注意字符串<strong>定义时要多定义一位</strong>，因为字符串的最后是\0,</p><p>例如: <code>char first_name[5] = &quot;Tayu&quot;;</code> </p></li><li><p><strong>%c在匹配用户输入的时候不会忽略空白符，所以要注意在scanf中就要加入空白符以匹配掉0到任意个空白符。</strong>     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s %c&quot;</span>,                               <br>     first_name, last_name, &amp;gender);       <br></code></pre></td></tr></table></figure></li><li><p>字符串越界, 会出现UB. 所以要用<code>%9s</code> 限制输入的最长长度。</p></li><li><p><code>%*lf</code>的意思是虽然让你输入, 但是变量该是什么还是什么. 这样的话<code>scanf(“%*f”,&amp;a);</code>用来输入double类型也是可以的。</p></li><li><p><code>printf</code> 默认遇到 ‘\0’ 就会停止打印.</p></li><li><p><code>pow</code>函数: 注意可能引起报错,  <strong>底数 a为负数并且指数 b 不是整数</strong>, 将会导致 domain error 错误</p></li></ol><h2 id="Lesson-2-if-for-array"><a href="#Lesson-2-if-for-array" class="headerlink" title="Lesson 2: if-for-array"></a>Lesson 2: if-for-array</h2><ol><li><p>要养成<strong>分行定义多个变量</strong>的编码风格. </p></li><li><p>变量在声明的时候一定尽可能给一个初始值, <code>int a = 0;</code></p></li><li><p>较小数程序: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a &gt;= b) &#123;<br>  min = b;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  min = a;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>? : &#x2F;&#x2F;Ternary Operator 三目运算符</p></li><li><p>输出单个字符也要用””, 因为是字符串:  <code>printf(&quot;A&quot;);</code></p></li><li><p>undefined behavior：未定义行为</p><p>例: </p><p><code>char a;</code></p><p><code>scanf(&quot;%d&quot;, &amp;a);</code></p><p>就是一个undefined behavior (UBs)</p><p>c语言标准没有规定发生什么情况, 出现任何情况都有可能, 这取决于编译器厂商.</p><p>所以, <em><strong>Avoid UBs! ! !</strong></em></p></li><li><p>用<strong>宏定义</strong>的常量叫<em><strong>符号常量</strong></em>, <code>const</code>关键字定义的叫字面常量. </p><p><strong>推荐所有的数组长度</strong>都用宏定义的符号常量</p></li><li><p>可变长数组: </p><p><code>int n;</code></p><p><code>int a[n];</code></p><p>这样做是<em><strong>非常不推荐的</strong></em></p></li><li><p><input disabled="" type="checkbox"> : subscript operator (下标运算符)</p></li><li><p>数组访问越界错误, 经典的UB, 编译器会悄无声息地换成另一个值. </p></li><li><p>for循环的第一部分 int i &#x3D; 1; 可以是一个定义(C99以后才可以).</p></li><li><p>下标0的元素可以被赋值一个不影响后面元素的值 , 后面所有其余元素<strong>自动被赋值为0</strong>.</p></li><li><p>一个变量有左值和右值, i &#x3D; 1; &#x2F;&#x2F;左值， 指代的是<em><strong>i所在的空间</strong></em></p><p>j &#x3D; i; &#x2F;&#x2F;右值，指的才是它<em><strong>真正的值</strong></em>   </p></li><li><p><code>int num[] = &#123;0&#125;;</code>这样只是开了一个元素, 不要以为开了任意个. 并且也不要不写长度.</p></li><li><p><code>int num[20] = &#123;[2] = 1&#125;;</code>这种写法是可以的</p></li><li><p><code>int  numbers[NUM] = &#123;&#125;;</code>什么都没有, 标准上这样<strong>不允许</strong>.</p></li><li><p>不推荐不对数组初始化.</p></li><li><p>如果<strong>字符数组</strong>不初始化(即在等号后面写上字面量的话), 那么它是什么值都有可能(<strong>每个元素都是垃圾值</strong>), 且**最后一位也&#x3D;&#x3D;不是’\0’&#x3D;&#x3D;**而是垃圾值. 所以要么就给出字面量, 要么就使用<code>sprintf</code>初始化, 否则自己一定记得把结尾后面的元素手动写成’\0’.  (另: <code>memset(str, 0, strlen(str))</code>是毫无问题的字符串初始化为全零的操作)</p></li></ol><h2 id="Lesson-3-for-while"><a href="#Lesson-3-for-while" class="headerlink" title="Lesson 3: for-while"></a>Lesson 3: for-while</h2><ol><li><p>VLA: variable-length array 可变长数组  C99 introduces VLA</p><p>C11 makes it optional 也就是说C11又把它去掉了(也就是说有没 有取决于编译器)</p><p>而且VLA在声明时不需要(也不支持)初始化</p></li><li><p>每写一段代码之后就应当下意识去运行一下, 以免错误积累… </p></li><li><p>如何输入任意次直到EOF: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> len = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;numbers[++len]) != EOF); <span class="hljs-comment">//先加，再判断。len++就是先判断再加</span><br></code></pre></td></tr></table></figure><p>这个操作值得掌握.</p></li><li><p>do-while 语句: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">//注意这里有一个分号, 不要忽略了</span><br></code></pre></td></tr></table></figure></li><li><p>程序员在写代码时不要太聪明 (不是说不设计一个好的算法) , 是说要让代码可读且简单.</p></li><li><p>写代码就像写诗 – 多换行. </p></li><li><p>在合适的场景多用<strong>布尔变量</strong>.</p></li><li><p><strong>scanf是有返回值的.</strong> 一般来说, <strong>匹配了几个就返回几</strong>.</p><p><code>%d%d%d, &amp;a, &amp;b, &amp;c</code></p><p>如果输入 1 2就返回2</p><p>如果输入 abc 不能匹配, 就返回0</p><p>如果是   “          “   这样的空输入就返回EOF, (end of file, 文件结束符, 一般来说其值&#x3D; -1 )</p></li><li><p>读取int数组: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    arr[i++] = n;<br>  &#125; <span class="hljs-keyword">while</span>( getchar() != <span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>读取字符串:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>( (<span class="hljs-built_in">string</span>[i++] = getchar()) != <span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">// 读入一个无换行的字符串,美中不足是最后一个位置会是&#x27;\n&#x27;(垃圾值)</span><br></code></pre></td></tr></table></figure></li><li><p><code>strlen()</code> 返回字符串长度</p></li><li><p><code>memset()</code> 只能初始化值为<strong>0和-1</strong></p></li></ol><h2 id="Lesson-4-多维数组"><a href="#Lesson-4-多维数组" class="headerlink" title="Lesson 4: 多维数组"></a>Lesson 4: 多维数组</h2><ol><li><p><code>game-of-life.c</code> 中涉及的系统调用: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//表示暂停的毫秒 ，在windows.h头文件下</span><br><br>system(<span class="hljs-string">&quot;cls&quot;</span>);  <span class="hljs-comment">//清屏</span><br><br><span class="hljs-comment">//Linux</span><br>sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">//表示暂停的秒数; 在unistd.h下</span><br>system(<span class="hljs-string">&quot;clear&quot;</span>); <span class="hljs-comment">// 在stdlib.h下</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033c&quot;</span>); <span class="hljs-comment">// 清空</span><br></code></pre></td></tr></table></figure></li><li><p>二维数组实现上下左右移动: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> vectors[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;  <span class="hljs-comment">// vector[i][j]可以认为是第i组里面的第j个元素</span><br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k) &#123;<br>    <span class="hljs-type">int</span> newI = i + vectors[k][<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> newJ = j + vectors[k][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (arr[newI][newJ] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123; <span class="hljs-comment">// 实现上下左右方向的统计雷的个数</span><br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Special-Lesson-Learning-debug"><a href="#Special-Lesson-Learning-debug" class="headerlink" title="Special Lesson: Learning debug"></a>Special Lesson: Learning debug</h2><blockquote><p>Don’t be too afraid, and learn from coding!</p></blockquote><ol><li><p><strong>debugging</strong>思想: 削减到最小出现bug的问题 (以方便集中注意力debug, 如果你不能debug, 那么至少你要先把bug的出现域缩小, 你可以另写一个函数, 最好就几行, 以便锁定bug, 节省自己和别的帮你debug的人的精力!) – by Mr. Niu</p></li><li><p>编写测试代码, 调用检查函数, 尝试发现到底错在哪里. </p></li><li><p>有用的检查错误命令: </p><ol><li><p>gcc -Wall hello.c</p></li><li><p>gcc -Wall -Werror hello.c</p></li><li><p>clang -Wall hello.c</p></li></ol></li><li><p>运行时内存检查: gcc -fsanitize&#x3D;address hello.c 可以看到泄漏的内存总大小 &#x2F; 泄漏位置, 有用极了. </p></li><li><p>函数性能分析 Linux 下用 <code>perf</code></p></li></ol><h2 id="Lesson-5-函数"><a href="#Lesson-5-函数" class="headerlink" title="Lesson 5: 函数"></a>Lesson 5: 函数</h2><ol><li><p>函数名命名使用大驼峰 (谷歌). </p></li><li><p>形参可以和实参同名. </p></li><li><p>避免全局变量. </p></li><li><p><code>int IsPrime(int number);</code></p><p>函数先声明, 后定义. </p></li><li><p><code>int BinarySearch(int key, int dict[], int len);</code> &#x2F;&#x2F; 这里的形参不能不写上数组长度.</p></li><li><p><code>int BinarySearch(int key, const int dict[], int len)</code></p><p>如果你不想修改数组， 那么传入时一定要用**<code>const</code>**修饰. </p></li><li><p>多维数组传值: 一定要写<strong>除了第一维以外所有维</strong>的数值, 如:arr[] [][][][[LEN] [LEN][LEN]</p></li><li><p>在函数定义上面写 &#x2F;** 加回车, 以对函数功能及参数含义作注解. </p></li><li><p>C语言只有传值, 以传地址的值的方法来实现传引用.</p></li><li><p>无参数输入的函数声明: int Fun(void);   C语言的老特性, 不能省略<strong>void</strong>, 否则可能出问题. 但是C++等其它语言则不需.</p></li></ol><h2 id="Lesson-6-递归"><a href="#Lesson-6-递归" class="headerlink" title="Lesson 6: 递归"></a>Lesson 6: 递归</h2><ol><li><p>how? C语言语法支持自调用甚至可以调用main函数自己 (c++就不能自调用main).</p></li><li><p>why? 适用情景: 解决问题时又遇到了和原问题差不多的问题.</p></li><li><p>会不会一直递归下去, 无穷无尽? 有可能.</p></li><li><p>要<strong>用递归的思维去思考问题</strong>: 子任务是比原来任务规模更小的任务, 直到最后碰到了一个最小的任务, 然后把它直接解决掉. (困难, 需要有意识训练, 需要花很长很长的时间).</p></li><li><p>训练递归思维 (Ask the mirror right questions) :  </p><p>a) &#x3D;&#x3D;What is a smaller task?&#x3D;&#x3D; (更小的问题是什么?) </p><p>b) How to solve the task given the solution to the smaller one? (如果知道了小问题的解, 怎么推出原问题的解?)</p><p>c) What is the smallest task? (最小规模的任务是什么?)</p></li><li><p>像一个计算机一样思考, 理解递归的底层实现. </p></li><li><p>栈空间(Stack), 堆空间(Heap), 栈帧(Stack Frame): </p><p><strong>Stack</strong></p><table><thead><tr><th>main                            (bottom)</th></tr></thead><tbody><tr><td>a  25                          |</td></tr><tr><td>b  37                          |</td></tr><tr><td>min 25                    (top)</td></tr></tbody></table><table><thead><tr><th>min</th></tr></thead><tbody><tr><td>a  25</td></tr><tr><td>b  37                    (new top)</td></tr></tbody></table><p>栈空间(用以存储局部变量), 生长的方向是从上往下(自底向顶).</p><p>调用一个函数时,会**为这个函数准备一个栈帧 ** 栈帧存储局部变量. 函数结束后, 栈帧消失.</p></li></ol><p>​   遵循FILO的一个结构. 最后调用的最先消失, 先是往栈空间不断压栈帧的过程, 后是不断弹出栈帧的过程.</p><ol start="8"><li><p>想要更深入理解栈空间&#x2F;堆空间, 请移步<em>计算机系统基础</em>. </p></li><li><p>注意函数里变量的生命周期问题, 函数里的数组如果是在栈空间里, 那么<strong>这个数组会随着函数的结束而消失</strong>, 所以你无法通过<code>&#123;int a[1005]; ... return a;&#125;</code>来用返回这个数组的首地址的方式试图返回这个数组&#x2F; 字符串字面量. </p><p>解决方案 1. <code>malloc</code>函数申请堆空间, 但是要注意判断是否申请成功, 且调用者须把空间free掉.    2. 操作外面的数组 (传入的&#x2F; 全局的)</p></li></ol><h2 id="Lesson-7-数据类型"><a href="#Lesson-7-数据类型" class="headerlink" title="Lesson 7: 数据类型"></a>Lesson 7: 数据类型</h2><ol><li><p>基础数据类型 int double char bool</p></li><li><p>聚合数据类型 []</p></li><li><p>整型 short (int) , int(至少4个字节), long (int), long long (int) (至少8个字节)  只是不会减少, 但不一定严格递增        signed vs. unsigned</p></li><li><p>printf函数 无符号整型<code>%u</code>, 有long就加一个l <code>printf(&quot;ULONG_MAX = %lu\n\n&quot;, ULONG_MAX);</code></p></li><li><p>有符号整数溢出是UB, 无符号整数溢出会发生<strong>回绕现象</strong>.</p></li><li><p>size_t 就是一个unsigned long long. 输出时使用%zu</p></li><li><p>混用有符号和无符号就会出错 -1 &gt; 256(unsigned). 所以尽量不要用无符号, 除非你很有把握不会与有符号数比较. (有符号会被隐式转换成无符号的)</p></li><li><p>注意 可以使用<code>typedef unsigned long long int size_t</code></p></li><li><p>如果只写一个char, 无从得知是有符号还是无符号. (看具体系统)</p></li><li><p>隐式类型转换  (1) 算术&#x2F;逻辑表达式(类型提升)   (2)定义初始化, 赋值(类型转换)    (3)函数调用时(类型转换)    (4)函数赋值时(类型转换)  </p></li><li><p>想要明确表示是float 后缀要加F. <code>float pi = 3.1415926F</code> 不加F的话就不是float, 默认是double.</p></li><li><p>long double 的话后缀加L.</p></li><li><p>在C语言中, <strong>0开头的数字为八进制数</strong>, 010就是十进制的8.</p></li><li><p>epsilon 表示浮点数所能表示的两个最近的能精确表示的数字之间的gap. (这个gap不可能为0, 为什么?)</p></li><li><p>浮点数实在太复杂, 但是好在我们实际上基本用不到. (如: 做web开发就几乎和浮点数无任何关系)</p></li><li><p>浮点数表示能力不够的情况除了overflow还有underflow也就是太接近0了, 无法表示(且这个gap一定会存在).</p></li></ol><h2 id="Lesson-8-指针"><a href="#Lesson-8-指针" class="headerlink" title="Lesson 8: 指针"></a>Lesson 8: 指针</h2><ol><li><p><code>printf(&quot;%p&quot;, &amp;radius);</code> &#x2F;&#x2F; 打印地址变量(指针)要用<code>%p</code>, 其输出为一个十六进制数</p></li><li><p>存储的其实是int类型中<strong>4个连续字节</strong>的<em><strong>首地址</strong></em>, 而不是一个字节一个字节地存储. 拿到这个首地址就可以根据int这个变量类型来解析出那4个所要的字节.</p></li><li><p><span id="jump"><em><strong>左值与右值</strong></em>, 等号左边叫左值, 代表变量所在的一块***&#x3D;&#x3D;存储空间&#x3D;&#x3D;***(not the first address), 而右值代表空间里的那个内容</span></p><p>所以, 我们可以使用 <code>(*ptr) = 20;</code> 这样的语句来给所指的变量赋值</p></li><li><p><code>int a = 0;</code> <strong>直接访问</strong>a, 或者可以<code>int *prt = &amp;a</code>;  访问*p来<strong>间接访问</strong>a</p></li><li><p><code>*</code> 叫作**”解引用运算符”**或者”间接寻址运算符”.</p></li><li><p>&#x3D;&#x3D;**动态数组: **&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> *numbers = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// (老版本 / C++)需要强制类型转换, 因为malloc返回值是void型; 且返回的是整块内存的首地址(所以使用指针变量来存).</span><br><br><span class="hljs-type">int</span> *numbers = <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(*numbers)); <span class="hljs-comment">// 本质上就是数组声明</span><br><br><span class="hljs-comment">// recommended way</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;numbers[i]);<br>  &#125; <span class="hljs-comment">// 把这块连续的空间当成数组使用(也可作其他用途)</span><br></code></pre></td></tr></table></figure></li><li><p>如果写<code>int *prt = ... </code>那么其实是无法判定指向的是一个int型变量还是一个以此变量开头的数组(需要C程序员自己清楚). </p></li><li><p>&#x3D;&#x3D;<em><strong>指针与数组</strong></em>&#x3D;&#x3D;  数组名即是数组第一个元素的地址(指向int的一个指针) 所以, 可以把指向一块内存空间的首个元素的指针名接作为数组名使用. </p><p>即 <code>numbers[i]</code> 就等价于 <code>*(numbers + i)</code></p><p>​<code>&amp;numbers[i]</code> 等价于  <code>numbers + i</code></p><p>数组的名字<strong>本质上不是一个变量</strong>, 而永远都是这个数组首元素的地址.我们只能取它的值, 而不能修改它(<strong>右值</strong>).</p><p>如果硬想把它变成一个变量, 则再定义一个指针等于它. <code>int *prt = arr;</code></p></li><li><p>指针的加法 <code>*(numbers + 1)</code> 并不是在数值上加1, 而是说一次跳过一块内存. (区别于普通的整数运算)</p></li><li><p>类似的, <em><strong>指针和指针可以相减</strong></em>, 不可以相加, 相减结果表示连续的一块内存地址两个地址之间相差的元素数. (<strong>注意不是字节数</strong>)</p></li><li><p>那么<code>arr[i]</code> 就是 <code>*(arr + i)</code> 就是 <code>*(i + arr)</code> 就是 <code>i[arr]</code> &#x2F;&#x2F; 但是你不要这么写, 码风不好. </p></li><li><p>另外<code>&amp;arr[i]</code> 就是 <code>&amp;(*(arr + i))</code> 就是 <code>arr + i</code>  </p></li><li><p>动态内存申请的空间用完了还需要还回去. </p><p>为什么要还, 因为此空间<strong>不是存在栈帧里的, 而是在堆上面</strong></p><p>如果不free的话, 申请这块内存的指针已经没了, 但是内存里这块空间还被占据着, 没人能够再访问它. 发生<strong>内存泄漏</strong> (引用这块内存的指针变量已经没有了但是没有释放被引用的内存)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(numbers); <span class="hljs-comment">// 注意: 同一块内存不能free两次</span><br></code></pre></td></tr></table></figure><p>Q: 怎么分析是否一块内存是否被free了两次, 这其实是无法<strong>静态分析</strong>出的. </p></li><li><p>如果不是堆空间不可free.</p></li><li><p>申请内存有可能失败, 失败就返回一个空指针.(指向NULL的指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (numbers == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 就是空指针</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error; No dynamic memory any more.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>calloc</code> : malloc 之后赋予所有元素0, 而非垃圾值</strong></p><p><code>realloc</code> : 重新申请一个内存, 并且把原来的数组已有值赋给现在的内存. </p></li><li><p><strong>指针和字符串</strong> 1) 声明 char msg[20] &#x3D; “Hello World!”;     也可以    char *msg &#x3D; “Hello World!”;  </p><p>​2) 默认的<strong>使用指针定义的字符串字面量不可以修改</strong>char *msg &#x3D; “Hello World!”;    msg[0] &#x3D; “N”;  &#x2F;&#x2F; 这是UB</p><p>​                        3) 但是如果用数组定义字符串字面量就可以修改 char msg[20] &#x3D; “Hello World!”;   msg[0] &#x3D; “N”;  &#x2F;&#x2F; 允许</p></li><li><p>()++的优先级高于*, (<strong>至于++(), 和 * 优先级相同</strong>) 所以以下语句先让<code>str++</code>, 且<code>str++</code>返回的是自增之前的值(不同于<code>++str</code>).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">＊str++ != <span class="hljs-string">&#x27;\0&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>const char ＊str</code> 作为参数的意思是, <strong>不允许通过str这个指针来修改它指向的字符</strong>, 不等同于不能修改这个字符本身. </p></li><li><p><code>const char ＊str</code> 和 <code>char const ＊str</code> 是一样的, 限制str指针所指向的字符不能修改. 但是, <code>char * const str</code> 就不同了, 它限制了str 这个指针是一个常量指向char类型,  限制指针不能被修改 (即<code>str++</code>不允许)</p></li><li><p><code>size_t</code> 是什么类型, 可以理解成无符号长长整型, 且与机器无关, 配合**%zu**使用. </p></li><li><p><strong>指针是怎么来的?</strong> 1) 所有的数据存放在内存里 2) 内存可以编号, 即地址, 通过地址可访问内容 3) 一个数据类型占有若干个byte(字节), 那么把其占据的几个byte的第一个byte的地址作为指针的值.</p></li></ol><h2 id="Lesson-9-指针高级"><a href="#Lesson-9-指针高级" class="headerlink" title="Lesson 9: 指针高级"></a>Lesson 9: 指针高级</h2><ol><li><p><code>strcpy</code>: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">StrCpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span> &#123;<br>  <span class="hljs-keyword">while</span> ((*dest++ = *src++)); <span class="hljs-comment">// 写成指针, 去掉循环控制变量, &#x27;\0&#x27; 的ascii就是 0</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>strncmp</code>: 比较两个字符串中的最多前n个字符 </p></li><li><p>指针数组: 每个元素是一个指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *names[LEN] <span class="hljs-comment">//指针数组定义</span><br><br>Swap(&amp;str[i], &amp;str[min_index]); <br><span class="hljs-comment">// 相应的, 要再取一次地址, 才能传入一个二级指针</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(<span class="hljs-type">char</span> **left, <span class="hljs-type">char</span> **right)</span> &#123;<br>  <span class="hljs-type">char</span> *tmp = *left; <span class="hljs-comment">// left 实际上是二级指针, 用 * 解一次引用解出来一个指向char的指针</span><br>  *left = *right; <span class="hljs-comment">// 这样修改的是指向字符串字面量的指针</span><br>  *right = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于多维数组, 你只需要记住: <strong>C语言没有二维数组, 只有数组的数组.</strong></p><p>二维数组是一个指向数组的指针, 二维数组是一个二级指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> score[ROWS][COLS] = <span class="hljs-built_in">malloc</span>(ROWS * COLS * <span class="hljs-keyword">sizeof</span> **score); <span class="hljs-comment">// 感觉不如写sizeof(int)</span><br><span class="hljs-keyword">if</span> (score == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>运算符优先级</strong> : </p><p>​(suffix)++, (), [], <strong>.</strong> , -&gt; </p><p>​                        ++(prefix) , * , &amp; , ! , <strong>~</strong> , sizeof</p><p>​*, &#x2F;, %</p><p>​+, -</p><p>​&lt;&lt;, &gt;&gt;</p></li><li><p>[] &#x2F;&#x2F; 取数组下标符具有左结合性, 即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> student_score_table[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>] = &#123;<br>      &#123;<span class="hljs-number">0</span>,  <span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;,<br>      &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;,<br>      &#123;<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;,<br>      &#123;<span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;,<br>      &#123;<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;<br>  &#125;; <span class="hljs-comment">// 可以理解为是一个大小为5的数组, 数组里面是一个大小为3的数组</span><br><br><span class="hljs-comment">/**指针访问二维数组*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_score_table[3][2] = %d\n&quot;</span>,<br>         student_score_table[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_score_table[3][2] = %d\n&quot;</span>,<br>         (*(student_score_table + <span class="hljs-number">3</span>))[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_score_table[3][2] = %d\n&quot;</span>,<br>         (*(*(student_score_table + <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>)));<br></code></pre></td></tr></table></figure></li></ol><h2 id="Lesson-10-函数指针-结构体"><a href="#Lesson-10-函数指针-结构体" class="headerlink" title="Lesson 10: 函数指针&#x2F;结构体"></a>Lesson 10: 函数指针&#x2F;结构体</h2><ol><li><p>main函数里面是可以有参数的, main函数可以接受两个参数 <code>argc</code> (argument count计数, 调用了几个参数) 和 <code>argv</code> (argument vector) 一个数组, 数组里每个元素是一个指针, 指向char.</p><p><code> int main(int argc, char *argv[]) &#123;&#125;</code></p></li><li><p>C语言中约定<code>argv[0]</code>存储了程序的名字(argv[0] is the name of program)(当然一些环境或操作系统中<code>argv[0]</code>是一个空指针, 不存放任何东西但是占了位), 所以<strong>真正的存入argv[]是从下标1开始存入的</strong>.</p></li><li><p>C语言标准规定 <code>argv[argc]</code> is NULL (一定是一个空指针).</p><p>如: hello world </p><p>argc &#x3D;&#x3D; 3;</p><p>argv[0] &#x3D;&#x3D; “echo”(文件名), argv[1] &#x3D;&#x3D; “hello”, argv[2] &#x3D;&#x3D; “world”, argv[3] &#x3D;&#x3D;NULL</p></li><li><p><code>printf</code>函数可以结合表达式使用 <code>printf((argc &gt; 1) ? &quot;%s &quot; : &quot;%s&quot;, *++argv);</code></p></li><li><p><code>void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );</code>  </p><p>参数含义: 1. 待排序数组首地址(数组名) 2. 数组中元素数 3. 每一个元素的字节数 4. comp是一个指针, <strong>指向一个函数</strong>  &#x3D;&#x3D;<strong>(函数指针, functional pointer)</strong>&#x3D;&#x3D;, 指向的函数有两个参数是void型, 返回值是int.</p></li><li><p>如何获取数组长度: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> integers[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; <br><span class="hljs-type">int</span> size_of_integers = <span class="hljs-keyword">sizeof</span> integers / <span class="hljs-keyword">sizeof</span> *integers; <span class="hljs-comment">// 计算数组长度 sizeof一个数组就是返回整个数组的字节数, 注意这里sizeof不要在后面跟(), 但是sizeof(int)需要</span><br></code></pre></td></tr></table></figure></li><li><p>在C语言中<strong>函数名本身就是一个指针</strong>. <code>CompareInts()</code>这个函数, 在作为第四个参数传入<code>qsort()</code>时, 只要写<code>CompareInts</code>就代表一个函数指针. </p></li><li><p>当函数名出现在表达式中时, C语言解释其为函数指针(也就是说, C语言中, 函数就是函数指针). </p></li><li><p>函数指针和其它指针一样用, 你还可以构建一个<strong>函数指针数组</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> (*fps[<span class="hljs-number">2</span>])(<span class="hljs-type">double</span>) = &#123;<span class="hljs-built_in">sin</span>, <span class="hljs-built_in">cos</span>&#125;;  <span class="hljs-comment">// fps是一个数组, 有两个元素, 每个元素是一个指针, 指向一个函数, 这个函数接受一个double返回一个double</span><br></code></pre></td></tr></table></figure></li><li><p>函数指针说到底是一个变量, 是变量就可以声明, 可以修改.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*comp)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) = CompareInts; <span class="hljs-comment">// 很诡异的一个声明和赋值, 这样之后comp就完全等价于CompareInts, 在C语言中是不需要再对函数指针再解引用了(即不需要写*comp, 区别于传统指针)</span><br></code></pre></td></tr></table></figure></li><li><p>除了<code>qsort</code>, C语言还有<code>bsearch</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">bsearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmem, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> (*comp)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>; <span class="hljs-comment">// base指向被查找的数组, nmem为查找长度, size为每个元素的大小, comp同qsort()的</span><br></code></pre></td></tr></table></figure></li><li><p>那么有了函数指针, 函数就是一个一般变量了, 可以作为<strong>函数的参数, 函数的返回值, 数组的元素</strong> , 可以声明, 定义, 可以赋值, 函数指针可以干任何一般变量能做到的. 函数就成为了一等公民.</p></li><li><p>复杂的函数声明: 核心是指针与数组 &#x2F;  <code>*</code>, <code>[]</code>, <code>()</code>三个运算符的结合与优先. </p><p>题目1: 解释以下输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*arr)[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu&quot;</span>, <span class="hljs-keyword">sizeof</span> (arr)); <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu&quot;</span>, <span class="hljs-keyword">sizeof</span> (*arr)); <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>题目2: 解释以下声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure></li><li><p>使用<code>typedef</code>定义特定类型<strong>函数指针的别名</strong> <code>typedef int (*NICKNAME)(int, int);</code> 这样 <code>NICKNAME fun;</code> 就是对fun的一个声明.</p></li><li><p><strong>struct</strong>: 一种数据类型, 与int, char等等一样. </p></li><li><p>使用 <code>typedef struct musician &#123;, , , ,&#125; Musician;</code> &#x2F;&#x2F; 用别名Musician替代struct musician</p></li><li><p>结构体<strong>填充&#x2F;内存对齐</strong>, 结构体的存储是有要求的, 结构体成员里面最大字节数如果为8, 那么必须要首地址是8的倍数, 尾地址也要是8的倍数. </p></li><li><p>结构体也可以通过赋值号( <strong>&#x3D;</strong> )来赋值, 当然, 前提是两个结构体类型相同.</p></li><li><p>结构体变量也可以<strong>直接</strong>作为参数进行函数传参, 但是, 应该使用结构体指针进行传参以避免直接传结构体降低程序效率.</p></li><li><p>结构体成员名可以和main函数中的变量重名.</p></li><li><p>使用   <em><strong>结构体变量名</strong></em> <strong>.</strong>  <em><strong>内部的变量名</strong></em>  (点表达式) 来访问结构体内部. </p></li><li><p>结构体变量名就是一个结构体变量, 对其取址(&amp;musician)得到的就是一个<strong>结构体指针</strong>(指向结构体变量的指针)  (用结构体指针可以实现结构体的跨函数传递, 比<em>直接传递结构体</em>性能更高).</p></li><li><p>C语言<strong>不支持结构体直接判断相等</strong>. 即<code>struct1 == struct2</code>是<strong>不可以</strong>的(<em><strong>C中能用&#x3D;&#x3D;判断相等的只能是基本数据类型</strong></em>), 思考: </p><ol><li><p><code>ptr1 == ptr2</code> <strong>意味着什么?</strong></p></li><li><p><code>struct1</code>和<code>struct2 </code>的每一个成员都相等, <strong>又意味着什么?</strong></p></li></ol></li><li><p>结构体指针示例: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PrintMusician</span><span class="hljs-params">(Musician *m)</span> &#123; <span class="hljs-comment">// m为一个结构体指针(特别常用的做法)</span><br>(*m).name <span class="hljs-comment">// 通过指针访问结构体内部的变量方法1(注意.的优先级最高, 所以括号不能省略)</span><br>    m-&gt;gender <span class="hljs-comment">// 通过指针访问结构体内部的变量方法2</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>动态申请结构体:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> *<span class="hljs-title">book1</span>;</span><br>book1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*book1));<br><br><span class="hljs-comment">//也可以写成: </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> *<span class="hljs-title">book1</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*book1));<br><span class="hljs-comment">// malloc之后下意识检查是否malloc到了空指针</span><br><span class="hljs-keyword">if</span> (book1 == <span class="hljs-literal">NULL</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>enum</code> 枚举类型.</p></li></ol><p>​定义某一个数据类型, 这种类型只有几种可能, 在定义的同时将这些可能一一列举出来, 这样的类型就叫枚举.</p><h2 id="Lesson-11-链表"><a href="#Lesson-11-链表" class="headerlink" title="Lesson 11: 链表"></a>Lesson 11: 链表</h2><ol><li><p>链表的每一个**节点(Node)**就是一个结构体, 这个结构体的第一个域可以是一个整数, 第二个域需要是一个指针(叫作next, 指向链表的下一个节点). 链表就是通过指针把多个结构体连在一起.</p></li><li><p>链表和数组的区别在于数组的内存空间是连续的, 而链表每个节点都是<code>malloc</code>动态申请来的, 没法保证每一个的内存空间是连续的.</p><p>所以要访问链表的某个节点就只能从头开始往后扫描(最坏的时间复杂度是O(n)而数组为O(1) ).</p><p>(好处在于灵活, 所以插入&#x2F;删除链表节点时间复杂度O[1], 而插入&#x2F;删除数组元素时间复杂度最 坏O(n) )</p></li><li><p>链表实现了数据的动态保存, 不需要预先分配内存空间, 而是在需要时动态申请, 整个空间可以根据需要扩大或缩小.</p></li><li><p>双向链表: 一个指针(pre)指向前面, 一个指针(next)指向后面.</p></li><li><p>循环链表: 最后一个节点的next指针指向Head.</p></li><li><p>解决链表问题: 先想一般情况, 再讨论特殊情况 (空链表&#x2F;链表只有一个节点), 再看这两类有没有可以合并的. </p></li><li><p>删除节点函数Delete写的时候不应该传递被删除节点, 应传前一个指针. (双向链表无所谓)</p></li><li><p>如果删了head或tail节点, 要记得更新head或tail.</p></li><li><p>如果只想要在某函数符合特定条件的时候才调用一个函数, (如只有只剩1人时才return幸存者编号, 其它情况不使用该函数).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br>assert(IsSingleton(<span class="hljs-built_in">list</span>)); <span class="hljs-comment">// 做一个判断, 不成立就报错. (assert 断言)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* assert一般用于调试, 真正发布时, 要将assert去掉</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure></li><li><p>常见的链表操作补充: </p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(LinkedList *<span class="hljs-built_in">list</span>, Node *prev, <span class="hljs-type">int</span> val)</span>;<br>Node *<span class="hljs-title function_">Search</span><span class="hljs-params">(LinkedList *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> val)</span>;<br></code></pre></td></tr></table></figure></li><li><p>特殊头节点: 不存数据, 链表的长度. 对头节点的删除操作, 不用特殊化处理. (方便读取链表的长度, 可用于频繁获取链表长度的情形)</p></li><li><p>打印&#x2F;遍历链表: </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p-&gt;data);<br>p = p-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Lesson-12-预处理"><a href="#Lesson-12-预处理" class="headerlink" title="Lesson 12: 预处理"></a>Lesson 12: 预处理</h2><ol><li><p>预处理就是字符串替换.</p></li><li><p>宏函数<strong>可以</strong>接受不定长度的参数 </p><p>例如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(a, ...) <span class="hljs-keyword">if</span>(a) printf(__VA_ARGS__)</span><br><span class="hljs-comment">// or another way: </span><br><span class="hljs-comment">// #define print(format, ...)  printf(format, ##__VA_ARGS__)</span><br><br>print(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;To C or not to C&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>当你想要把多个语句放在一起作为一个宏函数时, use <em><code>do&#123; &#125;while(0)</code></em></p><p>这样的好处是, 如果调用宏函数, 就需要在末尾加; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo() do &#123;bar(); baz();&#125; while(0)</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) foo(); <span class="hljs-comment">// 这样就十分自然地写出了看起来没有问题, 实际上也没问题的代码.</span><br></code></pre></td></tr></table></figure></li><li><p>一些系统给的宏 <code>__x86_64__</code> 如果定义了就是在64-bit 环境下.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __x86_64__</span><br><span class="hljs-comment">// do sth</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br><span class="hljs-comment">// do sth</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 帮助定位错误的宏: </span><br>__FUNCTION__<br>__LINE__<br>    <br>__VA_ARGS__ <span class="hljs-comment">// C99引入, 表示一个或多个参数, 类似函数可变参数中的省略号</span><br><span class="hljs-comment">// 示例:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(format, ...) printf(format, ##__VA_ARGS__) <span class="hljs-comment">// 为什么使用## 如果不带##, __VA_ARGS__会替换为省略号匹配的所有参数, 同时会将省略号前面的一个逗号带上, 导致编译器报错, ##提示编译器把多余的逗号删除</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>#</code>和<code>##</code>运算符:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> concat(a, b) a ## b <span class="hljs-comment">// 把a和b字符串合并</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string(a) #a <span class="hljs-comment">// 给a的两边加上双引号, 变成字符串</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>##</code> 运算符</p><p><code>##</code>可以将两个记号 (如标识符) “<strong>粘合</strong>“ 在一起, 成为一个记号. (##运算符被称为”记号粘合”) 如果其中一个操作数是宏参数, “粘合”会在形式参数被相应的实参替换后发生. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MK_ID(n) i##n</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;<br><span class="hljs-comment">// 就是int i1, i2, i3;</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GENERIC_MAX(type)</span><br>type type##_max(type x, type y) &#123;  \<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y;  \<br>&#125;<br><br>GENERIC_MAX(<span class="hljs-type">float</span>)<br><span class="hljs-comment">// float float_max(float x, float y) &#123; return x &gt; y ? x : y;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>如果对于字符串进行宏定义替换, 替换之后又要进行 ## 或者是 # 的操作, 又不希望因为直接做##或#而忽略掉之前的宏定义, 就可以使用一个temp宏作为中介使得一趟替换之后没有到位, 而是转入temp宏, 这样就能够使得字符串替换不被忽略掉.</p></li><li><p><strong>预处理指令</strong></p><p><code>#include</code>  包含</p><p><code>#define</code>  宏定义</p><p>(根据条件判断来选择编译的内容)</p><p><code>#if </code>       如果, 则预定义</p><p><code>#else</code>   否则, 预定义</p><p><code>#elif </code>    否则如果, 则预定义</p><p><code>#endif </code> 结束条件判断</p><p><code>#ifdef</code>  如果定义了, 则 (if define)</p><p><code>#ifndef </code> 如果没定义, 则 (if not define)</p></li><li><p><code>#include</code></p></li></ol><p>​两种形式 &lt;&gt; 到配置目录中找和 “ “从当前目录开始找, 无则到配置目录里找.</p><p>​文件包含允许嵌套. A包含B, B包含C, 那么A包含了B和C</p><ol start="3"><li><p><code>#define</code> </p><p>宏定义, 可以带参数. </p></li><li><p>条件编译 (为了提高可移植性的)</p><p>#if (<strong>常量表达式</strong>)   –&gt; 注意常量, 非变量</p><p>仅当表达式为真, 才编译它与<code>#endif</code>之间的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> beta 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> status 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (status == debug)</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序调试中\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (status == beta)</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序测试中\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;欢迎使用正式版!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*-----------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PI        <span class="hljs-comment">// 这个判断是为了避免重复定义, 常用于一些复杂的文件</span></span><br>define PI <span class="hljs-number">3.14</span> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>         </span><br></code></pre></td></tr></table></figure></li><li><p>常用宏函数: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAP(a, b) \        <span class="hljs-comment">// 这里的反斜杠是续行, 一般在C语言中只在宏定义中才会用到</span></span><br>    <span class="hljs-keyword">do</span> &#123;           \        <span class="hljs-comment">// 为什么不给a, b加括号, 因为 = 是除了 , 最低优先级的运算符</span><br>        <span class="hljs-type">int</span> t = a; \<br>        a = b;     \<br>        b = t;     \<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>) <span class="hljs-comment">//宏需写在代码头文件下面，此为简单版，交换两个 int 型数字</span><br><br><span class="hljs-comment">// 最简洁的swap</span><br>x ^= y ^= x ^= y;  <span class="hljs-comment">//异或真神奇！不过这究竟是为什么呢？</span><br></code></pre></td></tr></table></figure></li><li><p>定义宏函数: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ture 1 <span class="hljs-comment">// 把前面的字符串替换为后面的字符串</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> false 0 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> foo(bar) bar + 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dist(x1, y1, x2, y2) (abs((x1) - (x2) + abs((y1) - (y2))) <span class="hljs-comment">// 注意这里每一个变量都要加括号, 以避免变量内部有一个比&#x27;-&#x27;优先级更小的运算符</span></span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x1 - x2) + <span class="hljs-built_in">abs</span>(y1 - y2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>#include</code> 预编译的机制, 其实就是把被 include 的代码copy到当前的c文件中, 只是做了一个substitute的工作, 你可以写出以下的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hello.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">printf</span>(<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;inc.h&quot;</span></span><br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// inc.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span> </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.h</span><br>hello world<br></code></pre></td></tr></table></figure></li><li><p>用gcc<strong>预编译</strong> <code>gcc -E a.c | less</code> </p></li><li><p>然后用vim命令<code>\printf</code>搜索对应的函数的声明</p><p><code>extern int printf (const char *__restrict __format, ...);</code></p></li><li><p>将这行代码copy也可以实现 <code>printf</code> 函数.  </p><p>其实 <code>#include &lt;stdio.h&gt;</code> 就是把以上预编译的东西全部粘贴过来, 而其中起作用的就是 <code>printf</code> 的声明.</p></li><li><p>这就是C语言的规定, **<code>#include</code> 做的就是<em>纯文本</em>的复制粘贴. **</p></li><li><p>预处理过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> aa == bb</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码被预编译为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其它信息全部被擦除了. 一个变量如果是在预编译指令中, 那么不需要定义就可以使用, 其值是系统赋予的, 如<code>__x86_64__</code>, 而本例中,  aa和bb都是空, 所以二者相等.</p></li><li><p>适当使用预编译指令, 不要滥用. </p></li><li><p>预编译也称为元编程 (meta-programing) , 发生在实际编译之前. (C++的模板元编程) (gcc的预处理器同样可以处理汇编代码)</p></li></ol><h2 id="Lesson-13-位运算"><a href="#Lesson-13-位运算" class="headerlink" title="Lesson 13: 位运算"></a>Lesson 13: 位运算</h2><ol><li><p>移位运算符: &lt;&lt;  &gt;&gt;  ( 有符号数右移, 高位补什么视编译器而定, 一般补的是符号位(最高位) )</p><p>为什么有符号数右移视编译器而定? 历史久, 需要兼容各类系统, C标准没有规定.</p><p>向右移动x位相当于除以$2^x$</p></li><li><p>移位运算的使用</p><ul><li>在能满足需求的情况下, 使用无符号数进行移位运算</li><li>如果需要使用有符号数的移位运算, 请验证高位补偿的规则并考虑可移植性问题.</li></ul></li><li><p>按位与 ( &amp; )  按位或 ( | )  按位异或 ( ^ ) </p></li><li><p>一元运算 按位取反 ( ~ )  会对操作数进行<em>整型提升</em> (不能忽略前面的位)</p></li><li><p>优先级: ~ &gt; 二元算术运算 &gt; <strong>&lt;&lt;, &gt;&gt;</strong> &gt; 关系运算 &gt; &amp; &gt; | &gt; 逻辑运算</p></li><li><p>几个常见的错误示例:</p><p><code>status &amp; 0x4000 != 0</code> 表示先不等于0, 然后与运算</p><p><code>i &lt;&lt; 2 + 1</code> 表示先把 2 + 1, 再移位</p></li><li><p>使用位运算访问位 将num的 (从低开始的) 第i位读取出来. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">num &amp; (<span class="hljs-number">1</span> &lt;&lt; i)<br></code></pre></td></tr></table></figure><p>将该位设置成0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">num &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; i)<br></code></pre></td></tr></table></figure><p>将该位设置成1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">num |= (<span class="hljs-number">1</span> &lt;&lt; i)<br></code></pre></td></tr></table></figure></li><li><p>使用位运算访问位域</p><p>将 1 &lt;&lt; i 替换为多个1bit (如 0x0070) 操作第4 - 6位</p></li><li><p>异或加密 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">a <span class="hljs-built_in">^</span> a = 0<br>a <span class="hljs-built_in">^</span> 0 = a<br>a <span class="hljs-built_in">^</span> b <span class="hljs-built_in">^</span> b = a<br></code></pre></td></tr></table></figure><p>加密方式: 有信息M, 秘钥K, 可以使用M’ &#x3D; M ^ K获得密文, 再使用M’ ^ K &#x3D; M ^ K ^ K &#x3D; M进行解密.</p></li><li><p>bit vector 位向量</p><p>一个长度为N的bit流可以表示一个最多有N个元素的集合. 下标 i 对应元素的布尔值如果为true就代表i这个数字在集合set中, 以此表示一个N个元素的集合.</p><p>有什么用? 代替bool数组, (因为bool类型是C99后才有的), 可以换取空间优势.</p><p>做集合的 <strong>交 &#x2F; 并 &#x2F; 差</strong> 运算时性能可观. </p></li><li><p>例: 交换一个32位整数的高16位和低16位. </p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">y = ((x &amp; <span class="hljs-number">0xFFFF</span>) &gt;&gt; <span class="hljs-number">16</span>) | ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span>)<br></code></pre></td></tr></table></figure></li><li><p>例: 取以2为底的对数的整数部分 [Log<sub>2</sub> x]</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getLg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xffff0000</span>) &#123;ans += <span class="hljs-number">16</span>; x &amp;= <span class="hljs-number">0xffff0000</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xff00ff00</span>) &#123;ans += <span class="hljs-number">8</span>; x &amp;= <span class="hljs-number">0xff00ff00</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xf0f0f0f0</span>) &#123;ans += <span class="hljs-number">4</span>; x &amp;= <span class="hljs-number">0xf0f0f0f0</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xcccccccc</span>) &#123;ans += <span class="hljs-number">2</span>; x &amp;= <span class="hljs-number">0xcccccccc</span>;&#125;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">0xaaaaaaaa</span>) &#123;ans += <span class="hljs-number">1</span>; x &amp;= <span class="hljs-number">0xaaaaaaaa</span>;&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Sp-Lesson-1-git"><a href="#Sp-Lesson-1-git" class="headerlink" title="Sp Lesson-1 git"></a>Sp Lesson-1 git</h2><ol><li><p>git就是一系列快照, git add 就是把文件加到临时快照里, commit就是把临时快照持久化, 而分支就是不同的程序员在进行各自的开发时使用便于管理的.</p></li><li><p>常用命令: </p><p><code>git init</code><br><code>git status</code><br><code>git commit -m &quot;&quot;</code><br><code>git log</code><br><code>git add -A //把当前文件夹中所有的纳入跟踪, 添加到暂存区</code><br><code>git checkout fe923 // fe923就是你某一次提交代号的前几位</code><br><code>git checkout 8f49c // 回到某一次具体的提交(可以是已经被回退掉的版本号)</code></p><p><code>git checkout -b &quot;git&quot; // 新建并转到命名为&quot;git&quot;的分支</code><br><code>git checkout master // 回到&quot;master&quot;分支</code><br><code>git branch // 查看分支信息</code><br><code>git merge // 合并分支</code></p><p><code>git merge git 进入一个界面, vim模式, 先按i进行insert编辑后, 按esc退出</code></p></li><li><p>主流的版本控制器 Git SVN</p></li><li><p>版本控制分类 1) 本地版本控制 2) 集中版本控制(所有的版本数据存在服务器上, 代表工具<code>SVN</code>) 3) 分布式版本控制 (每个人都拥有全部的代码, 服务器或者任一用户的保存损坏了都不会有影响, 只要再重新拷贝一份就可以了, 代表Git)</p></li><li><p>Git是目前世界上最先进的分布式版本控制系统</p></li><li><p>2005 Linus Torvalds 用2周时间开发出了自己的版本控制系统, 也就是后来的Git (为了辅助Linux内核, 开源, 免费)</p></li><li><p>Git Bash: Unix 与 Linux 风格的命令行, 使用最多, 推荐最多</p><p>Git CMD: Windows 风格的命令行</p><p>Git GUI: 图形界面的Git, 不建议使用</p></li><li><p>环境变量只是为了全局使用.</p></li><li><p><strong>Git 基本理论</strong> </p><blockquote><p>工作区域 </p></blockquote><p>Git 本地有三个工作区域: <strong>工作目录 ( Working Directory )</strong> , <strong>暂存区 (Stage&#x2F; Index)</strong> , <strong>资源库 (Repository &#x2F; Git Directory)</strong> , 如果在加上<strong>远程的git仓库 (Remote Directory)</strong> 就可以分成四个工作区域. </p><ul><li>&#x3D;&#x3D;<strong>Workspace</strong>&#x3D;&#x3D;: 工作区, 就是你平时存放项目代码的地方</li><li><strong>Index &#x2F; Stage</strong>:  暂存区, 用于临时存放你的变动, 事实上只是一个文件.</li><li><strong>Repository</strong>: 仓库区 ( 或本地仓库 ) , 就是安全存放数据的位置, 有所有的版本的数据. 其中HEAD指向最新放入仓库的版本.</li><li>&#x3D;&#x3D;<strong>Remote</strong>&#x3D;&#x3D;: 远程仓库, 托管代码的服务器.</li></ul><p>HEAD一开始指向的是master分支 (主分支).</p><p>在文件中有一个隐藏文件夹<code>.git</code> 其中有Stage 和 Local Repo文件夹</p></li><li><p>git的工作流程: </p><ol><li>在工作目录中添加修改文件;</li><li>将需要进行版本管理的文件放入暂存区域; <code>git add .</code>    (**.**表示全部)</li><li>将暂存区域的文件提交到git仓库</li></ol></li><li><p>Git项目搭建</p></li></ol><blockquote><p>创建工作目录与常用指令</p></blockquote><p>   工作目录 (WorkSpace) 可以是项目的目录, 不要有中文. </p><blockquote><p>本地仓库搭建</p></blockquote><p>   一种方法是创建全新的仓库, 另一种是克隆远程仓库.</p><ul><li><p>创建全新的仓库, <code>git init</code> 执行后在项目目录多出了一个 .git目录, 关于版本的所有信息都在这个目录里面.</p></li><li><p>克隆远程仓库到本地. <code>git clone ... </code> 然后就行了 </p><table><thead><tr><th>HTTP</th><th>利于匿名访问</th><th>适合开源项目</th><th align="center">可以方便被别人克隆和读取(但没有push权限, push需验证)</th></tr></thead><tbody><tr><td><strong>SSH</strong></td><td><strong>不利于匿名访问</strong></td><td><strong>比较适合内部项目</strong></td><td align="center"><strong>只要配置了SSH公钥即可自由实现clone和push操作</strong></td></tr></tbody></table><center>(HTTP 和 SSH协议的对比)<center></li></ul><ol start="11"><li><p>Git文件操作</p><blockquote><p>文件4种状态</p></blockquote><ul><li><strong>Untracked</strong>: 未跟踪,在文件夹中, 但没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code>.</li><li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照与文件夹中内容一致, 如果被修改, 状态变为<code>Modified</code>. 如果使用<code>git rm</code>则成为<code>Untracked</code>文件.</li><li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 有两个去处, 通过<code>git add</code>可进入暂存<code>Stage</code>状态, 使用<code>git checkout</code>则丢弃修改, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改.</li><li><strong>Staged</strong>: 暂存状态, 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code>.</li></ul></li><li><p>git文件操作命令: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git status <span class="hljs-comment"># Untracked</span><br>git add .<br>git status <span class="hljs-comment">#  to be commit (在*暂存区*里)</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment"># 提交到本地仓库</span><br>git status<br>git push<br></code></pre></td></tr></table></figure><blockquote><p>忽略文件</p></blockquote><p>在主目录下建立”.gitignore”文件, 此文件有如下规则:</p><ol><li>忽略文件中的空行和以井号 ( # ) 开始的行.</li><li>可以使用Linux通配符. 例如 : 星号( * )代表任意多个字符, 问号( ? )代表一个字符, 方括号 ( <strong>[…]</strong> ) 代表可选字符范围, 大括号( **{…} **)代表可选的字符串等.</li><li>如果名称的最前面有一个感叹号 ( ! ) , 表示例外规则, 将不被忽略.</li><li>如果名称的最前面是一个路径分隔符 ( &#x2F; ) , 表示要忽略的的文件在此目录下, 而子目录中的文件不忽略.</li><li>如果名称的最后面是一个路径分隔符 ( &#x2F; ) , 表示要忽略的是此目录下该名称的子目录, 而非文件 (默认文件或目录都忽略).</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.txt <span class="hljs-comment"># 忽略所有.txt结尾的文件</span><br>!lib.txt <span class="hljs-comment"># 但lib.txt除外</span><br>/temp    <span class="hljs-comment"># 仅忽略项目目录下的TODO文件, 不包括其它目录temp</span><br>build/      <span class="hljs-comment"># 忽略build/目录下的所有文件</span><br>doc/*.txt   <span class="hljs-comment"># (忽略某个文件夹下的文件)会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Git分支</strong> </p><ul><li>master: 主分支</li><li>dev: 开发(develop)用</li><li>v4.2: 不同版本的分支</li></ul><p>git中常用的分支命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment"># 列出所有本地分支</span><br>git branch -r  <span class="hljs-comment"># 列出所有远程分支</span><br>git branch [name]  <span class="hljs-comment"># 新建一个分支, 但依然停留在当前分支</span><br>git checkout -b [branch]  <span class="hljs-comment"># 新建一个分支, 并切换到该分支</span><br>git merge [branch]  <span class="hljs-comment"># 合并分支到当前分支</span><br>git branch -d [name]  <span class="hljs-comment"># 删除分支</span><br><br><span class="hljs-comment"># 删除远程分支</span><br>git push origin --delete [name]<br>git branch -dr [remote / branch]<br></code></pre></td></tr></table></figure><p>如果多个分支冲突了, 只要协商即可.</p></li><li><p><code>git commit --allow-empty</code> 允许无修改</p></li></ol><h2 id="Sp-Lesson-2-Vim"><a href="#Sp-Lesson-2-Vim" class="headerlink" title="Sp Lesson-2  Vim"></a>Sp Lesson-2  Vim</h2><ol><li><p><code>u</code> 撤销上一步操作</p></li><li><p><code>ctrl v</code> 块操作</p></li><li><p>强制退出 <code>:q!</code></p></li><li><p><strong>查找命令</strong>:  <code>:/</code> 正向查找   <code>:?</code> 反向查找 </p><p><code>n</code> 前向查找   <code>N</code> 反向查找</p><p>快速查找 : 1) 将光标移动到目标单词上  2) 按下<code>*</code>启动正向查找 <code>#</code> 反向查找</p></li><li><p><code>gg</code> : 回到顶部 <code>G</code> : 回到底部</p></li><li><p><code>$</code>: 跳转行末</p></li><li><p><code>0</code>: 行首</p></li><li><p><code>Ctrl+f</code>：向文件尾翻一屏</p><p><code>Ctrl+b</code>：向文件首部翻一屏</p><p><code>Ctrl+d</code>：向文件尾部翻半屏</p><p><code>Ctrl+u</code>：向文件首部翻半屏</p></li><li><ol><li><p><code>dw</code>  从光标当前的位置开始删除，直到删到单词最后。</p></li><li><p><code>daw</code>  算是1的属性扩充版，这个命令可以直接删除光标所在的一个单词。为了方便记忆，可以记忆为delete a word缩写。</p></li><li><p><code>bdw</code>  这也是一个复合命令。b可以让光标回退到单词开头的位置，而<code>dw</code>则是第1个描述过的命令。</p></li><li><p><code>ciw</code>  修改一个单词，change in word的缩写。</p></li><li><p><code>Shift d</code> 从光标处删除到行末尾.</p></li></ol></li><li><p><code>vs</code> 分栏 <code>e 文件名</code> 切换到文件</p></li><li><p>重命名某一个字符串 <code>%s/原字符串/新的字符串/g</code></p></li></ol><h2 id="Sp-Lesson-3-命令行"><a href="#Sp-Lesson-3-命令行" class="headerlink" title="Sp Lesson-3 命令行"></a>Sp Lesson-3 命令行</h2><ol><li><p><code>cat /hello.txt </code> 查看文件 ( 将文件内容输出至终端 ) (catch 抓来看看)</p></li><li><p><code>date</code> 获取当前的日期和时间</p></li><li><p><code>pwd</code> 获取当前的路径 (print work directory)</p></li><li><p>Linux下有一个整体的根目录. (从UNIX过来) Windows没有 (从DOS过来)</p></li><li><p><code>.</code>表示当前目录, <code>./home</code></p></li><li><p><code>..</code> 表示上一级目录 </p></li><li><p><code>echo</code>: 回声</p></li><li><p><code>man ls</code> :  man即manual, 手册</p></li><li><p><code>which ls</code>: 查看命令的位置</p></li><li><p><code>echo hello &gt; hello.txt</code>  输出重定向到 <code>hello.txt</code> 里</p></li><li><p><code>time</code> 对于任何一个命令都可以使用 <code>time</code> 来查看运行时间. <code>time ./a.out</code> 来查看可执行文件的运行时间</p></li><li><p><code>timeout</code> 倒计时 .. 秒, 若进程没有终止则强行停止. (可用于检测程序性能, 强行终止死循环等)</p></li><li><p><code>find</code> 寻找文件, 如 <code>find . | grep \.cpp$</code></p></li><li><p><code>grep</code>命令用于查找文件里符合条件的字符串或正则表达式</p></li><li><p><code>wc</code> 统计行数, 加<code>-l</code>只输出行数.</p></li><li><p><code>find . | grep \.c$ | xargs cat | wc -l</code> 利用管道协作, 统计所有c语言代码行数 (xargs 的功能, 将输入转换成后面命令的参数)</p></li><li><p>使用 <code>... | vim - </code> , 用vim打开前面命令的输出.</p></li><li><p>什么是管道命令? <code>命令1 | 命令2</code> 命令1的标准输出是命令2的标准输入. (以前面命令的输出作为后面一个命令的输入, 以此类推 ) </p><p>(注: 管道命令后面接的命令必须能够接收输入的命令, 不能接不能接收输入的命令, 比如ls cp mv等)</p></li><li><p>命令行中, 若要使用括号, 需要写作<code>$( ... )</code>左括号前加$</p></li><li><p>Linux命令行编程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 1 100) <span class="hljs-comment"># 所谓 $(seq 1 100) 本质上就是文本, 即 1 2 3 4 5 ... 100</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>(命令行的 2 个关键词: 文本, 工具)</p></li><li><p>编写 .sh 文件 (shell 脚本) 来帮你对拍&#x2F; 调试程序. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>gcc bad.c -o bad.exe<br>gcc ok.c -o ok.exe<br><br>for i in $(seq 1 5)<br>do <br>echo ======= Test case $i ========<br>cp hello$&#123;i&#125;.in hello.in<br>./a.out<br>cat hello.out<br>done<br><br>for T in $(seq 1 100)<br>do<br>echo Testcase $T<br>./gen # 生成输入<br>echo &quot;100 + 200&quot; &gt; in.txt<br><br>diff -q \<br>&lt;(timeout 1 ./ok.exe &lt; in.txt) \<br>&lt;(timeout 1 ./bad.exe &lt; in.txt)<br>if [[ $? != 0]]<br>then <br>echo &#x27;Error!&#x27;<br>fi<br>done<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>run.sh</code> 文件, 编写文件内容为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in $(seq 1 3) <br>do <br>./a.out &lt; in$i.txt &gt; out$i.txt<br>diff ans$i.txt out$i.txt || echo &quot;Error on Testcase #$i&quot;<br>done<br></code></pre></td></tr></table></figure><p>这样就实现了一个对拍脚本. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">:: 在终端中运行脚本<br>bash run.sh<br></code></pre></td></tr></table></figure></li></ol><h2 id="Sp-Lesson-4-gdb"><a href="#Sp-Lesson-4-gdb" class="headerlink" title="Sp Lesson-4 gdb"></a>Sp Lesson-4 gdb</h2><ol><li><p><code>GDB</code>:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g ...<br>gdb ...<br></code></pre></td></tr></table></figure><p><code>start</code></p><p><code>next (n) 5</code> : 步过5行 </p><p><code>step (s)</code> : 步入</p><p><code>continue (c)</code>: &#x3D;&#x3D;跳转至下一断点所在行&#x3D;&#x3D; (from wherever we currently  are)</p><p><code>finish</code> : tell gdb to finish this current function call and then stop once we finish the call</p><p><code>bt</code> : back trace 查看若干级函数调用的历史记录和参数值</p><p><code>list</code> : 看代码</p><p> <code>b codes/main.c: 127</code> : 设置断点</p><p>( 另可在函数上打断点, <code>b main</code> )</p><p><code>info b  (i b)</code> : 查看断点信息</p><p><code>run (r)</code> : 从断点处或从头开始执行 (运行程序) </p><p><code>print i  (p i)</code></p><p><code>print &amp;i</code> : 查看 i 的地址值</p><p><code>set logging on</code> : 将gdb输出结果打印至日志文件中.                                                                  </p><p><code>watch</code> : 设置watchpoint以实时观察一个变量是否变化, 一旦变化, 就会输出变化信息. (查看设置了哪些watchpoint <code>info breakpoints(watchpoints)</code>) (用于避免反复<code>p</code>, 一般watch的是核心变量)</p><p><code>delete ID</code> : 删除断点 (delete 删除所有断点)  </p><p><code>display i</code> : 每次<code>n</code>都打印出i的值.</p><p><code>undisplay ID</code> : 停止跟踪ID下标的那个变量, 一般第一个display的下标为1  </p><p><code>up</code> : 返回上一级函数 (找到是谁在调用当前行)</p><p><code>backtrace</code> : 不再是一次一次地up , 而是直接全部 print the entire call stack , 看到所有的涉事指针作为参数传递时的函数调用栈. (进行 N 次<code>up</code>)</p><p><code>fin</code> : 执行完当前函数, 返回到上一调用层, 并打印返回值</p><p><code>whatis j (what j)</code> : 可以得知 j 的数据类型</p></li><li><p><code>gdb</code>高级</p><p><code>target record-full</code> : 记录所有东西</p><p><code>rn</code> (reversed-next) : 回退一步 ( <code>rs (reversed-step)  rc (reversed-continue)</code> )</p><p><code>set var x=15</code> : 改变x的值但是不退出gdb运行.</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/02/hello-world/"/>
    <url>/2024/03/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
